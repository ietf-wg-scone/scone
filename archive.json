{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-04-20T01:44:27.752009+00:00",
  "repo": "ietf-wg-scone/trone",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "bike shed",
      "description": "",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDON1dwo86qsnWm",
      "title": "Throughput advice format",
      "url": "https://github.com/ietf-wg-scone/trone/issues/1",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While we're figuring out how to agree on a throughput advice format we could initially include both options:\n\n- A TRAIN Packet always includes a payload field of size N after the SCID. \n- The third most significant bit is set to 1 when a network element updates the payload field. \n- If the bit is not set, the low 5 bits are used to signal a preset rate.",
      "createdAt": "2025-02-19T16:20:44Z",
      "updatedAt": "2025-04-08T11:32:27Z",
      "closedAt": "2025-04-08T11:32:26Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "We are back to the composability argument. TRAIN is designed to pick \"the lowest of multiple assertions\". During the discussion, I heard the view that there is no need for that, because in practice there is only one bottleneck and one TRAIN rewriter. I am really not sure about that -- I can really imagine a cascade of NATs, each believing that they are the only one enforcing bandwidth. The rule that you propose implies that any \"rewriter\" must check a specific bit, and if it is set jump to the payload and analyze it. Which implies that all on path agents will need to support \"checking the payload\", in which case I am not sure I see the point of having the information in the top bits.",
          "createdAt": "2025-02-20T08:15:50Z",
          "updatedAt": "2025-02-20T08:15:50Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's fine if we eventually converge on a single format / location for the advice (I have my bias already).  \nIn order to get there it might be useful to have both options on the table so we can do some early implementations and measurements.\n\nAlso, with regards to composability. I agree that there are possible cases, but they are probably not that common. A network element that only considers the top bits could simply not send throughput advice if it sees the \"check the payload\" bit. ",
          "createdAt": "2025-02-20T10:26:28Z",
          "updatedAt": "2025-02-20T10:26:28Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on the agreed design this issue is no longer relevant. ",
          "createdAt": "2025-04-08T11:32:26Z",
          "updatedAt": "2025-04-08T11:32:26Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDON1dwo86qspaJ",
      "title": "Name",
      "url": "https://github.com/ietf-wg-scone/trone/issues/2",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bike shed"
      ],
      "body": "We have a few options:\n\n1. Keep TRAIN\n2. Find something that fits TRONE\n3. Completely new name, e.g., Throughput Advice Signaling Protocol (TASP)\n\nI'd be fine with any of the above. ",
      "createdAt": "2025-02-19T16:24:24Z",
      "updatedAt": "2025-04-16T16:04:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could also call it SCONE.\n",
          "createdAt": "2025-04-16T16:04:53Z",
          "updatedAt": "2025-04-16T16:04:53Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDON1dwo86u3xiG",
      "title": "Adoption and Business implications of \"A single Rate Signal field\"",
      "url": "https://github.com/ietf-wg-scone/trone/issues/4",
      "state": "OPEN",
      "author": "atiwariphd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The payload of a TRONE packet consists of a single Rate Signal field\n\nI would like to raise an issue to make sure everyone understands the adoption and business implication of the above constraint. \n\nA single rate value does not clearly explain how this rate should be measured and how the two parties (the sender of the rate signal and recipient of the rate signal) should interpret this signal in a consistent fashion. So if two parties (a Communication Service Provider and a Content and Application Provider) want to use this signal, they will have to have offline discussions between their business and technical teams to establish a common way of interpreting this signal. \n\nThis inherently will create barriers to entry for small app startups to use TRONE because typically small startups do not have the luxury of hiring a large partnership and technology ecosystems team to interface with multiple CSPs around the world to figure out how to interpret the \"single rate signal\" coming from their network.\n\nWe need to ask ourselves, do we want IETF to design a protocol that is only usable by large companies with plenty of resources?",
      "createdAt": "2025-03-20T02:49:44Z",
      "updatedAt": "2025-03-20T10:44:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is a lot of value in simplicity. A single rate signal and guidance in the document around how to interpret the signal makes it easy to reason about. \nDifferent CSPs might measure conformance in different ways, but the associated action to detection of non-conforming traffic would likely be that policing is re-introduced for a flow, or that a lower rate is signaled. Both these actions can be detected and acted upon by the endpoints. ",
          "createdAt": "2025-03-20T10:44:23Z",
          "updatedAt": "2025-03-20T10:44:23Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDON1dwo86u5K3z",
      "title": "Client initiated TRONE signal (uplink direction) with implicit support for flow detection",
      "url": "https://github.com/ietf-wg-scone/trone/issues/5",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 of the draft shows \"QUIC Sender\", ie, the server initiates the TRONE signal toward the client. This implies that TRONE signal is going to be server initiated. This will result in having the \"network element\" listens to all IP flows in the downlink direction. This is CPU intensive\n2. The authors should consider a design that is independent of SNI-based flow detection\n3. The authors should reconsider this design and allow for CLIENT initiated TRONE signaling (uplink direction) with implicit support for  flow detection\n\nAs a point of reference, section 6 of draft mishra-scone-usercase-00, added following requirement:\nSCONE (aka TRONE) signal MUST be a client-application endpoint initiated to assist the network element (UPF/5G or PGW/4G) with the implicit flow detection\nplease see https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.1.1",
      "createdAt": "2025-03-20T06:13:47Z",
      "updatedAt": "2025-03-20T06:45:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TRONE packets are sent by each endpoint individually, so there is opportunity for the client to send an early TRONE packet such that a network element that keeps some flow state can use the presence of a TRONE packet as an indication to not do further DPI and SNI parsing etc. \nThe problem in the current draft version is that endpoints need to indicate support using transport parameters before  sending TRONE packets. The authors have discussed an approach where an opportunistic TRONE \"indication\" can be appended to a QUIC initial packet. The network element can use this information as an indication that the client is willing to receive rate signals. \nAs opposed to \"regular\" TRONE packets, this indication would have to be appended to the end of a QUIC Initial packet.",
          "createdAt": "2025-03-20T06:43:56Z",
          "updatedAt": "2025-03-20T06:45:35Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDON1dwo86u5RKN",
      "title": "Network Element initiate TRONE packet for Dynamic update of Throughput advise based on changing RAT or subscription plan",
      "url": "https://github.com/ietf-wg-scone/trone/issues/6",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 states \"A network element detects a TRONE packet by observing that a packet has a QUIC long header and the TRONE protocol version of 0xTBD.\" A network element then conditionally replaces the Rate Signal field with values of its choosing\"\n\nAbove implies that 'network element\" has to wait/rely on server to originate a TRONE packet for the NE to send advisory bit-rate towards the client.\n\nThis may not work well when we consider a use case such as the mobile user may move from one Radio Access Technology to another (4G to 5G or vice-versa) during an ongoing video session. Ideally, the NE should be in a position to send dynamically an  updated Throughput advisory bit-rate on its own without having to wait for server to originate a TRONE packet.\n\nIn another use case, there can be a need for the NE to send an updated Throughput advisory bitrate, if there is any change in consumption of subscribers' data plan.\n\nThere is also a requirement added in mishra-scone-usecase-00 that calls out:\nDynamic update - \"throughput advice\" MAY change during the ongoing flow and UPF/PGW SHOULD be able to send \"throughput advice\" to client-application-endpoint as soon as possible.\n\nPlease refer to https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.5.1\n\n",
      "createdAt": "2025-03-20T06:26:49Z",
      "updatedAt": "2025-03-20T06:54:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, we do want the ability to signal rate changes in a timely fashion. \nThere are however, a number of ways to achieve this. \nIf we make it cheap enough to update the rate signal field, we can provide guidance to endpoints to generate TRONE packets at a relatively high frequency. One such advice would be to send a new advice for every new application layer \"burst\" such as the transmission of a set of HLS/DASH video segments. \nFurthermore, it is possible for network elements to insert TRONE packets of its own and expand UDP datagrams. Hopefully this will not be needed, but can be a last resort if the TRONE packet frequency is too low. Special care needs to be taken to not run into Path MTU issues, so guidance around not expanding datagrams to sizes larger than 1200 bytes (smallest maximum datagram payload size that needs to be supported for QUIC v1/v2)  could be needed.",
          "createdAt": "2025-03-20T06:54:52Z",
          "updatedAt": "2025-03-20T06:54:52Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDON1dwo86u5cxB",
      "title": "Client-side explicit ACK for receipt of TRONE packet",
      "url": "https://github.com/ietf-wg-scone/trone/issues/7",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "7.3.  Feedback To Sender About Signals \n\nSuggest that the TRONE draft consider a use case for client to send an explicit ACK to the \"network element\" upon receiving a TRONE packet. Without an explicit ACK, a NE may not know if the client has received the latest Throughput advisory bit-rate. This may help the scenario where a client may not self regulate due to loss of TRONE packet with the most recent Throughput advisory bit-rate.\n\nAdding a requirement that support the ACK from client to the network element. \n\nI-D mishra-scone-usecase-00 listed the following requirement: \n\nClient-application endpoint SHOULD send acknowledgement receipt of throughput advisory signal from the network element using the SCONE (TRONE) signal\n\nhttps://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.3.1",
      "createdAt": "2025-03-20T06:50:46Z",
      "updatedAt": "2025-04-16T15:22:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if acknowledging the receipt of a specific TRONE packet adds much value. \nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place. \nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not. ",
          "createdAt": "2025-03-20T09:37:12Z",
          "updatedAt": "2025-03-20T09:37:12Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "Hi Marcus, I'm cross referring a comment posted on my GitHub RE client ACK. Please see below:\n\nhttps://github.com/smishra1200/SCONE-Use-Case/issues/1",
          "createdAt": "2025-04-01T23:21:41Z",
          "updatedAt": "2025-04-01T23:21:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The clients use TRONE because they seek the advice. You have to assume that they will heed that advice, largely because of self interest. Nobody want application data thrown out randomly and causing terrible UI artefacts.\n\nAs @ihlar says, if the network wants to enforce something, it has to implement it using some kind of active queue management. Preferably signalling to the client using ECN/L4S. ",
          "createdAt": "2025-04-09T06:32:15Z",
          "updatedAt": "2025-04-09T06:32:15Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@ihlar \n\n> Not sure if acknowledging the receipt of a specific TRONE packet adds much value.\nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place.\nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not.\nWhat you say is correct but what if the TRONE advisory packet is not received or that there is some time between the receipt of the TRONE signal and the client-app actually stepping down the bit-rate ladder?\n\nAnd as @rjt-ietf noted (below), the ACK offers network to not enforce any throughput limitation when the end-point is in the process of following the advice.\n\n> ...the throughput advice will be average bitrate within a time window, so I think it's necessary to let the CSPs know that the endpoint is following the advice \n\nBTW, for this [requirement](url) in the use case document, we have downshifted it to a \"MAY\" for FWIW",
          "createdAt": "2025-04-15T13:47:21Z",
          "updatedAt": "2025-04-15T13:47:21Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The TRONE model is for the network to provide advice. The design assume that the TRONE packet does not change the state of the network. For example, a network may be already programmed to apply a rate limiter to packets with certain characteristics, or to all packets. The TRONE packets will inform endpoints about those characteristics, so they can make useful decisions such as picking a video codec that remains within those envelopes. For that usage, we do not need acknowledgement: it is the responsibility of the endpoints to repeat packets if they cannot get information.",
          "createdAt": "2025-04-16T15:01:07Z",
          "updatedAt": "2025-04-16T15:01:07Z"
        },
        {
          "author": "rjt-ietf",
          "authorAssociation": "NONE",
          "body": "I'm ok with networks assuming an endpoint will follow the advice if TRONE packets are sent.\nBut I think the TRONE communication **may** change the state of a network.\nA network may have a generic limiter that looks at data at a 3-second window. But with TRONE, it should switch to a SCONE limiter that looks at the data window specified by SCONE, for example, 20 seconds.",
          "createdAt": "2025-04-16T15:08:09Z",
          "updatedAt": "2025-04-16T15:08:09Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "This doesn't seem necessary to me, unless the expectation is that packet loss is very high and the TRONE packets are relatively infrequent.",
          "createdAt": "2025-04-16T15:22:40Z",
          "updatedAt": "2025-04-16T15:22:40Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDON1dwo86vExP6",
      "title": "Detail interaction with congestion control",
      "url": "https://github.com/ietf-wg-scone/trone/issues/8",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "This came on repeatedly during the Bangkok IETF session. Congestion control and Trone are complementary, but we need to explain how that complementing works.",
      "createdAt": "2025-03-21T04:53:23Z",
      "updatedAt": "2025-04-16T17:15:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "Totally agreed @huitema . We tried to describe the distinction between SCONE and ECN in an [earlier draft](https://datatracker.ietf.org/doc/draft-tomar-scone-ecn/) but I am glad you are owning up to describe the complementarity of Trone and congestion control wholistically.",
          "createdAt": "2025-03-26T15:48:42Z",
          "updatedAt": "2025-03-26T15:48:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "During the 4/16/25 interim, we agreed to only merge part of PR #16, leaving aside a bunch of text:\n\n1. Speculative text about using congestion control signals to trigger TRONE packets when congestion eases: Consider then a condition in which congestion eases, either because the\ncompeting connections end or because the wireless transmission capacity\nimproves. The endpoints will notice that the rate of ECN marking rate has\nbecome low enough, and that the path is not congested anymore. However,\nthey don't know by how much they can increase their sending rate. Most\ncongestion control algorithms will proceed cautiously, allowing the\napplication to increase its sending rate step by step and verifying at each\nstep that they are not causing congestion. In these cases, a TRONE\nsignal can inform them about the changed capacity of the path and allow\nthem to increase capacity faster.\n\n2. Speculative text about using the TRONE signal to inform congestion control at the beginning of a connection: The TRONE signal can be particularly useful at the very beginning of a\nconnection. Congestion control algorithms typically start with a\nslow start process in which the application is allowed to double\nits sending rate after each RTT, until congestion is notified. This\nresults in a burst of excess transmission during the last RTT,\ncreating queues and possibly causing packet losses. Queues and\nlosses will affect not just the new connection that is testing the\ncapacity of the path, but also all established connections that\nshare the bottleneck. If the endpoints are using TRONE and learned the\nmaximum capacity of the path, they can exit the slow start process\nas soon as the maximum capacity has been tested, and avoid creating\nqueues or causing packet losses.\n\n3. Speculative text linking TRONE and \"careful resume\": The TRONE signal can also be useful if the applications remembers the\ncongestion control parameters of previous connections, and uses a\n\"careful resume\" process to quickly ramp up capacity as specified\nin  ({{?I-D.ietf-tsvwg-careful-resume}}). The endpoints could use\nTRONE to verify that the path characteristics have not changed\nsince the last connection before applying the careful resume\nprocess.\n\n4. General advice that if congestion uses the TRONE signal, it should be aware that if could be spoofed: In all cases, the endpoints should consider that the TRONE signal could\nhave been spoofed (see {{security}}). The congestion controller can use\nthe maximum capacity indicated by TRONE as a guide, but it\ncan also cautiously probe for available\ncapacity beyond the limit until receiving congestion signals.\n\nWe may want to use some of this text to specify whether and how congestion control use the TRONE signal. This is not obvious, because the general advice is that the two are independent, but it would be naive to believe that nobody would try plugging the capacity signaled by TRONE in their congestion controller. It might be better to explain the pitfalls of doing that, and perhaps signal the rare points where it makes sense.\n\nWe may also want to look at how \"easing of congestion\" could be used as a trigger for sending SCONE packets. This is somewhat experimental, because current congestion algorithms only detect easing of congestion if the application can push more data. An application working under the TRONE specified rate limit would not be able to do that. Updated congestion control algorithms might be able to detect easing of congestion by monitoring the rate of ECN marks, or the evolution of the RTT, but this is still a research area.",
          "createdAt": "2025-04-16T17:15:24Z",
          "updatedAt": "2025-04-16T17:15:24Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDON1dwo86vE006",
      "title": "Consider a way to do greasing",
      "url": "https://github.com/ietf-wg-scone/trone/issues/9",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is a bit of ambiguity in the specification of \"who uses TRONE\". The original Scone WG appears to have focused on adaptive bit rate video. If we strictly kept that focus, we have a privacy issue. Third parties could observe the presence of Trone headers, and infer that the end to end QUIC connection is engaged in video streaming.\n\nTo reduce the privacy issue, we could adopt a combined strategy, and ask more applications to support Trone, thus weakening the correlation between Trone and video.\n\nWe could also envisage greasing, with applications sending datagrams composed of a Trone packet, followed by a short header and random content. If the peer is not Trone capable, such greasing packets will be discarded because they do done decrypt correctly. But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.",
      "createdAt": "2025-03-21T05:04:11Z",
      "updatedAt": "2025-03-26T17:43:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "> But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.\n\nI am assuming you are referring to the network element as the \"third party\" here. If you prevent the network element from distinguishing the \"real\" Trone packets from the Greased packets, then how will the network element decide which packet to add the rate advisory to?",
          "createdAt": "2025-03-26T08:32:29Z",
          "updatedAt": "2025-03-26T08:32:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@atiwariphd the network element cannot distinguish between grease and real TRONE packet. I documented that as an attack in a separate PR #13 ",
          "createdAt": "2025-03-26T17:43:14Z",
          "updatedAt": "2025-03-26T17:43:14Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDON1dwo86vE3Wm",
      "title": "Could network elements mangle innocent packets?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/10",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is already discussed in the [TRAIN issue 32](https://github.com/martinthomson/train-protocol/issues/32). A Trone intermediary can mistake packets of some other applications for Trone packets. If it reqrite 6 bits, that will cause the packet to be eithre dropped or misinterpreted.\n\nAs explained by @ihlar during the IETF meeting in Bangkok, we need to distinguish:\n\n1. random collision: the end to end application issues some random first bytes that happen to mimic Trone. It will happen at low frequency.\n2. systematic collision: the end to end collision had negotiated some header that happens to Mimic Trone. All packets with that header will be mangled.\n\nThe proposed solution is for intermediaries to keep flow state and stop marking if too many packets of a flow match Trone. We need to develop that.\n",
      "createdAt": "2025-03-21T05:11:54Z",
      "updatedAt": "2025-04-08T09:29:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree we should document this and give some guidance on when to stop marking.\n\nThe use of two versions could help here as well. If the protocol mandates that endpoints send packets of both versions, only  observing packets of a single version could be an indication that these packets are mimicked and not real TRONE.\n\nSo, something like - stop marking if:\n\n1. After observing N packets, the ratio of TRONE to non-TRONE packets is close to 1.\n2. After observing M TRONE packets, the ratio of TRONE-1 to TRONE-2 (or vice versa) is close to 1.  ",
          "createdAt": "2025-04-08T09:29:05Z",
          "updatedAt": "2025-04-08T09:29:05Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDON1dwo86vE_RE",
      "title": "Spoofing attacks against intermediaries",
      "url": "https://github.com/ietf-wg-scone/trone/issues/11",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In issue #9 we discuss the possibility of greasing TRONE. Greasing is cool for privacy, but the same mechanisms can be used as an attack. Suppose something like:\n\n~~~\n+------------+    +----------+       /---------------\\       +-------------+\n|end point A | -- | Trone NE | ---- ( Big bad Internet) ---- | end point B |\n+------------+    +----------+       \\---------------/       +-------------+\n                                          |\n                                          |\n                                    +-------------+\n                                    | wily hacker |\n                                    +-------------+\n~~~\n\nThe hacker creates Trone packets with:\n\n* IP / UDP header: set IP source to address of B, IP destination to address of A\n* SCONE packet: pick a destination CID and a destination CID\n* 1RTT header: same destination  CID as SCONE packet\n* 1 RTT content: enough random bytes to look plausible\n\nThe attacker needs to know at least a valid address for end point A, so the packets will be routed through the target NE, but after that there are many possibilities:\n\n* an off path attacker can pick random values for the source address of \"B\" and for the CID.\n* an on path attacker can pick pairs of addresses that match existing hosts \"A\" and \"B\" and either random CID or CID copied from observed traffic.\n\nThe possible effects would be:\n\n* trick the NE into \"remembering\" lots of TRONE context, thus consuming lots of memory\n* force the NE to process a vast quantity of TRONE packets, thus consuming lots of resource\n* trick the NE into detecting a \"systematic collision\" (see issue #10) and thus disable TRONE for that flow.\n ",
      "createdAt": "2025-03-21T05:38:19Z",
      "updatedAt": "2025-03-21T05:38:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDON1dwo86vv_gA",
      "title": "Is the \"version=range\" paradigm appropriate?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/14",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As presented at IETF 122, we define a \"version\" field that is used to choose between possible ranges.\nThis seems strange both from a cleanliness standpoint and from a greasing standpoint.\n\nWhen there are only two versions, the version field amounts to an extra bit in the range specifier - by including it directly in the range specifier (making it 0-127 rather than 0-63), we gain an unified range with a larger span (or a finer resolution, if we choose to reduce the multiplier in the exponential spacing).\n\nIf we desire to ensure that we can introduce more versions of the TRONE signal later, two versions with near-identical semantics are not enough.\n",
      "createdAt": "2025-03-26T07:03:56Z",
      "updatedAt": "2025-04-17T18:12:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "Yeah, I think there could be discussions regarding how endpoints / network elements act and how the bit rates are encoded.\n\nRegarding the former, at the moment, the draft defines two versions of TRONE covering different ranges. Senders send both. Network elements modify both independently. Receivers calculate the minimum of the two. There is indeed some complexity, when the goal is to signal just one value (i.e., the bit rate).\n\nAn alternative design will be to allow network elements rewrite TRONE2 packets (carrying larger bit rates) to TRONE1 packets (carrying smaller rates).\n\nIf we adopt such a design, senders just need to send one TRONE packet (i.e., TRONE2). Receivers will no longer be required to calculate the minimum.\n\nNetwork elements would still be required to observe two versions and rewrite them as necessary (possibly to a different version), but considering that we only have 6 spare bits in the QUIC invariants before variable length fields, I think we have to either squeeze all bit rates into 6 bits or live with having multiple versions indicating different bit rates.",
          "createdAt": "2025-04-16T10:16:13Z",
          "updatedAt": "2025-04-16T10:16:13Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the idea of rewriting is an good one. The one thing we have to be careful about, in my opinion, is that not _every_ future version of TRONE can be rewritten.\n\nSo for example, suppose the initial protocol has 0xTRONE1 and 0xTRONE2 and a network element can rewrite 0xTRONE1 <->0xTRONE2. Suppose subsequently we figure out we need a 0xTRONE3 for some purpose. I think any network element that only understands 0xTRONE1/2 should not rewrite 0xTRONE3 packets, and simply ignore them.",
          "createdAt": "2025-04-16T15:57:09Z",
          "updatedAt": "2025-04-16T15:57:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The idea of version rewriting is in line with the general design of using 2 version numbers to get an extra bit for the range of values.",
          "createdAt": "2025-04-17T18:12:28Z",
          "updatedAt": "2025-04-17T18:12:28Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDON1dwo86v0U91",
      "title": "TRONE with other protocols - ICE in particular?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/15",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As specified, the TRONE protocol only works with QUIC. And given that it can prepend data to a datagram, it is not a drop-in with anything but QUIC.\n\nThis form of signalling is interesting to other use cases. Would it be reasonable/possible/hard/impossible to carry a TRONE packet as an ICE extension?\n",
      "createdAt": "2025-03-26T14:02:31Z",
      "updatedAt": "2025-03-27T08:22:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "@alvestrand \n\n> This form of signalling is interesting to other use cases.\n\nCan you please articulate the use case?",
          "createdAt": "2025-03-26T15:43:02Z",
          "updatedAt": "2025-03-26T15:43:02Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "The classical WebRTC VC use case is one where we set up a video call (usually between the user and a datacenter), and we want to adapt the codec configuration to the available bandwidth.\nToday we do that using congestion control only.\n",
          "createdAt": "2025-03-26T16:30:28Z",
          "updatedAt": "2025-03-26T16:30:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "See issue #9 about greasing. The intermediaries do not know that a TRONE packet is in fact a QUIC packet. They merely see a TRONE packet followed by a QUIC like byte, a repeat of the connection identifier bytes, and a bunch of random looking bytes. If you want to add more complexity to ICE, your ICE implementation could certainly send UDP packets that match that format. QUIC enpoints use the \"random bytes\" for verifying that the packet is legit; you could use this random bytes to carry some kind of verifier in your ICE/TRONE packets.",
          "createdAt": "2025-03-26T17:54:06Z",
          "updatedAt": "2025-03-26T17:54:06Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "ICE packets are distinguished from other packets by looking at the first byte. TRONE packets, as specified, would put a different value in the first byte. See https://datatracker.ietf.org/doc/html/rfc7983#section-7\nIt would be trivial to specify a TRONE packet as an ICE attribute, and ICE even has support for protecting only some of the attributes in an ICE packet (it uses a hash over the message + a shared secret), but it's a non-trivial job for the router to find the TRONE packet inside the ICE message.\n",
          "createdAt": "2025-03-26T21:00:02Z",
          "updatedAt": "2025-03-26T21:00:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@alvestrand that's why I suggested sending two messages, the ICE message proper, and a separate \"TRONE\" message on the same 4-tuple.",
          "createdAt": "2025-03-26T23:29:28Z",
          "updatedAt": "2025-03-26T23:29:28Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification - I imagined that you were suggesting sending a single UDP packet with a TRONE message followed by the ICE message, but sending two UDP makes much more sense. Specifying a payload that would pass the TRONE inspector and be verifiable with the ICE credentials shouldn't take much more than a page.",
          "createdAt": "2025-03-27T08:22:08Z",
          "updatedAt": "2025-03-27T08:22:08Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDON1dwo86wCKw4",
      "title": "Clarify rounding behavior for bitrate-to-signal value conversion",
      "url": "https://github.com/ietf-wg-scone/trone/issues/17",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft needs clear guidance on rounding when converting between bitrates and signal values.\n\n- Should implementers round up or down when converting from bitrates to signal values?\n- What are the practical implications of each choice? (rounding down ensures staying under capacity limits; rounding up maximizes bandwidth utilization when rate adaptation algorithms rarely use full capacity)\n- Recommend specific approach with rationale, noting the logarithmic scale means adjacent steps differ by at most ~11%\n- Include example calculations demonstrating the recommended approach\n\n\n\n",
      "createdAt": "2025-03-27T15:07:00Z",
      "updatedAt": "2025-03-27T15:07:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDON1dwo86wCPkw",
      "title": "Confusion between \"No limit\" and \"TRONE not supported on path\"",
      "url": "https://github.com/ietf-wg-scone/trone/issues/18",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently conflates two distinct conditions in signal value 63 to mean either:\n- The network can support unlimited bandwidth (higher than max range)\n- TRONE is not supported by network elements on path\n\nThis creates ambiguity for applications interpreting signal 63 - should they assume unlimited bandwidth or cautiously rely on congestion control? We could disambiguate this by using different signal values:\n\n- 62: No limit (bandwidth exceeds maximum range)\n- 63: TRONE not supported on path\n\nOr clearly specify how applications should interpret signal 63, acknowledging its dual meaning requires caution.",
      "createdAt": "2025-03-27T15:11:45Z",
      "updatedAt": "2025-04-08T11:28:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.",
          "createdAt": "2025-03-27T15:12:48Z",
          "updatedAt": "2025-03-27T15:12:48Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.\n\nI agree, there is no need to distinguish between these. I take 63 to mean there is no limit in this range, whether that is due to an active policy or absence thereof makes no difference. ",
          "createdAt": "2025-04-08T11:28:45Z",
          "updatedAt": "2025-04-08T11:28:45Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDON1dwo86wDn_2",
      "title": "Privacy considerations when sending different TRONE protocol versions",
      "url": "https://github.com/ietf-wg-scone/trone/issues/19",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently recommends alternating between TRONE1 and TRONE2 versions without addressing the privacy implications. We should think about this more and at least add some considerations to the text.\n\nTo ensure network elements know TRONE is supported while minimizing information disclosure, one idea would be:\n\n- Send at least one packet of each version initially even if the application only operates in one range.\n- Subsequently prioritize sending the version most relevant to current bandwidth usage\n",
      "createdAt": "2025-03-27T16:50:15Z",
      "updatedAt": "2025-04-16T15:44:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be fine to keep alternating the versions at all times, just use two datagrams to send TRONE probes. I suppose that would be the best solution from a privacy perspective (unless I'm missing something). The additional cost of alternating should be low, and there are other potential benefits as discussed in #10 .",
          "createdAt": "2025-04-08T11:58:15Z",
          "updatedAt": "2025-04-08T11:58:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "To be precise, will it be:\r\na) for the first burst send TRONE1 and for the next burst send TRONE 2, or\r\nb) for each burst send both TRONE 1 and TRONE2?\r\n\r\nI assume it'd be _b\", but trying to confirm.\r\n\r\nRegarding the overhead, I agree that it'd be negligible. The lowest bitrate being proposed is 100Kbps which is ~10pps assuming 1200 byte packets. That'd mean that, if endpoints are to receive updated TRONE signals one per every 10 seconds (see #20), the difference is sending one or two QUIC packets with TRONE headers for every 100 UDP datagrams.",
          "createdAt": "2025-04-09T04:50:22Z",
          "updatedAt": "2025-04-09T04:50:22Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes agree that it should be _b_.",
          "createdAt": "2025-04-09T05:32:05Z",
          "updatedAt": "2025-04-09T05:32:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "As stated in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526, we could allow network elements rewrite TRONE2 packets (carrying higher bit rates) to TRONE1.",
          "createdAt": "2025-04-16T15:44:13Z",
          "updatedAt": "2025-04-16T15:44:13Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDON1dwo86xr5d8",
      "title": "Time window for suggested bitrate",
      "url": "https://github.com/ietf-wg-scone/trone/issues/20",
      "state": "OPEN",
      "author": "rjt-ietf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue is mostly in regard to  slide 11 of https://datatracker.ietf.org/meeting/122/materials/slides-122-scone-trone-questions-01, which was discussed at IETF 122.\n\nThe current draft doesn't mention this perspective so I want to open up the discussion.\n\nIn general, I think that a fixed window length specified by SCONE is preferable as it simplifies works for network elements. But meanwhile, we need to find a window that works for all users of SCONE.\n\nDifferent video applications choose to buffer different lengths of videos during playbacks. For example, App A may buffer 10s while App B buffers 20s. A 10-second window will work for app A but not work for app B. A 20-second window will work for both.\n\nA flow that complies with a short window will also comply with a longer one.\n\nThis means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection. ",
      "createdAt": "2025-04-08T22:27:05Z",
      "updatedAt": "2025-04-16T15:35:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "> This means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection.\r\n\r\nAgreed.\r\n\r\nSince network devices cannot identify the actual application protocol being used (e.g., HLS, WebRTC, MOQ), the responsiveness to TRONE signals they can expect corresponds to that of the least responsive application protocol.\r\n\r\nAssuming that HLS would use chunks as large as 10 seconds, and assuming that each chunk would be sent at full speed, window of 20 seconds is a good ball-park figure, IMO.",
          "createdAt": "2025-04-09T04:42:48Z",
          "updatedAt": "2025-04-09T04:42:48Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "For realtime video, the interesting timeframe  is the next 20 ms - we don't buffer on the HLS timescale.\nPermitted burst size is of interest, but mainly because we don't want the L4S problem of sending a keyframe and having the last packet of the frame be marked as congestion-experienced because the whole keyframe was sent at line rate.\n\n",
          "createdAt": "2025-04-09T06:20:51Z",
          "updatedAt": "2025-04-09T06:20:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "I think there are two separate questions:\n* time window of the signals being emitted by network elements (which would be the window that they would use for detecting abuse)\n* how frequent endpoints request / receive updates\n\nFor the first question, unless endpoints agree to expose what type of application they are, the time window has to be that of the application that takes the longest time to adopt to the SCONE signal. My guess is that that application would be HLS, and that therefore the time window should be in the order of 10 seconds.\n\nFor the second question, I think there is no need to forbid endpoints requesting SCONE signals more frequently, e.g., by sending TRONE packets.",
          "createdAt": "2025-04-09T23:47:54Z",
          "updatedAt": "2025-04-09T23:48:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "SCONE is intended for timeframes of multiple RTTs at a minimum, so I would expect 30 seconds or a minute to be a reasonable timeframe.",
          "createdAt": "2025-04-16T15:26:16Z",
          "updatedAt": "2025-04-16T15:26:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion at Interim 3: we need to pick a value now for the doc to be adopted. 20 seconds seems to be a good starting point. Keeping this issue open to make sure we don't lose the finer points here.",
          "createdAt": "2025-04-16T15:35:22Z",
          "updatedAt": "2025-04-16T15:35:22Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDON1dwo86yoU-z",
      "title": "Network inserted TRONE packets",
      "url": "https://github.com/ietf-wg-scone/trone/issues/21",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The topic of whether network elements should be able to generate TRONE packets and insert them into expanded datagrams was discussed at IETF 122. Also discussed in #6.\nIdeally this should not be needed, given that there is proper guidance on when to send TRONE packets and making sure that updating the rate limit field of the TRONE packets is sufficiently cheap. The risk of expanding datagrams in the network is that it can result in path MTU issues with lost packets as a consequence. \n\nThere are a few paths we can take on this topic:\n\n1. Say nothing about it.\n2. Mention the possibility and give guidance on potential MTU issues that can arise. \n3. Explicitly forbid network inserted TRONE packets and design protocol mechanisms to enforce it.",
      "createdAt": "2025-04-15T15:59:14Z",
      "updatedAt": "2025-04-16T15:53:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I believe we should have normative text advising against doing this and why, but I doubt it's worth building a mechanism to enforce that unless it's quite simple.",
          "createdAt": "2025-04-16T15:16:54Z",
          "updatedAt": "2025-04-16T15:16:54Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suspect it would be easy for the encrypted envelope to carry such protection of the TRONE info ... and an on-path observer would never know if the endpoint did this, or not. (However, realising the mechanism could be done later -  there may be pain in making an efficient implementation).",
          "createdAt": "2025-04-16T15:53:06Z",
          "updatedAt": "2025-04-16T15:53:06Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDON1dwo86y0OE3",
      "title": "How frequently should endpoints send TRONE packets?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/24",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This has been discussed extensively both privately, at IETF 122, and in the latest interim. We should give guidance to endpoints on how often and under what circumstances they should send TRONE packets to give an opportunity to generate new advice.",
      "createdAt": "2025-04-16T15:38:18Z",
      "updatedAt": "2025-04-16T15:38:18Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDON1dwo86MqU5p",
      "title": "Transparent Rate Optimization for Network Endpoints (TRONE)",
      "url": "https://github.com/ietf-wg-scone/trone/pull/3",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An attempt at TRONE.\r\nWe can bikeshed the name in #2.\r\n\r\nThe PR uses TRAIN as a baseline so that it's easier to review the changes from TRAIN.\r\nNote that this version changes the rate signal field to a field with explicit values, located after the CIDs.\r\nIf we're very unsure about the design tradeoffs we could consider doing both the TRAIN and TRONE ways as discussed in #1.\r\n\r\nThere's also a discussion on how network elements are capable of crafting TRONE packets. ",
      "createdAt": "2025-02-26T15:03:17Z",
      "updatedAt": "2025-03-05T13:18:41Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "b568f3314171b26d5bc38891e21c4f5f714a4c55",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "advice-format",
      "headRefOid": "946f94dac013f33e4c29520a5bdcb13f877e212c",
      "closedAt": "2025-03-03T17:42:04Z",
      "mergedAt": "2025-03-03T17:42:04Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "681b12c446391332da002b4b3cf33a0d51ab3f64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86d7v0C",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T04:25:32Z",
          "updatedAt": "2025-02-28T04:25:33Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Even if I thought that this was necessary, this is probably not the right logic to use here.  You are going to independently reduce the rate and window size.  If you don't reduce one, but you reduce the other, that is sometimes going to reduce the actual send rate below your target.  That's another reason I don't like this design.",
              "createdAt": "2025-02-28T04:25:33Z",
              "updatedAt": "2025-02-28T04:25:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86d9h0k",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T09:02:21Z",
          "updatedAt": "2025-02-28T09:02:21Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Yeah, composability makes this solution a bit messy. I've been a bit back and forth on this.  My original thinking was to only check the rate and update the window unconditionally:\r\n`if packet_rate == 0 or target_rate < packet_rate:`\r\n`    write_uint32(packet[offset : offset + 4], target_rate)`\r\n`    write_uint32(packet[offset + 4 : offset + 8], target_aw)`\r\n\r\n    \r\nThat could lead to the sending of bursts that are not tolerated by the element further upstream. \r\nIt might be the least messy thing to do with this design though. (And I still think the case with chained elements who wish to signal rates is a rather exceptional one).",
              "createdAt": "2025-02-28T09:02:21Z",
              "updatedAt": "2025-02-28T13:10:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eFfDm",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "billwuqin",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T04:40:27Z",
          "updatedAt": "2025-03-01T04:40:27Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Thank for getting together baking this draft among authors, thanks for Martin to enage this discussion, I am wondering\r\nIs there possible to leave this as one open issue or split it from PR#3 and move to new PR. \r\nI hope we can have one posted version before submission deadline, let us know what we can do to help move the way forward.",
              "createdAt": "2025-03-01T04:40:27Z",
              "updatedAt": "2025-03-01T04:40:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eF4Fl",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T07:53:46Z",
          "updatedAt": "2025-03-01T07:53:47Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "The latest commit contains an update in response to Martin's comment, fixing the logic so that average window is not updated separately from updating the rate limit. Which is probably the right thing to do, given this design. \r\n\r\nThere is a larger issue around the structure and placement of the rate signal, something the WG needs to resolve. I would hope that the merged document can contain the latest commit and then we have the broader discussion as an open issue, see #1 for instance. ",
              "createdAt": "2025-03-01T07:53:46Z",
              "updatedAt": "2025-03-01T07:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eOFsQ",
          "commit": {
            "abbreviatedOid": "2b0ef2f"
          },
          "author": "mjoras",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T15:35:01Z",
          "updatedAt": "2025-03-03T15:35:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86enOJN",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T13:18:41Z",
          "updatedAt": "2025-03-05T13:18:41Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "To be clear, I did not approve this document.",
              "createdAt": "2025-03-05T13:18:41Z",
              "updatedAt": "2025-03-05T13:18:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDON1dwo86P8JWx",
      "title": "Initial attempt at adding version-dependent logarithmic rates",
      "url": "https://github.com/ietf-wg-scone/trone/pull/12",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First pass, expecting there will be further changes needed. There seemed to be general consensus around this approach, which we believe we need to take before an adoption call.",
      "createdAt": "2025-03-24T22:03:34Z",
      "updatedAt": "2025-04-09T05:30:13Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "5764ba5c4c979069d5c841889845133a61fae8c7",
      "closedAt": "2025-04-09T05:30:13Z",
      "mergedAt": "2025-04-09T05:30:13Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "a4f79332ca9e716f7c255932d800191385ef33f4"
      },
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Took all the suggestions and punted some things to issues. Are we okay with this now?",
          "createdAt": "2025-03-27T16:51:01Z",
          "updatedAt": "2025-03-27T16:51:01Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Note the question in #14 - not an objection to merging this PR, but a heads-up that we may want to revisit this.\r\n",
          "createdAt": "2025-03-28T04:28:21Z",
          "updatedAt": "2025-03-28T04:28:21Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @kazuho @martinthomson any further thoughts or are we okay to merge this and iterate?",
          "createdAt": "2025-04-03T15:35:36Z",
          "updatedAt": "2025-04-03T15:35:36Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Who actually has merge approval perms? @britram could I get it provisionally just to h it the button? \ud83d\ude42 ",
          "createdAt": "2025-04-07T20:12:52Z",
          "updatedAt": "2025-04-07T20:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86ho3fT",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thank you for the PR. Looks good overall.",
          "createdAt": "2025-03-24T22:45:22Z",
          "updatedAt": "2025-03-24T23:06:41Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n| 10 | 316 Kbps | 31.6 Mbps |\r\n```",
              "createdAt": "2025-03-24T22:45:22Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 75,
              "body": "I think we do not have these in the proposed encoding? (and IMO we probably do not need them)",
              "createdAt": "2025-03-24T22:46:27Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 89,
              "body": "Do we need this change? Not that it is incorrect, but seems a bit verbose, as the Rate Signal field is defined to be six bits.",
              "createdAt": "2025-03-24T22:48:01Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n```\r\nAs we read `version` from the packet later (see `packet[1..5]`), maybe it makes sense to delay the invocation of `convert_rate_to_signal` after that. Something like below.",
              "createdAt": "2025-03-24T22:51:30Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\npacket_version = packet[1..5]\r\nif is_long and (packet_version == TRONE1_VERSION or packet_version == TRONE2_VERSION):\r\n  target_rate_value = convert_rate_to_signal(target_rate, packet_version)\r\n```",
              "createdAt": "2025-03-24T22:54:25Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nshould signal the minimum value (0) for rates below the range and preserve the\r\noriginal value for rates above the range.\r\n```\r\nWhen there are multiple network elements, the Rate Signal field might convey a value other than 63.",
              "createdAt": "2025-03-24T23:02:53Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-03-24T23:03:14Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Do we want to state that values 0 to 62 represents the ceiling values?",
              "createdAt": "2025-03-24T23:05:53Z",
              "updatedAt": "2025-03-24T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpc5V",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:58:13Z",
          "updatedAt": "2025-03-25T00:58:13Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "You're right I got my wires crossed from my notes.",
              "createdAt": "2025-03-25T00:58:13Z",
              "updatedAt": "2025-03-25T00:58:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpT6C",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:29:04Z",
          "updatedAt": "2025-03-25T01:21:17Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I would not do it this way.  Instead, I would set the target rate value for each version as follows:\r\n\r\n```python\r\nversions = [TRONE_VERSION1, TRONE_VERSION2]\r\ntarget = [63, 63]\r\nfor i in 1..len(versions):\r\n    target[i] = convert_rate(target_rate, versions[i])\r\n\r\n# then when a packet arrives\r\nif packet[0] & 0x80 != 0x80:\r\n    skip\r\ni = find(versions, packet[1..5])\r\nif i is not None and packet[0] & 0x3f > target[i]:\r\n    packet[0] = packet[0] & 0xc0 | target[i]",
              "createdAt": "2025-03-25T00:29:04Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n* Support for both very low bitrates (down to 100 Kbps) and very high bitrates\r\n  (up to 12.5 Gbps)\r\n* Graceful handling of network elements that might only recognize one version\r\n  or some subset of future versions.\r\n```\r\n\r\nThis is unordered.",
              "createdAt": "2025-03-25T00:29:47Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n* When sending TRONE packets, endpoints SHOULD alternate between versions\r\n```\r\nUnordered",
              "createdAt": "2025-03-25T00:30:41Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n* Network elements SHOULD apply appropriate rate signals to all packets that\r\n   include a TRONE version they support.\r\n```",
              "createdAt": "2025-03-25T00:31:45Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 170,
              "body": "We need to talk about rounding.\r\n\r\nIn practice, if the bitrate formula is $r=b * 10^{\\frac{n}{20}}$, the inverse is $n=\\left\\lceil 20 * \\log_{10}(\\frac{r}{b})\\right\\rceil$  or $n=\\left\\lfloor 20 * \\log_{10}(\\frac{r}{b})\\right\\rfloor$ but we should offer guidance on which to choose.",
              "createdAt": "2025-03-25T00:36:56Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqTg8",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:24:09Z",
          "updatedAt": "2025-03-25T03:25:23Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "We should talk about the privacy trade-offs with respect to sending each.  I think that it is reasonable to send both unconditionally, but it might be better to only send these when the estimated bandwidth availability enters the range covered by each.\r\n\r\nAn application that is currently operating in the TRONE1 range could decide that it only needs to send TRONE1 packets.  That limits the number of markings that are needed and does not reveal anything extra.  The challenge being in ensuring that the network element is aware that TRONE markings are available.  For that, I would recommend always sending one packet at least once, even when the active usage is well outside of the protocol-defined ranges.\r\n\r\n\r\nHowever, an application that MIGHT operate in just the TRONE2 range reveals information that the network does not otherwise obtain if it sends the TRONE2 signal.",
              "createdAt": "2025-03-25T03:24:09Z",
              "updatedAt": "2025-03-25T03:25:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqVP1",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:28:07Z",
          "updatedAt": "2025-03-25T03:28:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Or more clever:\r\n\r\n```python\r\ni = find(versions, packet[1..5]) if packet[0] & 0x80 == 0x80 else None\r\nif i is not None and ...\r\n```",
              "createdAt": "2025-03-25T03:28:07Z",
              "updatedAt": "2025-03-25T03:28:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrFXa",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:31:29Z",
          "updatedAt": "2025-03-25T05:31:30Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Agreed. Should I leave the text here while we work through this nuance or do you think there's something better to put in its place for now?",
              "createdAt": "2025-03-25T05:31:30Z",
              "updatedAt": "2025-03-25T05:31:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrGof",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:34:29Z",
          "updatedAt": "2025-03-25T05:34:29Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "An issue for followup is fine.",
              "createdAt": "2025-03-25T05:34:29Z",
              "updatedAt": "2025-03-25T05:34:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86htdY0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T09:38:15Z",
          "updatedAt": "2025-03-25T09:38:15Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "In the current state, I do not think we need to talk about rounding.\r\n\r\nWe state that the code points represent the ceiling. That means code points 0, 20, 40, 60 represent `<= 100Kbps`, `<= 1Mbps`, `<=10Mbps`, `<=100Mbps`, as they are divisible. OTOH, other values are indivisible. For example, 10<sup>1/20</sup> is 112201.84..., meaning that code point 1 represents bit rate up to 112,201bps.\r\n\r\nMaybe all we need to provide is these examples.\r\n\r\nOf course, we could go the other way and state that the 3 (or 4) most significant digits of the log function represents the bit rate...",
              "createdAt": "2025-03-25T09:38:15Z",
              "updatedAt": "2025-03-25T09:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2MB3",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I think this is fine, except for the confusion between \"no TRONE on this path\" and \"no limit\".",
          "createdAt": "2025-03-25T22:21:17Z",
          "updatedAt": "2025-03-25T22:27:26Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think saying \"63 = No limit\" conflates two separate notions:\r\n\r\n* the TRONE protocol is not supported by network elements on the path (definition of 0x3F above)\r\n* the limit is higher that either 126Mbps or 12.6 Gbps.\r\n\r\nWe could remove that issue by defining the last lines of the table as:\r\n\r\n| 60 | 100 Mbps | 10 Gbps |\r\n| 62 | No limit | No limit |\r\n| 63 |  TRONE not supported on path |  TRONE not supported on path |\r\n\r\n\r\n",
              "createdAt": "2025-03-25T22:21:17Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 122,
              "body": "Would be \"up to 10Gbps\" if we use only 62 actual ranges.",
              "createdAt": "2025-03-25T22:22:38Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 170,
              "body": "I think it is fine to base the rounding on the table. I think we should say \"pick the highest rate signal that correspond to a value lower or equal to the rate\", but it might be a local decision.",
              "createdAt": "2025-03-25T22:25:20Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2_U7",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T00:54:09Z",
          "updatedAt": "2025-03-26T00:54:10Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "We should offer advice to network operators on the consequences of different choices.  Rounding down has the effect of guaranteeing that the used capacity is lower than the target.  However, given that applications that employ rate adaptation will rarely be able to completely use the given bandwidth, it might be better to pick a higher number.  Especially given that any excess is never more than about 11% higher than the previous step.",
              "createdAt": "2025-03-26T00:54:10Z",
              "updatedAt": "2025-03-26T00:54:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Khj",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:16:12Z",
          "updatedAt": "2025-03-26T04:16:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm not convinced that we need that feature.  What would  you do with that information?",
              "createdAt": "2025-03-26T04:16:12Z",
              "updatedAt": "2025-03-26T04:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4UB0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:47:48Z",
          "updatedAt": "2025-03-26T04:47:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think there is a difference between \"more than 10Gbps\" and \"don't know\". In one case, the app has the go ahead to use a vast amount of bandwidth. In the other, the app has to proceed cautiously and rely on congestion control for a bandwidth estimate.",
              "createdAt": "2025-03-26T04:47:48Z",
              "updatedAt": "2025-03-26T04:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Ymh",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:04:16Z",
          "updatedAt": "2025-03-26T05:04:16Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "`10M*10^{62/20}` = 12.589G; `10M*10^{61/20}` = 11.220G.  We only get 10G if we decide to use 61 ranges.",
              "createdAt": "2025-03-26T05:04:16Z",
              "updatedAt": "2025-03-26T05:04:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Zl7",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:07:16Z",
          "updatedAt": "2025-03-26T05:07:16Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I can't conceive of a scenario where an app would see an \"uncapped\" signal and decide that it can switch to sending at line rate.  You are taking the word of one path element and extrapolating to the entire path.\r\n\r\nLet's say that you get a 1Mbps signal.  You are currently at ~30kbps.  It might be reasonable to skip a few steps in your capacity probing to get closer to 1Mbps.  But that might be based on an assumption about the relative availability of bandwidth in modern networks and maybe past experience with the same network; I doubt you would make the same guess at 1Tbps (if that were a possible signal, that is).\r\n\r\nI conclude that while the congestion controller might be nudged a little, senders still need to have one and use that to probe the actual path availability.  The network still has queues and other users.  Expressions of policy limitations don't necessary entail guarantees, even at the node that is making that assertion.",
              "createdAt": "2025-03-26T05:07:16Z",
              "updatedAt": "2025-03-26T05:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4m8S",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:51:58Z",
          "updatedAt": "2025-03-26T05:51:58Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Sorry, I didn't do the math. But yes, that's the crux of the debate. We have 64 code points, from 0 to 63. If we reserve one to say \"don't know\", that means using only 62 code points, the last one marking the unbounded range.",
              "createdAt": "2025-03-26T05:51:58Z",
              "updatedAt": "2025-03-26T05:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4pOz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:58:46Z",
          "updatedAt": "2025-03-26T05:58:47Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I really need to get going on writing the congestion control part. There are a couple of ways to use a \"bandwidth cap\". It could solve one specific problem, stop the \"slow start\" exponential growth early. It could fit with the \"careful resume\" mechanism -- very that the new connection has the same cap as the previous one before reusing values learned before. It could inform of bandwidth drop, controlling the building of queues when the congestion controller discovers the new capacity. It could inform \"resume after congestion\" mechanisms, to grow sending rate quicker after transient congestion stops. At the application level, it can inform choice of codecs...",
              "createdAt": "2025-03-26T05:58:46Z",
              "updatedAt": "2025-03-26T05:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iP_c_",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:07:14Z",
          "updatedAt": "2025-03-27T15:07:14Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Filed #17 ",
              "createdAt": "2025-03-27T15:07:14Z",
              "updatedAt": "2025-03-27T15:07:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iQGWk",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:13:34Z",
          "updatedAt": "2025-03-27T15:13:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Filed #18 for followup though I'm largely in agreement with @martinthomson on this.",
              "createdAt": "2025-03-27T15:13:34Z",
              "updatedAt": "2025-03-27T15:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iSFuB",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T16:50:24Z",
          "updatedAt": "2025-03-27T16:50:24Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Filed #19 ",
              "createdAt": "2025-03-27T16:50:24Z",
              "updatedAt": "2025-03-27T16:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZV-N",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-03T22:21:54Z",
          "updatedAt": "2025-04-03T22:21:54Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "We can come back to that after merging this PR.",
              "createdAt": "2025-04-03T22:21:54Z",
              "updatedAt": "2025-04-03T22:21:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZWRw",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Let's merge this. We can iterate later.",
          "createdAt": "2025-04-03T22:22:55Z",
          "updatedAt": "2025-04-03T22:22:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86j3Gwz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to merge, one small editorial nit that we can fix now or later.",
          "createdAt": "2025-04-08T08:29:54Z",
          "updatedAt": "2025-04-08T08:31:08Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "This reads a bit like a single TRONE packet can have two versions, perhaps rewrite as:\r\n``````suggestion\r\nA network element applies the same rate policy to TRONE packets of both \r\nversions, accounting for the different scales of each version. When a\r\n",
              "createdAt": "2025-04-08T08:29:54Z",
              "updatedAt": "2025-04-08T19:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86kCEii",
          "commit": {
            "abbreviatedOid": "5764ba5"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "+1 to merging.",
          "createdAt": "2025-04-09T04:34:16Z",
          "updatedAt": "2025-04-09T04:34:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDON1dwo86QF6Tw",
      "title": "Description of DOS attack against intermediaries",
      "url": "https://github.com/ietf-wg-scone/trone/pull/13",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Adding a description of the attack listed in #11.\r\n\r\nClose #11",
      "createdAt": "2025-03-25T18:25:44Z",
      "updatedAt": "2025-04-17T10:04:02Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "sec-rec-inter",
      "headRefOid": "2ab4aaf3a97e170832d069c6898bc362d1141b43",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lC-nU",
          "commit": {
            "abbreviatedOid": "7433288"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is good, except for the terminology nits.\r\nI think we can expand on the guidance to network elements (e.g., requiring that you observe TRONE packets in both uplink and downlink directions of a 5-tuple makes the attacks somewhat more difficult to pull off), but that can be done later.",
          "createdAt": "2025-04-15T16:12:12Z",
          "updatedAt": "2025-04-15T16:17:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nis invalid or because decryption fail, but network elements cannot do these checks,\r\n```",
              "createdAt": "2025-04-15T16:12:13Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nand will have to process the packets. All the network elements between the injection\r\n```",
              "createdAt": "2025-04-15T16:12:51Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\na denial of service (DOS) attempt against network elements. The attack will\r\n```",
              "createdAt": "2025-04-15T16:13:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nforce the intermediaries to process the fake packets. If network elements\r\n```",
              "createdAt": "2025-04-15T16:13:56Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nthe rate of TRONE packets that a network element is willing to process;\r\n```",
              "createdAt": "2025-04-15T16:14:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\na processing error at network elements. For example, they might pick connection\r\nidentifiers of arbitrary length. Network elements can mitigate these attacks\r\n```",
              "createdAt": "2025-04-15T16:15:16Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lSRzw",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thank you for writing this!",
          "createdAt": "2025-04-16T15:52:45Z",
          "updatedAt": "2025-04-16T15:52:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lasB9",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:04:02Z",
          "updatedAt": "2025-04-17T10:04:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDON1dwo86QQjgP",
      "title": "First cut for congestion and TRONE interaction",
      "url": "https://github.com/ietf-wg-scone/trone/pull/16",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think that we need to explicitly describe the interaction between congestion control and TRONE, if only to dispel any notion that TRONE replaces congestion control, as stated in issue #8. This is a first cut for describing such interactions. ",
      "createdAt": "2025-03-26T18:51:48Z",
      "updatedAt": "2025-04-17T10:02:40Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "first-congestion",
      "headRefOid": "37699bd37d10f56e306d78e055f3a13c884d3e6f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lJDps",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T04:08:16Z",
          "updatedAt": "2025-04-16T04:08:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think text up to this paragraph if fine.\r\n\r\nBut for the remainder, I'm not sure if it'd be a good idea to imply TRONE as a signal that supplements congestion signals that indicate that more bandwidth might be available.\r\n\r\nI wonder if it would be better to explain the difference of the time scales congestion signals and TRONE signals act upon.\r\n\r\nThe time scale of congestion signals is in the unit of RTT, while I'd presume TRONE signals to indicate average b/w available across ~10 seconds; see https://github.com/ietf-wg-scone/trone/issues/20. For video playback using chunked files, the two signals would be handled differently; congestion control applies to the transport, while the TRONE signal would be used for choosing the chunks with the appropriate bitrate. Note each chunk can be sent much faster than the rate indicated by TRONE, as long as the average bitrate (including the idle period) remains below the TRONE value.",
              "createdAt": "2025-04-16T04:08:17Z",
              "updatedAt": "2025-04-16T04:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lTVJf",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T17:28:03Z",
          "updatedAt": "2025-04-16T17:28:03Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Agreed. The following paragraphs are cut in the next commit.",
              "createdAt": "2025-04-16T17:28:03Z",
              "updatedAt": "2025-04-16T17:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lXf23",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thank you for the updates! LG",
          "createdAt": "2025-04-17T03:08:54Z",
          "updatedAt": "2025-04-17T03:08:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86larO4",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:02:40Z",
          "updatedAt": "2025-04-17T10:02:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDON1dwo86SskzI",
      "title": "Remove text on expanding datagrams.",
      "url": "https://github.com/ietf-wg-scone/trone/pull/22",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "How to handle network generated TRONE packets is a topic that requires WG discussion. \r\nI recommend that we remove any text on this topic for now and add something back based on the conclusion of #21.",
      "createdAt": "2025-04-15T16:05:26Z",
      "updatedAt": "2025-04-16T12:39:54Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "a4f79332ca9e716f7c255932d800191385ef33f4",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "ihlar-patch-1",
      "headRefOid": "8e0cd81a46e403c12e5e28b63109e6ebc3ec1f63",
      "closedAt": "2025-04-16T12:39:54Z",
      "mergedAt": "2025-04-16T12:39:54Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lDJtL",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T16:26:20Z",
          "updatedAt": "2025-04-15T16:26:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJGCc",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-16T04:11:23Z",
          "updatedAt": "2025-04-16T04:11:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDON1dwo86SsueK",
      "title": "Add \"TRONE Indication\" strawman.",
      "url": "https://github.com/ietf-wg-scone/trone/pull/23",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the meeting, and mentioned in #5, it is useful for an endpoint to signal its potential usage of TRONE to a network element. This initial pass uses a \"TRONE Indication\" packet which is probably excessive but is a fully reversed TRONE packet that's meant to go at the end of a datagram. This allows for the network element to first detect a QUIC initial, and then check the end of the packet for TRONE.\r\n\r\nAn alternative would be a more bespoke indicating like a concatenation of versions, or something like that.",
      "createdAt": "2025-04-15T16:23:30Z",
      "updatedAt": "2025-04-18T04:41:27Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "a4f79332ca9e716f7c255932d800191385ef33f4",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "2f3548f3523392f20915d3b492a258e288188cab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @martinthomson thoughts on this?\r\n\r\nWe can merge as-is and remove fields later, or if we think it's important enough to cut them now I can change it to just be a QUIC version field.",
          "createdAt": "2025-04-16T16:34:53Z",
          "updatedAt": "2025-04-16T16:34:53Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "I think we can merge this pull request (it'd be good to have all features being written down before the adoption call, but we can fix issues after adoption).\r\n\r\nHowever, I realize that indications cannot be designed based solely on Invariants, because packet coalescing is a version-specific concept defined in RFC 9000. So the text has to reflect that at some point at least, and the fact might have an affect on what we append.\r\n\r\nPS. Please see \u2193 for what I mean exactly.",
          "createdAt": "2025-04-18T00:45:20Z",
          "updatedAt": "2025-04-18T04:41:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lFchD",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T20:05:41Z",
          "updatedAt": "2025-04-15T20:05:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJINs",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thank you for the PR.",
          "createdAt": "2025-04-16T04:15:03Z",
          "updatedAt": "2025-04-16T04:28:03Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe QUIC handshake by attaching a TRONE indication packet after the last QUIC long header\r\npacket in the first UDP datagram. The TRONE indication provides an\r\n```\r\n\r\nTrone is designed to be QUIC-version-neutral, so it is better to avoid referring to concepts specific to QUIC v1. Also, even in v1, the first datagram that an endpoint sends might contain an Initial and a Handshake (consider servers).",
              "createdAt": "2025-04-16T04:15:03Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nTRONE support by observing a full TRONE packet after the handshake completes.\r\n\r\nWhen sending QUIC short header packets in the first flight, endpoints SHOULD send them\r\nseparately from the first datagram carrying the TRONE indication packet, to avoid\r\nreceivers incapable of decoding TRONE packets from dropping the short header packet.\r\n```",
              "createdAt": "2025-04-16T04:21:56Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 27,
              "body": "I think there is a question around what TRONE indication packets signal.\r\n\r\nIIRC, TRONE is unidirectional.\r\n\r\nAssuming the use of a TRONE indication packet signals that the sender is capable of _receiving_ TRONE packets, I do not think we need the Rate Signal field here (and separately, I think we can use a different version number for indication packets).",
              "createdAt": "2025-04-16T04:27:46Z",
              "updatedAt": "2025-04-16T14:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lR86Z",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T15:24:25Z",
          "updatedAt": "2025-04-16T15:24:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Agreed, I think all the fields here are likely excessive, but kept them in for now so we can discuss further. A new version is probably fine in terms of avoiding false positives.",
              "createdAt": "2025-04-16T15:24:25Z",
              "updatedAt": "2025-04-16T15:24:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDON1dwo86S8gIt",
      "title": "allow network elements rewrite the version field",
      "url": "https://github.com/ietf-wg-scone/trone/pull/25",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526 and during yesterday's interim, we can simplify the design by allowing network elements rewrite the version field.\r\n\r\nNow, senders need to send only one packet (0xTRONE2 with rate=0x3f) instead of sending one for each of the two versions, and receivers no longer need to calculate the minimum of two values.\r\n\r\nMaybe closes #14 and #19.",
      "createdAt": "2025-04-17T07:09:13Z",
      "updatedAt": "2025-04-18T01:57:48Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/changing-versions",
      "headRefOid": "6cd6dac6489a78922f2b3b2b653c47a2b8bc014c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this! Was writing up something basically the same.\r\n\r\nDo we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.",
          "createdAt": "2025-04-18T00:26:09Z",
          "updatedAt": "2025-04-18T00:26:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "Thank you for checking!\r\n\r\n> Do we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.\r\n\r\nMaybe raise as a different issue?\r\n\r\nBut FWIW, I do not think we want to neither allow or prohibit endpoints from mangling other versions of QUIC. It is not our business, and in the future, we might see another version of QUIC that recommends endpoints doing such a thing (example: a super-ECN signal that changes the bits in UDP payload). I think what we might need to add is a pointer to RFC 8999 regarding the topic.",
          "createdAt": "2025-04-18T01:57:46Z",
          "updatedAt": "2025-04-18T01:57:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lakq6",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for this PR. \r\nLooks really good, small nit commented below. ",
          "createdAt": "2025-04-17T09:52:01Z",
          "updatedAt": "2025-04-17T09:58:59Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "178 is at n = 61 \r\nn = 62 should be ~199.53. \r\n\r\n```suggestion\r\nWith two versions combined, bitrates between 100 Kbps and 199.5 Gbps can be\r\n```",
              "createdAt": "2025-04-17T09:52:01Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n| 0xTRONE2 | 62          | 199.5 Gbps  |\r\n```",
              "createdAt": "2025-04-17T09:53:17Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n   (up to 199.5 Gbps)\r\n```",
              "createdAt": "2025-04-17T09:53:57Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lbbuP",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-17T11:34:12Z",
          "updatedAt": "2025-04-17T11:34:12Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Thank you!",
              "createdAt": "2025-04-17T11:34:12Z",
              "updatedAt": "2025-04-17T11:34:12Z"
            }
          ]
        }
      ]
    }
  ]
}