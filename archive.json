{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-27T01:36:13.751606+00:00",
  "repo": "ietf-wg-scone/trone",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "bike shed",
      "description": "",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDON1dwo86qsnWm",
      "title": "Throughput advice format",
      "url": "https://github.com/ietf-wg-scone/trone/issues/1",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While we're figuring out how to agree on a throughput advice format we could initially include both options:\n\n- A TRAIN Packet always includes a payload field of size N after the SCID. \n- The third most significant bit is set to 1 when a network element updates the payload field. \n- If the bit is not set, the low 5 bits are used to signal a preset rate.",
      "createdAt": "2025-02-19T16:20:44Z",
      "updatedAt": "2025-02-20T10:26:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "We are back to the composability argument. TRAIN is designed to pick \"the lowest of multiple assertions\". During the discussion, I heard the view that there is no need for that, because in practice there is only one bottleneck and one TRAIN rewriter. I am really not sure about that -- I can really imagine a cascade of NATs, each believing that they are the only one enforcing bandwidth. The rule that you propose implies that any \"rewriter\" must check a specific bit, and if it is set jump to the payload and analyze it. Which implies that all on path agents will need to support \"checking the payload\", in which case I am not sure I see the point of having the information in the top bits.",
          "createdAt": "2025-02-20T08:15:50Z",
          "updatedAt": "2025-02-20T08:15:50Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's fine if we eventually converge on a single format / location for the advice (I have my bias already).  \nIn order to get there it might be useful to have both options on the table so we can do some early implementations and measurements.\n\nAlso, with regards to composability. I agree that there are possible cases, but they are probably not that common. A network element that only considers the top bits could simply not send throughput advice if it sees the \"check the payload\" bit. ",
          "createdAt": "2025-02-20T10:26:28Z",
          "updatedAt": "2025-02-20T10:26:28Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDON1dwo86qspaJ",
      "title": "Name",
      "url": "https://github.com/ietf-wg-scone/trone/issues/2",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bike shed"
      ],
      "body": "We have a few options:\n\n1. Keep TRAIN\n2. Find something that fits TRONE\n3. Completely new name, e.g., Throughput Advice Signaling Protocol (TASP)\n\nI'd be fine with any of the above. ",
      "createdAt": "2025-02-19T16:24:24Z",
      "updatedAt": "2025-02-19T16:24:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDON1dwo86u3xiG",
      "title": "Adoption and Business implications of \"A single Rate Signal field\"",
      "url": "https://github.com/ietf-wg-scone/trone/issues/4",
      "state": "OPEN",
      "author": "atiwariphd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The payload of a TRONE packet consists of a single Rate Signal field\n\nI would like to raise an issue to make sure everyone understands the adoption and business implication of the above constraint. \n\nA single rate value does not clearly explain how this rate should be measured and how the two parties (the sender of the rate signal and recipient of the rate signal) should interpret this signal in a consistent fashion. So if two parties (a Communication Service Provider and a Content and Application Provider) want to use this signal, they will have to have offline discussions between their business and technical teams to establish a common way of interpreting this signal. \n\nThis inherently will create barriers to entry for small app startups to use TRONE because typically small startups do not have the luxury of hiring a large partnership and technology ecosystems team to interface with multiple CSPs around the world to figure out how to interpret the \"single rate signal\" coming from their network.\n\nWe need to ask ourselves, do we want IETF to design a protocol that is only usable by large companies with plenty of resources?",
      "createdAt": "2025-03-20T02:49:44Z",
      "updatedAt": "2025-03-20T10:44:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is a lot of value in simplicity. A single rate signal and guidance in the document around how to interpret the signal makes it easy to reason about. \nDifferent CSPs might measure conformance in different ways, but the associated action to detection of non-conforming traffic would likely be that policing is re-introduced for a flow, or that a lower rate is signaled. Both these actions can be detected and acted upon by the endpoints. ",
          "createdAt": "2025-03-20T10:44:23Z",
          "updatedAt": "2025-03-20T10:44:23Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDON1dwo86u5K3z",
      "title": "Client initiated TRONE signal (uplink direction) with implicit support for flow detection",
      "url": "https://github.com/ietf-wg-scone/trone/issues/5",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 of the draft shows \"QUIC Sender\", ie, the server initiates the TRONE signal toward the client. This implies that TRONE signal is going to be server initiated. This will result in having the \"network element\" listens to all IP flows in the downlink direction. This is CPU intensive\n2. The authors should consider a design that is independent of SNI-based flow detection\n3. The authors should reconsider this design and allow for CLIENT initiated TRONE signaling (uplink direction) with implicit support for  flow detection\n\nAs a point of reference, section 6 of draft mishra-scone-usercase-00, added following requirement:\nSCONE (aka TRONE) signal MUST be a client-application endpoint initiated to assist the network element (UPF/5G or PGW/4G) with the implicit flow detection\nplease see https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.1.1",
      "createdAt": "2025-03-20T06:13:47Z",
      "updatedAt": "2025-03-20T06:45:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TRONE packets are sent by each endpoint individually, so there is opportunity for the client to send an early TRONE packet such that a network element that keeps some flow state can use the presence of a TRONE packet as an indication to not do further DPI and SNI parsing etc. \nThe problem in the current draft version is that endpoints need to indicate support using transport parameters before  sending TRONE packets. The authors have discussed an approach where an opportunistic TRONE \"indication\" can be appended to a QUIC initial packet. The network element can use this information as an indication that the client is willing to receive rate signals. \nAs opposed to \"regular\" TRONE packets, this indication would have to be appended to the end of a QUIC Initial packet.",
          "createdAt": "2025-03-20T06:43:56Z",
          "updatedAt": "2025-03-20T06:45:35Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDON1dwo86u5RKN",
      "title": "Network Element initiate TRONE packet for Dynamic update of Throughput advise based on changing RAT or subscription plan",
      "url": "https://github.com/ietf-wg-scone/trone/issues/6",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 states \"A network element detects a TRONE packet by observing that a packet has a QUIC long header and the TRONE protocol version of 0xTBD.\" A network element then conditionally replaces the Rate Signal field with values of its choosing\"\n\nAbove implies that 'network element\" has to wait/rely on server to originate a TRONE packet for the NE to send advisory bit-rate towards the client.\n\nThis may not work well when we consider a use case such as the mobile user may move from one Radio Access Technology to another (4G to 5G or vice-versa) during an ongoing video session. Ideally, the NE should be in a position to send dynamically an  updated Throughput advisory bit-rate on its own without having to wait for server to originate a TRONE packet.\n\nIn another use case, there can be a need for the NE to send an updated Throughput advisory bitrate, if there is any change in consumption of subscribers' data plan.\n\nThere is also a requirement added in mishra-scone-usecase-00 that calls out:\nDynamic update - \"throughput advice\" MAY change during the ongoing flow and UPF/PGW SHOULD be able to send \"throughput advice\" to client-application-endpoint as soon as possible.\n\nPlease refer to https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.5.1\n\n",
      "createdAt": "2025-03-20T06:26:49Z",
      "updatedAt": "2025-03-20T06:54:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, we do want the ability to signal rate changes in a timely fashion. \nThere are however, a number of ways to achieve this. \nIf we make it cheap enough to update the rate signal field, we can provide guidance to endpoints to generate TRONE packets at a relatively high frequency. One such advice would be to send a new advice for every new application layer \"burst\" such as the transmission of a set of HLS/DASH video segments. \nFurthermore, it is possible for network elements to insert TRONE packets of its own and expand UDP datagrams. Hopefully this will not be needed, but can be a last resort if the TRONE packet frequency is too low. Special care needs to be taken to not run into Path MTU issues, so guidance around not expanding datagrams to sizes larger than 1200 bytes (smallest maximum datagram payload size that needs to be supported for QUIC v1/v2)  could be needed.",
          "createdAt": "2025-03-20T06:54:52Z",
          "updatedAt": "2025-03-20T06:54:52Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDON1dwo86u5cxB",
      "title": "Client-side explicit ACK for receipt of TRONE packet",
      "url": "https://github.com/ietf-wg-scone/trone/issues/7",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "7.3.  Feedback To Sender About Signals \n\nSuggest that the TRONE draft consider a use case for client to send an explicit ACK to the \"network element\" upon receiving a TRONE packet. Without an explicit ACK, a NE may not know if the client has received the latest Throughput advisory bit-rate. This may help the scenario where a client may not self regulate due to loss of TRONE packet with the most recent Throughput advisory bit-rate.\n\nAdding a requirement that support the ACK from client to the network element. \n\nI-D mishra-scone-usecase-00 listed the following requirement: \n\nClient-application endpoint SHOULD send acknowledgement receipt of throughput advisory signal from the network element using the SCONE (TRONE) signal\n\nhttps://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.3.1",
      "createdAt": "2025-03-20T06:50:46Z",
      "updatedAt": "2025-03-20T09:37:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if acknowledging the receipt of a specific TRONE packet adds much value. \nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place. \nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not. ",
          "createdAt": "2025-03-20T09:37:12Z",
          "updatedAt": "2025-03-20T09:37:12Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDON1dwo86vExP6",
      "title": "Detail interaction with congestion control",
      "url": "https://github.com/ietf-wg-scone/trone/issues/8",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "This came on repeatedly during the Bangkok IETF session. Congestion control and Trone are complementary, but we need to explain how that complementing works.",
      "createdAt": "2025-03-21T04:53:23Z",
      "updatedAt": "2025-03-26T15:48:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "Totally agreed @huitema . We tried to describe the distinction between SCONE and ECN in an [earlier draft](https://datatracker.ietf.org/doc/draft-tomar-scone-ecn/) but I am glad you are owning up to describe the complementarity of Trone and congestion control wholistically.",
          "createdAt": "2025-03-26T15:48:42Z",
          "updatedAt": "2025-03-26T15:48:42Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDON1dwo86vE006",
      "title": "Consider a way to do greasing",
      "url": "https://github.com/ietf-wg-scone/trone/issues/9",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is a bit of ambiguity in the specification of \"who uses TRONE\". The original Scone WG appears to have focused on adaptive bit rate video. If we strictly kept that focus, we have a privacy issue. Third parties could observe the presence of Trone headers, and infer that the end to end QUIC connection is engaged in video streaming.\n\nTo reduce the privacy issue, we could adopt a combined strategy, and ask more applications to support Trone, thus weakening the correlation between Trone and video.\n\nWe could also envisage greasing, with applications sending datagrams composed of a Trone packet, followed by a short header and random content. If the peer is not Trone capable, such greasing packets will be discarded because they do done decrypt correctly. But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.",
      "createdAt": "2025-03-21T05:04:11Z",
      "updatedAt": "2025-03-26T17:43:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "> But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.\n\nI am assuming you are referring to the network element as the \"third party\" here. If you prevent the network element from distinguishing the \"real\" Trone packets from the Greased packets, then how will the network element decide which packet to add the rate advisory to?",
          "createdAt": "2025-03-26T08:32:29Z",
          "updatedAt": "2025-03-26T08:32:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@atiwariphd the network element cannot distinguish between grease and real TRONE packet. I documented that as an attack in a separate PR #13 ",
          "createdAt": "2025-03-26T17:43:14Z",
          "updatedAt": "2025-03-26T17:43:14Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDON1dwo86vE3Wm",
      "title": "Could network elements mangle innocent packets?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/10",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is already discussed in the [TRAIN issue 32](https://github.com/martinthomson/train-protocol/issues/32). A Trone intermediary can mistake packets of some other applications for Trone packets. If it reqrite 6 bits, that will cause the packet to be eithre dropped or misinterpreted.\n\nAs explained by @ihlar during the IETF meeting in Bangkok, we need to distinguish:\n\n1. random collision: the end to end application issues some random first bytes that happen to mimic Trone. It will happen at low frequency.\n2. systematic collision: the end to end collision had negotiated some header that happens to Mimic Trone. All packets with that header will be mangled.\n\nThe proposed solution is for intermediaries to keep flow state and stop marking if too many packets of a flow match Trone. We need to develop that.\n",
      "createdAt": "2025-03-21T05:11:54Z",
      "updatedAt": "2025-03-21T05:11:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDON1dwo86vE_RE",
      "title": "Spoofing attacks against intermediaries",
      "url": "https://github.com/ietf-wg-scone/trone/issues/11",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In issue #9 we discuss the possibility of greasing TRONE. Greasing is cool for privacy, but the same mechanisms can be used as an attack. Suppose something like:\n\n~~~\n+------------+    +----------+       /---------------\\       +-------------+\n|end point A | -- | Trone NE | ---- ( Big bad Internet) ---- | end point B |\n+------------+    +----------+       \\---------------/       +-------------+\n                                          |\n                                          |\n                                    +-------------+\n                                    | wily hacker |\n                                    +-------------+\n~~~\n\nThe hacker creates Trone packets with:\n\n* IP / UDP header: set IP source to address of B, IP destination to address of A\n* SCONE packet: pick a destination CID and a destination CID\n* 1RTT header: same destination  CID as SCONE packet\n* 1 RTT content: enough random bytes to look plausible\n\nThe attacker needs to know at least a valid address for end point A, so the packets will be routed through the target NE, but after that there are many possibilities:\n\n* an off path attacker can pick random values for the source address of \"B\" and for the CID.\n* an on path attacker can pick pairs of addresses that match existing hosts \"A\" and \"B\" and either random CID or CID copied from observed traffic.\n\nThe possible effects would be:\n\n* trick the NE into \"remembering\" lots of TRONE context, thus consuming lots of memory\n* force the NE to process a vast quantity of TRONE packets, thus consuming lots of resource\n* trick the NE into detecting a \"systematic collision\" (see issue #10) and thus disable TRONE for that flow.\n ",
      "createdAt": "2025-03-21T05:38:19Z",
      "updatedAt": "2025-03-21T05:38:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDON1dwo86vv_gA",
      "title": "Is the \"version=range\" paradigm appropriate?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/14",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As presented at IETF 122, we define a \"version\" field that is used to choose between possible ranges.\nThis seems strange both from a cleanliness standpoint and from a greasing standpoint.\n\nWhen there are only two versions, the version field amounts to an extra bit in the range specifier - by including it directly in the range specifier (making it 0-127 rather than 0-63), we gain an unified range with a larger span (or a finer resolution, if we choose to reduce the multiplier in the exponential spacing).\n\nIf we desire to ensure that we can introduce more versions of the TRONE signal later, two versions with near-identical semantics are not enough.\n",
      "createdAt": "2025-03-26T07:03:56Z",
      "updatedAt": "2025-03-26T07:03:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDON1dwo86v0U91",
      "title": "TRONE with other protocols - ICE in particular?",
      "url": "https://github.com/ietf-wg-scone/trone/issues/15",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As specified, the TRONE protocol only works with QUIC. And given that it can prepend data to a datagram, it is not a drop-in with anything but QUIC.\n\nThis form of signalling is interesting to other use cases. Would it be reasonable/possible/hard/impossible to carry a TRONE packet as an ICE extension?\n",
      "createdAt": "2025-03-26T14:02:31Z",
      "updatedAt": "2025-03-26T23:29:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "@alvestrand \n\n> This form of signalling is interesting to other use cases.\n\nCan you please articulate the use case?",
          "createdAt": "2025-03-26T15:43:02Z",
          "updatedAt": "2025-03-26T15:43:02Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "The classical WebRTC VC use case is one where we set up a video call (usually between the user and a datacenter), and we want to adapt the codec configuration to the available bandwidth.\nToday we do that using congestion control only.\n",
          "createdAt": "2025-03-26T16:30:28Z",
          "updatedAt": "2025-03-26T16:30:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "See issue #9 about greasing. The intermediaries do not know that a TRONE packet is in fact a QUIC packet. They merely see a TRONE packet followed by a QUIC like byte, a repeat of the connection identifier bytes, and a bunch of random looking bytes. If you want to add more complexity to ICE, your ICE implementation could certainly send UDP packets that match that format. QUIC enpoints use the \"random bytes\" for verifying that the packet is legit; you could use this random bytes to carry some kind of verifier in your ICE/TRONE packets.",
          "createdAt": "2025-03-26T17:54:06Z",
          "updatedAt": "2025-03-26T17:54:06Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "ICE packets are distinguished from other packets by looking at the first byte. TRONE packets, as specified, would put a different value in the first byte. See https://datatracker.ietf.org/doc/html/rfc7983#section-7\nIt would be trivial to specify a TRONE packet as an ICE attribute, and ICE even has support for protecting only some of the attributes in an ICE packet (it uses a hash over the message + a shared secret), but it's a non-trivial job for the router to find the TRONE packet inside the ICE message.\n",
          "createdAt": "2025-03-26T21:00:02Z",
          "updatedAt": "2025-03-26T21:00:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@alvestrand that's why I suggested sending two messages, the ICE message proper, and a separate \"TRONE\" message on the same 4-tuple.",
          "createdAt": "2025-03-26T23:29:28Z",
          "updatedAt": "2025-03-26T23:29:28Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDON1dwo86MqU5p",
      "title": "Transparent Rate Optimization for Network Endpoints (TRONE)",
      "url": "https://github.com/ietf-wg-scone/trone/pull/3",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An attempt at TRONE.\r\nWe can bikeshed the name in #2.\r\n\r\nThe PR uses TRAIN as a baseline so that it's easier to review the changes from TRAIN.\r\nNote that this version changes the rate signal field to a field with explicit values, located after the CIDs.\r\nIf we're very unsure about the design tradeoffs we could consider doing both the TRAIN and TRONE ways as discussed in #1.\r\n\r\nThere's also a discussion on how network elements are capable of crafting TRONE packets. ",
      "createdAt": "2025-02-26T15:03:17Z",
      "updatedAt": "2025-03-05T13:18:41Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "b568f3314171b26d5bc38891e21c4f5f714a4c55",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "advice-format",
      "headRefOid": "946f94dac013f33e4c29520a5bdcb13f877e212c",
      "closedAt": "2025-03-03T17:42:04Z",
      "mergedAt": "2025-03-03T17:42:04Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "681b12c446391332da002b4b3cf33a0d51ab3f64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86d7v0C",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T04:25:32Z",
          "updatedAt": "2025-02-28T04:25:33Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Even if I thought that this was necessary, this is probably not the right logic to use here.  You are going to independently reduce the rate and window size.  If you don't reduce one, but you reduce the other, that is sometimes going to reduce the actual send rate below your target.  That's another reason I don't like this design.",
              "createdAt": "2025-02-28T04:25:33Z",
              "updatedAt": "2025-02-28T04:25:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86d9h0k",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T09:02:21Z",
          "updatedAt": "2025-02-28T09:02:21Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Yeah, composability makes this solution a bit messy. I've been a bit back and forth on this.  My original thinking was to only check the rate and update the window unconditionally:\r\n`if packet_rate == 0 or target_rate < packet_rate:`\r\n`    write_uint32(packet[offset : offset + 4], target_rate)`\r\n`    write_uint32(packet[offset + 4 : offset + 8], target_aw)`\r\n\r\n    \r\nThat could lead to the sending of bursts that are not tolerated by the element further upstream. \r\nIt might be the least messy thing to do with this design though. (And I still think the case with chained elements who wish to signal rates is a rather exceptional one).",
              "createdAt": "2025-02-28T09:02:21Z",
              "updatedAt": "2025-02-28T13:10:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eFfDm",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "billwuqin",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T04:40:27Z",
          "updatedAt": "2025-03-01T04:40:27Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Thank for getting together baking this draft among authors, thanks for Martin to enage this discussion, I am wondering\r\nIs there possible to leave this as one open issue or split it from PR#3 and move to new PR. \r\nI hope we can have one posted version before submission deadline, let us know what we can do to help move the way forward.",
              "createdAt": "2025-03-01T04:40:27Z",
              "updatedAt": "2025-03-01T04:40:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eF4Fl",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T07:53:46Z",
          "updatedAt": "2025-03-01T07:53:47Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "The latest commit contains an update in response to Martin's comment, fixing the logic so that average window is not updated separately from updating the rate limit. Which is probably the right thing to do, given this design. \r\n\r\nThere is a larger issue around the structure and placement of the rate signal, something the WG needs to resolve. I would hope that the merged document can contain the latest commit and then we have the broader discussion as an open issue, see #1 for instance. ",
              "createdAt": "2025-03-01T07:53:46Z",
              "updatedAt": "2025-03-01T07:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eOFsQ",
          "commit": {
            "abbreviatedOid": "2b0ef2f"
          },
          "author": "mjoras",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T15:35:01Z",
          "updatedAt": "2025-03-03T15:35:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86enOJN",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T13:18:41Z",
          "updatedAt": "2025-03-05T13:18:41Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "To be clear, I did not approve this document.",
              "createdAt": "2025-03-05T13:18:41Z",
              "updatedAt": "2025-03-05T13:18:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDON1dwo86P8JWx",
      "title": "Initial attempt at adding version-dependent logarithmic rates",
      "url": "https://github.com/ietf-wg-scone/trone/pull/12",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First pass, expecting there will be further changes needed. There seemed to be general consensus around this approach, which we believe we need to take before an adoption call.",
      "createdAt": "2025-03-24T22:03:34Z",
      "updatedAt": "2025-03-26T05:58:47Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "ad1f5972492fccf779c7684e85b5a52c5931353b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86ho3fT",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thank you for the PR. Looks good overall.",
          "createdAt": "2025-03-24T22:45:22Z",
          "updatedAt": "2025-03-24T23:06:41Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n| 10 | 316 Kbps | 31.6 Mbps |\r\n```",
              "createdAt": "2025-03-24T22:45:22Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 75,
              "body": "I think we do not have these in the proposed encoding? (and IMO we probably do not need them)",
              "createdAt": "2025-03-24T22:46:27Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 89,
              "body": "Do we need this change? Not that it is incorrect, but seems a bit verbose, as the Rate Signal field is defined to be six bits.",
              "createdAt": "2025-03-24T22:48:01Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n```\r\nAs we read `version` from the packet later (see `packet[1..5]`), maybe it makes sense to delay the invocation of `convert_rate_to_signal` after that. Something like below.",
              "createdAt": "2025-03-24T22:51:30Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\npacket_version = packet[1..5]\r\nif is_long and (packet_version == TRONE1_VERSION or packet_version == TRONE2_VERSION):\r\n  target_rate_value = convert_rate_to_signal(target_rate, packet_version)\r\n```",
              "createdAt": "2025-03-24T22:54:25Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nshould signal the minimum value (0) for rates below the range and preserve the\r\noriginal value for rates above the range.\r\n```\r\nWhen there are multiple network elements, the Rate Signal field might convey a value other than 63.",
              "createdAt": "2025-03-24T23:02:53Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-03-24T23:03:14Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Do we want to state that values 0 to 62 represents the ceiling values?",
              "createdAt": "2025-03-24T23:05:53Z",
              "updatedAt": "2025-03-24T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpc5V",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:58:13Z",
          "updatedAt": "2025-03-25T00:58:13Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "You're right I got my wires crossed from my notes.",
              "createdAt": "2025-03-25T00:58:13Z",
              "updatedAt": "2025-03-25T00:58:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpT6C",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:29:04Z",
          "updatedAt": "2025-03-25T01:21:17Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I would not do it this way.  Instead, I would set the target rate value for each version as follows:\r\n\r\n```python\r\nversions = [TRONE_VERSION1, TRONE_VERSION2]\r\ntarget = [63, 63]\r\nfor i in 1..len(versions):\r\n    target[i] = convert_rate(target_rate, versions[i])\r\n\r\n# then when a packet arrives\r\nif packet[0] & 0x80 != 0x80:\r\n    skip\r\ni = find(versions, packet[1..5])\r\nif i is not None and packet[0] & 0x3f > target[i]:\r\n    packet[0] = packet[0] & 0xc0 | target[i]",
              "createdAt": "2025-03-25T00:29:04Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n* Support for both very low bitrates (down to 100 Kbps) and very high bitrates\r\n  (up to 12.5 Gbps)\r\n* Graceful handling of network elements that might only recognize one version\r\n  or some subset of future versions.\r\n```\r\n\r\nThis is unordered.",
              "createdAt": "2025-03-25T00:29:47Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n* When sending TRONE packets, endpoints SHOULD alternate between versions\r\n```\r\nUnordered",
              "createdAt": "2025-03-25T00:30:41Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n* Network elements SHOULD apply appropriate rate signals to all packets that\r\n   include a TRONE version they support.\r\n```",
              "createdAt": "2025-03-25T00:31:45Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 170,
              "body": "We need to talk about rounding.\r\n\r\nIn practice, if the bitrate formula is $r=b * 10^{\\frac{n}{20}}$, the inverse is $n=\\left\\lceil 20 * \\log_{10}(\\frac{r}{b})\\right\\rceil$  or $n=\\left\\lfloor 20 * \\log_{10}(\\frac{r}{b})\\right\\rfloor$ but we should offer guidance on which to choose.",
              "createdAt": "2025-03-25T00:36:56Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqTg8",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:24:09Z",
          "updatedAt": "2025-03-25T03:25:23Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "We should talk about the privacy trade-offs with respect to sending each.  I think that it is reasonable to send both unconditionally, but it might be better to only send these when the estimated bandwidth availability enters the range covered by each.\r\n\r\nAn application that is currently operating in the TRONE1 range could decide that it only needs to send TRONE1 packets.  That limits the number of markings that are needed and does not reveal anything extra.  The challenge being in ensuring that the network element is aware that TRONE markings are available.  For that, I would recommend always sending one packet at least once, even when the active usage is well outside of the protocol-defined ranges.\r\n\r\n\r\nHowever, an application that MIGHT operate in just the TRONE2 range reveals information that the network does not otherwise obtain if it sends the TRONE2 signal.",
              "createdAt": "2025-03-25T03:24:09Z",
              "updatedAt": "2025-03-25T03:25:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqVP1",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:28:07Z",
          "updatedAt": "2025-03-25T03:28:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Or more clever:\r\n\r\n```python\r\ni = find(versions, packet[1..5]) if packet[0] & 0x80 == 0x80 else None\r\nif i is not None and ...\r\n```",
              "createdAt": "2025-03-25T03:28:07Z",
              "updatedAt": "2025-03-25T03:28:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrFXa",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:31:29Z",
          "updatedAt": "2025-03-25T05:31:30Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Agreed. Should I leave the text here while we work through this nuance or do you think there's something better to put in its place for now?",
              "createdAt": "2025-03-25T05:31:30Z",
              "updatedAt": "2025-03-25T05:31:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrGof",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:34:29Z",
          "updatedAt": "2025-03-25T05:34:29Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "An issue for followup is fine.",
              "createdAt": "2025-03-25T05:34:29Z",
              "updatedAt": "2025-03-25T05:34:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86htdY0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T09:38:15Z",
          "updatedAt": "2025-03-25T09:38:15Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "In the current state, I do not think we need to talk about rounding.\r\n\r\nWe state that the code points represent the ceiling. That means code points 0, 20, 40, 60 represent `<= 100Kbps`, `<= 1Mbps`, `<=10Mbps`, `<=100Mbps`, as they are divisible. OTOH, other values are indivisible. For example, 10<sup>1/20</sup> is 112201.84..., meaning that code point 1 represents bit rate up to 112,201bps.\r\n\r\nMaybe all we need to provide is these examples.\r\n\r\nOf course, we could go the other way and state that the 3 (or 4) most significant digits of the log function represents the bit rate...",
              "createdAt": "2025-03-25T09:38:15Z",
              "updatedAt": "2025-03-25T09:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2MB3",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I think this is fine, except for the confusion between \"no TRONE on this path\" and \"no limit\".",
          "createdAt": "2025-03-25T22:21:17Z",
          "updatedAt": "2025-03-25T22:27:26Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think saying \"63 = No limit\" conflates two separate notions:\r\n\r\n* the TRONE protocol is not supported by network elements on the path (definition of 0x3F above)\r\n* the limit is higher that either 126Mbps or 12.6 Gbps.\r\n\r\nWe could remove that issue by defining the last lines of the table as:\r\n\r\n| 60 | 100 Mbps | 10 Gbps |\r\n| 62 | No limit | No limit |\r\n| 63 |  TRONE not supported on path |  TRONE not supported on path |\r\n\r\n\r\n",
              "createdAt": "2025-03-25T22:21:17Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 122,
              "body": "Would be \"up to 10Gbps\" if we use only 62 actual ranges.",
              "createdAt": "2025-03-25T22:22:38Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 170,
              "body": "I think it is fine to base the rounding on the table. I think we should say \"pick the highest rate signal that correspond to a value lower or equal to the rate\", but it might be a local decision.",
              "createdAt": "2025-03-25T22:25:20Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2_U7",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T00:54:09Z",
          "updatedAt": "2025-03-26T00:54:10Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "We should offer advice to network operators on the consequences of different choices.  Rounding down has the effect of guaranteeing that the used capacity is lower than the target.  However, given that applications that employ rate adaptation will rarely be able to completely use the given bandwidth, it might be better to pick a higher number.  Especially given that any excess is never more than about 11% higher than the previous step.",
              "createdAt": "2025-03-26T00:54:10Z",
              "updatedAt": "2025-03-26T00:54:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Khj",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:16:12Z",
          "updatedAt": "2025-03-26T04:16:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm not convinced that we need that feature.  What would  you do with that information?",
              "createdAt": "2025-03-26T04:16:12Z",
              "updatedAt": "2025-03-26T04:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4UB0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:47:48Z",
          "updatedAt": "2025-03-26T04:47:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think there is a difference between \"more than 10Gbps\" and \"don't know\". In one case, the app has the go ahead to use a vast amount of bandwidth. In the other, the app has to proceed cautiously and rely on congestion control for a bandwidth estimate.",
              "createdAt": "2025-03-26T04:47:48Z",
              "updatedAt": "2025-03-26T04:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Ymh",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:04:16Z",
          "updatedAt": "2025-03-26T05:04:16Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "`10M*10^{62/20}` = 12.589G; `10M*10^{61/20}` = 11.220G.  We only get 10G if we decide to use 61 ranges.",
              "createdAt": "2025-03-26T05:04:16Z",
              "updatedAt": "2025-03-26T05:04:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Zl7",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:07:16Z",
          "updatedAt": "2025-03-26T05:07:16Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I can't conceive of a scenario where an app would see an \"uncapped\" signal and decide that it can switch to sending at line rate.  You are taking the word of one path element and extrapolating to the entire path.\r\n\r\nLet's say that you get a 1Mbps signal.  You are currently at ~30kbps.  It might be reasonable to skip a few steps in your capacity probing to get closer to 1Mbps.  But that might be based on an assumption about the relative availability of bandwidth in modern networks and maybe past experience with the same network; I doubt you would make the same guess at 1Tbps (if that were a possible signal, that is).\r\n\r\nI conclude that while the congestion controller might be nudged a little, senders still need to have one and use that to probe the actual path availability.  The network still has queues and other users.  Expressions of policy limitations don't necessary entail guarantees, even at the node that is making that assertion.",
              "createdAt": "2025-03-26T05:07:16Z",
              "updatedAt": "2025-03-26T05:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4m8S",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:51:58Z",
          "updatedAt": "2025-03-26T05:51:58Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Sorry, I didn't do the math. But yes, that's the crux of the debate. We have 64 code points, from 0 to 63. If we reserve one to say \"don't know\", that means using only 62 code points, the last one marking the unbounded range.",
              "createdAt": "2025-03-26T05:51:58Z",
              "updatedAt": "2025-03-26T05:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4pOz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:58:46Z",
          "updatedAt": "2025-03-26T05:58:47Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I really need to get going on writing the congestion control part. There are a couple of ways to use a \"bandwidth cap\". It could solve one specific problem, stop the \"slow start\" exponential growth early. It could fit with the \"careful resume\" mechanism -- very that the new connection has the same cap as the previous one before reusing values learned before. It could inform of bandwidth drop, controlling the building of queues when the congestion controller discovers the new capacity. It could inform \"resume after congestion\" mechanisms, to grow sending rate quicker after transient congestion stops. At the application level, it can inform choice of codecs...",
              "createdAt": "2025-03-26T05:58:46Z",
              "updatedAt": "2025-03-26T05:58:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDON1dwo86QF6Tw",
      "title": "Description of DOS attack against intermediaries",
      "url": "https://github.com/ietf-wg-scone/trone/pull/13",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Adding a description of the attack listed in #11.\r\n\r\nClose #11",
      "createdAt": "2025-03-25T18:25:44Z",
      "updatedAt": "2025-03-25T18:26:27Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "sec-rec-inter",
      "headRefOid": "7433288acc0264684fdadc14630f56fbdae4cabe",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDON1dwo86QQjgP",
      "title": "First cut for congestion and TRONE interaction",
      "url": "https://github.com/ietf-wg-scone/trone/pull/16",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think that we need to explicitly describe the interaction between congestion control and TRONE, if only to dispel any notion that TRONE replaces congestion control, as stated in issue #8. This is a first cut for describing such interactions. ",
      "createdAt": "2025-03-26T18:51:48Z",
      "updatedAt": "2025-03-26T18:51:48Z",
      "baseRepository": "ietf-wg-scone/trone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/trone",
      "headRefName": "first-congestion",
      "headRefOid": "05c4968e3fef1ddfe29c6b0f017f16f798e02bc6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}