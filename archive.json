{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-08-10T02:01:07.161181+00:00",
  "repo": "ietf-wg-scone/scone",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "propose-no-action",
      "description": "The editors believe that the draft already addresses this.",
      "color": "ffffff"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "bike shed",
      "description": "",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDON1dwo86qsnWm",
      "title": "Throughput advice format",
      "url": "https://github.com/ietf-wg-scone/scone/issues/1",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While we're figuring out how to agree on a throughput advice format we could initially include both options:\n\n- A TRAIN Packet always includes a payload field of size N after the SCID. \n- The third most significant bit is set to 1 when a network element updates the payload field. \n- If the bit is not set, the low 5 bits are used to signal a preset rate.",
      "createdAt": "2025-02-19T16:20:44Z",
      "updatedAt": "2025-04-08T11:32:27Z",
      "closedAt": "2025-04-08T11:32:26Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We are back to the composability argument. TRAIN is designed to pick \"the lowest of multiple assertions\". During the discussion, I heard the view that there is no need for that, because in practice there is only one bottleneck and one TRAIN rewriter. I am really not sure about that -- I can really imagine a cascade of NATs, each believing that they are the only one enforcing bandwidth. The rule that you propose implies that any \"rewriter\" must check a specific bit, and if it is set jump to the payload and analyze it. Which implies that all on path agents will need to support \"checking the payload\", in which case I am not sure I see the point of having the information in the top bits.",
          "createdAt": "2025-02-20T08:15:50Z",
          "updatedAt": "2025-02-20T08:15:50Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's fine if we eventually converge on a single format / location for the advice (I have my bias already).  \nIn order to get there it might be useful to have both options on the table so we can do some early implementations and measurements.\n\nAlso, with regards to composability. I agree that there are possible cases, but they are probably not that common. A network element that only considers the top bits could simply not send throughput advice if it sees the \"check the payload\" bit. ",
          "createdAt": "2025-02-20T10:26:28Z",
          "updatedAt": "2025-02-20T10:26:28Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on the agreed design this issue is no longer relevant. ",
          "createdAt": "2025-04-08T11:32:26Z",
          "updatedAt": "2025-04-08T11:32:26Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDON1dwo86qspaJ",
      "title": "Name",
      "url": "https://github.com/ietf-wg-scone/scone/issues/2",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bike shed"
      ],
      "body": "We have a few options:\n\n1. Keep TRAIN\n2. Find something that fits TRONE\n3. Completely new name, e.g., Throughput Advice Signaling Protocol (TASP)\n\nI'd be fine with any of the above. ",
      "createdAt": "2025-02-19T16:24:24Z",
      "updatedAt": "2025-05-05T14:46:37Z",
      "closedAt": "2025-05-05T14:46:37Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could also call it SCONE.\n",
          "createdAt": "2025-04-16T16:04:53Z",
          "updatedAt": "2025-04-16T16:04:53Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please implement the naming change in the draft.",
          "createdAt": "2025-04-23T07:00:07Z",
          "updatedAt": "2025-04-23T07:00:07Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDON1dwo86u3xiG",
      "title": "Adoption and Business implications of \"A single Rate Signal field\"",
      "url": "https://github.com/ietf-wg-scone/scone/issues/4",
      "state": "CLOSED",
      "author": "atiwariphd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The payload of a TRONE packet consists of a single Rate Signal field\n\nI would like to raise an issue to make sure everyone understands the adoption and business implication of the above constraint. \n\nA single rate value does not clearly explain how this rate should be measured and how the two parties (the sender of the rate signal and recipient of the rate signal) should interpret this signal in a consistent fashion. So if two parties (a Communication Service Provider and a Content and Application Provider) want to use this signal, they will have to have offline discussions between their business and technical teams to establish a common way of interpreting this signal. \n\nThis inherently will create barriers to entry for small app startups to use TRONE because typically small startups do not have the luxury of hiring a large partnership and technology ecosystems team to interface with multiple CSPs around the world to figure out how to interpret the \"single rate signal\" coming from their network.\n\nWe need to ask ourselves, do we want IETF to design a protocol that is only usable by large companies with plenty of resources?",
      "createdAt": "2025-03-20T02:49:44Z",
      "updatedAt": "2025-07-07T23:46:59Z",
      "closedAt": "2025-07-07T23:46:58Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is a lot of value in simplicity. A single rate signal and guidance in the document around how to interpret the signal makes it easy to reason about. \nDifferent CSPs might measure conformance in different ways, but the associated action to detection of non-conforming traffic would likely be that policing is re-introduced for a flow, or that a lower rate is signaled. Both these actions can be detected and acted upon by the endpoints. ",
          "createdAt": "2025-03-20T10:44:23Z",
          "updatedAt": "2025-03-20T10:44:23Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @ihlar here.  The draft is presently a little loose, but changes like #37 will tighten up the semantics enough to ensure that there should be no need for per-network logic or anything like that.  The rate can be taken at face value by endpoints and networks can set the value with an expectation that endpoints will act more or less consistently to keep within that advice (for those that support the protocol, of course).\n\nAs Marcus observes, the extent to which a network operator sticks to their advertised limit in terms of engaging some form of policing of published rates will vary.  Some will allow some flexibility beyond the limit, others might have more or less allowance for excess.  Some will use a longer period for enforcement, others will not (you can't realistically use a shorter enforcement window).  But ultimately, those are all choices outside of the throughput advice.  My expectation is that some networks will advertise rates that exceed their available capacity, relying on congestion control to manage contention; others might seek to provide advice that is closer to what they can guarantee delivery of, at least to some degree.\n\nAgain, all of this is permissible within what the protocol allows, but none of it requires special dispensation or treatment.  The ability to signal throughput advice remains as a useful guide for both endpoints and networks.\n\nThat this is standardized is exactly why this does become available to small networks or small application developers.  The fact that it is simple also contributes to that, it doesn't require a whole lot of engineering to use: you just set the policy and that determines the advice; or you follow the advice.\n\n(Closing this on the basis of these.)",
          "createdAt": "2025-07-07T23:46:59Z",
          "updatedAt": "2025-07-07T23:46:59Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDON1dwo86u5K3z",
      "title": "Client-initiated signal",
      "url": "https://github.com/ietf-wg-scone/scone/issues/5",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 of the draft shows \"QUIC Sender\", ie, the server initiates the TRONE signal toward the client. This implies that TRONE signal is going to be server initiated. This will result in having the \"network element\" listens to all IP flows in the downlink direction. This is CPU intensive\n2. The authors should consider a design that is independent of SNI-based flow detection\n3. The authors should reconsider this design and allow for CLIENT initiated TRONE signaling (uplink direction) with implicit support for  flow detection\n\nAs a point of reference, section 6 of draft mishra-scone-usercase-00, added following requirement:\nSCONE (aka TRONE) signal MUST be a client-application endpoint initiated to assist the network element (UPF/5G or PGW/4G) with the implicit flow detection\nplease see https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.1.1",
      "createdAt": "2025-03-20T06:13:47Z",
      "updatedAt": "2025-07-23T08:49:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TRONE packets are sent by each endpoint individually, so there is opportunity for the client to send an early TRONE packet such that a network element that keeps some flow state can use the presence of a TRONE packet as an indication to not do further DPI and SNI parsing etc. \nThe problem in the current draft version is that endpoints need to indicate support using transport parameters before  sending TRONE packets. The authors have discussed an approach where an opportunistic TRONE \"indication\" can be appended to a QUIC initial packet. The network element can use this information as an indication that the client is willing to receive rate signals. \nAs opposed to \"regular\" TRONE packets, this indication would have to be appended to the end of a QUIC Initial packet.",
          "createdAt": "2025-03-20T06:43:56Z",
          "updatedAt": "2025-03-20T06:45:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have a lot of good discussion going on in #23, but maybe an issue is better to explain how people view the problem. So here are my thoughts:\n\nAs I understand, there are two types of flows with different characteristics:\n\n1. flows rate-limited using CC\n2. flows for which short bursts are allowed, with the assumption that the long-term bitrate is below the policy\n\nBecause SCONE signals are purely advisory that endpoints often cannot adhere to (see #29), network elements have to monitor the long-term bitrate of type 2 connections, and if they are exceeding the limit, demote them to type 1. This would be the ordinary business for any SCONE-compatible network elements with the capability to enforce bitrates.\n\nIf network elements want to demote flows without paying the cost of monitoring the long-term bitrate, they can consult the QUIC Version field of the first few packets sent by the server. As stated, there will be false positives; hence this is an optimization.\n\nThe question regarding client-driven indication is, IMO, if we want to have another knob for optimization, providing the capability to demote flows just by looking at the first packet from the client. Note we would have even more false positives than the first knob, because clients might be sending Indications to servers that do not support SCONE.\n\nWhile I\u2019m not necessarily opposed to having Indications, I am still wondering why some think it is insufficient to only have the first optimization knob (i.e., see if the server sends SCONE packets early).\n\nThe heavyweight task that the network elements cannot avoid is actually measuring the long-term flow rate and demoting the connections. Compared to that the benefit for having the 2nd knob (Indications) seems marginal if any, even though it makes things much more complex.",
          "createdAt": "2025-05-01T06:30:03Z",
          "updatedAt": "2025-05-01T06:30:03Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "Hi @kazuho \n\nThanks for your thoughts on this. Following up on the discussion, here's my perspective:\n\nFrom a network element standpoint that uses deep packet inspection (DPI) for rate limiting, the process involves identifying potential video sessions and then applying rate limits based on the subscriber's data plan (e.g., 2 Mbps, 4 Mbps). This results in traffic being passed to the radio network at the specified bit rate, and any excess traffic arriving at a faster rate is discarded.\n\nConsidering this within the SCONE working group, it seems beneficial if a client application on the user equipment (UE) initiating adaptive bitrate (ABR) video playback could signal to the rate-limiting network element: \"I can send packets at a rate you can handle, so you don't need to drop them.\" This uplink indication would provide the network element with information to consider.\n\nUpon receiving such a signal, the network element might forgo DPI and potentially wait for a corresponding signal on the downlink for the same 4-tuple (within a reasonable timeout period) before applying the allowable rate limit. While inspecting downlink traffic can be resource-intensive, minimizing this inspection could be a desirable optimization.\n\nConversely, without this client-side notification, a network element relying on DPI will likely start enforcing rate limits immediately at the beginning of a video session, as it has no initial way of knowing if the client application is SCONE-capable.\n\nFor SCONE deployment, this early signaling mechanism distinguishes SCONE flows from non-SCONE flows. It's also important to note that SCONE usage is separate from the congestion control mechanisms within the mobile packet core and the RAN, and therefore outside the scope of our SCONE discussions.\n\nThanks,\nSanjay",
          "createdAt": "2025-05-02T16:49:03Z",
          "updatedAt": "2025-05-02T16:49:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> From a network element standpoint that uses deep packet inspection (DPI) for rate limiting, the process involves identifying potential video sessions and then applying rate limits based on the subscriber's data plan (e.g., 2 Mbps, 4 Mbps). This results in traffic being passed to the radio network at the specified bit rate, and any excess traffic arriving at a faster rate is discarded.\n\nObviously, if your condition is that you do DPI, then you do DPI.  But if your goal is to ensure that video does not exceed a given limit, is DPI really necessary?\n\nMy understanding is that the main concern is high network consumption over long periods of time, something that video is uniquely \"good\" at.  Right now, you use DPI to ensure that you do not limit non-video flows.  But in a world where you have the potential for SCONE to be used on those flows that you are interested in, isn't there a different approach?\n\nAt the start of a flow, you do not limit it, but set a timer.  If that timer pops without seeing SCONE, you switch the rate limit on with a relatively small window.  However, if you see a SCONE signal before then, you switch the timer on with a looser timer.  The rate limit would be the same in both cases, but the SCONE flow would have a deeper token bucket, so would be able to perform better.  There's no DPI involved.  The cost being that video flows will potentially observe huge throughput for the path and might get overenthusiastic in their choice of quality, which can degrade the overall experience.\n\nNow, with an indication, you are in much the same situation.  A signal might cause the DPI to be skipped, but then you still have two eventual end states: one where the signal never manifests and one where you see a SCONE signal.  I can't imagine that the outcome is any different.\n\nI say that because when you say:\n\n> Upon receiving such a signal, the network element might forgo DPI and potentially wait for a corresponding signal on the downlink for the same 4-tuple (within a reasonable timeout period) before applying the allowable rate limit. \n\nThat implies that you are exposing yourself to flows opting out of DPI.  And you can't go back in time and do DPI for that flow if you do that.  So if the signal never arrives -- something that seems likely -- you have lost the opportunity to \"classify\" the flow according to your DPI-based logic.\n\nFor me, the only thing that is potentially relevant here is this transitionary period where only some clients and servers support SCONE.  There, having an indication might be useful, but I don't see the game theory of this working out.  I can't see a network that currently uses DPI for classification giving that up; so unless you want to promise that on behalf of your employer and find other network operators willing to make similar commitments, this all seems pretty speculative to me.",
          "createdAt": "2025-05-05T00:38:10Z",
          "updatedAt": "2025-05-05T00:38:10Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For me, the only thing that is potentially relevant here is this transitionary period where only some clients and servers support SCONE. There, having an indication might be useful, but I don't see the game theory of this working out. I can't see a network that currently uses DPI for classification giving that up; so unless you want to promise that on behalf of your employer and find other network operators willing to make similar commitments, this all seems pretty speculative to me.\n\nI am not in a position to make any promises or name individual companies for that matter. But what I can say is that, in several conversations with CSPs, the potential for reducing the load caused by DPI in the user plane functions is one of the most attractive aspects of SCONE-like solutions. Initially, they would not disable DPI; rather, they would introduce SCONE into their DPI signatures. Packet filters matching \"_the SCONE application_\" would have higher priority than the more complex ones targeting individual applications based on SNI and similar. \nThis approach allows a gradual shift to SCONE-like policies (longer enforcement windows) for traffic that adopts SCONE early, while retaining existing throttling policies (shorter enforcement windows) for other traffic.\n\nThis, of course, only matters if you're not using your DPI for other purposes as well. However, there aren't many use cases beyond this type of policy enforcement where DPI must run in real-time on all flows (unless you're in the business of censorship or similar). Often, DPI is used primarily for collecting statistics or business intelligence; in these scenarios, performing DPI on a statistically significant subset of flows is possibly sufficient.\n\n> At the start of a flow, you do not limit it, but set a timer. If that timer pops without seeing SCONE, you switch the rate limit on with a relatively small window. However, if you see a SCONE signal before then, you switch the timer on with a looser timer. The rate limit would be the same in both cases, but the SCONE flow would have a deeper token bucket, so would be able to perform better. There's no DPI involved. The cost being that video flows will potentially observe huge throughput for the path and might get overenthusiastic in their choice of quality, which can degrade the overall experience.\n\nI would hope that we end up with something like this. \nMy worry is that the leap from the current situation to something like this approach, without an intermediate step, will be too significant for many CSPs, since it involves rethinking policy enforcement to some extent, which is more than a technical problem. The options would then be to either keep relying on DPI for classification, which reduces the incentive to deploy SCONE, or to apply some phased approach e.g., as described above, and gradually assess the benefits.\n\nAllowing for, _optional_, early SCONE indications is a way to help adoption of the technology, and is imo a small price to pay in terms of both protocol and specification complexity.\n",
          "createdAt": "2025-05-05T18:22:15Z",
          "updatedAt": "2025-05-05T18:22:15Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Color me just as skeptical as Martin. Implementations will send SCONE packets if they expect to get an advantage. We have to first explain what that advantage is. \"Getting rid of DPI\" is an advantage for the network. Application developers are not going to care much about that -- if they want to get rid of DPI, they will simply use ECH to scramble the data in the \"initial\" packets of a QUIC connection, hiding the data that DPI could find today.\n\nAnd sure, this is an arms race. If application developers better encrypt the data, the middle boxes will probably deploy some fingerprinting technique based on size and timing of the encrypted packets. This will probably succeed in identifying flows, but it requires observing enough packets to find the pattern. If the decision can wait that long, networks could just as well apply the \"delayed decision\" strategy that Martin is describing.\n\n\n",
          "createdAt": "2025-05-06T04:43:25Z",
          "updatedAt": "2025-05-06T04:46:00Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Color me just as skeptical as Martin. Implementations will send SCONE packets if they expect to get an advantage. We have to first explain what that advantage is. \"Getting rid of DPI\" is an advantage for the network. Application developers are not going to care much about that -- if they want to get rid of DPI, they will simply use ECH to scramble the data in the \"initial\" packets of a QUIC connection, hiding the data that DPI could find today.\n\n@huitema Application developers are not the only ones needed to enable SCONE adoption. There has to be an incentive for the network as well. SCONE, especially with an early indication, is one way we realistically see a way to avoid some of this \"arms race\" you describe.\n\nYou may be skeptical but we have CSPs and those that vendor equipment to CSPs saying that this would meaningfully help with SCONE deployment. What more would it take to make you _not_ skeptical?",
          "createdAt": "2025-05-06T15:59:53Z",
          "updatedAt": "2025-05-06T16:00:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You may be skeptical but we have CSPs and those that vendor equipment to CSPs saying that this would meaningfully help with SCONE deployment. What more would it take to make you _not_ skeptical?\n\nI don't like to deal in cliches, but you want a \"win win\" strategy. There has to be something gained by the application, otherwise it will just not bother. Plausible gains:\n\n1) Allow application to implement some long term tuning to network capacity (by opposition to just follow short term congestion feedback). This should result in lower latency because the application could forgo \"capacity probing\" strategies that build queues, and possibly lower power consumption (don't bother firing up a hi-def codec if you know that will not work).\n\n2) Make the traffic more \"regular\" -- the natural consequence of application tuning. The shorter queues in the network improve its overall efficiency, which should be visible in measurement of latency and packet loss.\n\nNone of that actually requires \"policing per flow\" or special-casing flows that use SCONE. Networks will still need to implement forms of active queue management at the edges, and should really work to implement ECN for real time feedback. It is just that flows that actually keep within the envelope advertised by SCONE will experience many fewer congestion events, ECN/CE marks, or AQM induced latency.\n",
          "createdAt": "2025-05-06T16:26:13Z",
          "updatedAt": "2025-05-06T16:26:13Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't like to deal in cliches, but you want a \"win win\" strategy. There has to be something gained by the application, otherwise it will just not bother. \n\n@huitema as someone from an application perspective, I think you are somewhat over-complicating the win-win. There is quite a simple win-win that would happen _today_ in many networks if we had SCONE. These are networks where:\n\n1. DPI is utilized per-flow to identify our application as video (even when it's not) and aggressively police it for a variety of reasons and in a variety of situations.\n2. The policing is heavy handed and quite difficult to deal with both from an application and transport layer perspective.\n3. Deploying ECH is not viable since ultimately \"networks are going to do what networks are going to do\" and the obvious thing to do is to be even more heavy handed since the \"arms race\" is extremely slow for them.\n\nIf we could wave a magic wand and have SCONE + the indication, there are networks where they _would absolutely_:\n1. Utilize SCONE to signal their advice.\n2. Disable 100% DPI for those flows since it has a significant cost for flow setup.\n3. Disable policing as long as the aggregate behavior of an application matches the signaled advice.\n4. Free us to deploy ECH on these flows.\n\n3 In particular would also give them a competitive edge over their peers who still rely on the policing, giving an urgency for other CSPs to adopt the same practices.\n\nWe could achieve this by having SCONE + an indication and setting it on all flows. I don't know what else to say to assure you this isn't hypothetical. It's a win for applications and for the operators. Frankly the one I am least convinced by having a big \"win\" in this situation is a vendor but at the end of the day if their customers are asking for it, they will provide it.",
          "createdAt": "2025-05-06T16:39:06Z",
          "updatedAt": "2025-05-06T16:39:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I\u2019m reading correctly, the argument for client\u2011driven Indications is to give CSPs a way to lighten their DPI burden. @ihlar\u2019s comment nicely summarizes those benefits.\n\nBut aren't there risks as well?\n\nSpecifically, I have one question: what will prevent CSPs from simply mapping these new signals onto their existing DPI\u2011based video policy? Today, any flow marked as \u201cvideo\u201d typically receives a far lower throughput allowance than generic traffic\u2014even when it\u2019s bursty. If providers treat client-driven SCONE Indications as just another way to label traffic \u201cvideo,\u201d endpoints will effectively be barred from sending any non\u2011video data over SCONE.\n\nAs we discuss in #29, that outcome would sabotage browser adoption\u2014browsers can\u2019t predict in advance how a connection will be used, so they can\u2019t safely opt in to SCONE if it means risking severe throttling. In the end, the only services that could realistically benefit from deploying SCONE would be those already classified as video. For everyone else, the incentive could turn out to be to avoid SCONE entirely, since advertising it would trigger the very low\u2011throughput \u201cvideo\u201d treatment.\n\nOf course, CSPs remain free to throttle as they see fit\u2014but there\u2019s a world of difference between \u201cthey can throttle\u201d and \u201cwe\u2019re giving them a mechanism to reclassify potentially non\u2011video traffic as video just to throttle it.\u201d\n\nHow do we prevent that second scenario? What mechanism ensures CSPs can\u2019t just recycle their existing video\u2011throttling rules against SCONE\u2011enabled traffic?",
          "createdAt": "2025-05-08T03:21:01Z",
          "updatedAt": "2025-05-08T03:21:01Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You make a very good point @kazuho.\nI think the response to this is that sending early indications should be optional and that endpoints such as browsers should be recommended to not use them. Or at least there should be sufficient guidance around both the risks and benefits of using early indications. For native video applications the benefits are significant, as discussed above. \n\n",
          "createdAt": "2025-05-08T08:49:08Z",
          "updatedAt": "2025-05-08T08:49:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I wonder if we're trying to do two things with one mechanism and it might make sense to split them a bit?\n\nFor example, If we don't want people doing DPI, we can put the SNI in cleartext in a hypothetical MUFFIN packet in the same UDP packet as the ClientHello. To be clear, I am not at all sure this is a good idea, but at least there's no DPI and it aligns with my general principle of \"If I wanted the network to know something, I'd tell it explicitly.\"\n\nI'd also be fine having a packet type that says \"Put the reverse path bandwidth in this\" that we can send in the first flight if we're doing 0-RTT and with the ClientFinished if we're not.  That would prevent it ever being sent in cases it hadn't been negotiated.\n\nFor throttling, I think the implementation is fairly easy: Keep doing what you're doing until you see a SCONE packet.  My understanding is that most networks have some initial token-bucket model to ensure web pages load quickly, so they might let the first 100 packets through unthrottled even today.\n\nAs a person who writes congestion controllers and runs QUIC on servers, having the receiver and not the sender receive this signal is potentially problematic. It's fine for apps, but are we going to expose this value to browser clients so they can do ABR or communicate it to the server so it can do ABR?\n\nPaths are commonly not symmetric, so I can appreciate the benefits of sending the SCONE packet in the relevant data path, but I do really want to have this information sender-side.",
          "createdAt": "2025-05-08T13:16:18Z",
          "updatedAt": "2025-05-08T13:16:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ihlar \n> I think the response to this is that sending early indications should be optional and that endpoints such as browsers should be recommended to not use them. Or at least there should be sufficient guidance around both the risks and benefits of using early indications. For native video applications the benefits are significant, as discussed above.\n\nI\u2019m not sure client\u2011driven Indications will even help native video apps. If you\u2019re already rate\u2011limited, you\u2019ve got nothing to lose by signaling early. But if you\u2019re not rate\u2011limited today, you have every incentive to avoid SCONE\u2014being tagged \u201cvideo\u201d means worse throughput and user experience.\n\nPut another way, the real danger is that only the apps CSPs already classify as video will adopt SCONE (since their performance can\u2019t get any worse), while everyone else steers clear. CSPs could then simply continue throttling based on those Indications, just as they do with DPI today.\n\nThat outcome would be a defeat: we\u2019d have built a mechanism that helps CSPs maintain\u2014or even strengthen\u2014their rate\u2011limiting, by providing an explicit signal, precisely the opposite of what this WG is chartered to achieve.",
          "createdAt": "2025-05-08T15:44:28Z",
          "updatedAt": "2025-05-08T15:44:28Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I don't understand how any of this changes significantly with or without the indication. Without the indication, the exact same thing would happen, just later in the connection when an endpoint sends an actual SCONE packet. Indications change nothing about what information is visible to a network element, so how do they change the decision calculus? In fact, without ECH the _exact same information_ is available at the same time (the client's ability to receive SCONE packets), by parsing the CH and looking for the SCONE transport parameter. It's just relatively costly to do so but since the existing practice requires decrypting the Initial packet anyway, it's perfectly viable to do.\n\nAn endpoint cannot control what the network does or does not decide based on SCONE or an indication or (as is common today) the contents of SNI or IP addresses. It is a similar problem to ECH, where taking away information can lead to the outcome of degrading _all_ traffic.\n\nWe are falling into the trap of re-litigating the utility and benefit of SCONE in general, rather than focusing on the indication itself. Having an indication or not does not change the information available to a network element about a flow, it is a detail that changes how accessible and when it is accessible. Clients are free to utilize or not utilize SCONE as they please, and network elements are free to utilize it or not utilize it. The exact same would be true for an indication.",
          "createdAt": "2025-05-08T16:13:20Z",
          "updatedAt": "2025-05-08T16:13:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mjoras \u201cSignificance\u201d is a subjective word.\n\nLet me explain how I understand the incentives of different types of network elements, how they might use Indications, and what outcomes may result.\n\nConsider three types of network elements capable of applying different policies to flows:\n\n* A. Elements that inspect the first packet from the client and enforce different bitrates using congestion control (CC).\n* B. Elements that can observe the throughput of a small number of SCONE flows and apply CC based on long-term flow rates.\n* C. Elements that can observe the throughput of all SCONE flows and apply CC based on long-term flow rates.\n\nFor type A elements, Indications could become a new tool to identify the type of flow and apply CC accordingly. This behavior wouldn\u2019t negatively affect flows already throttled by SNI inspection. However, it would hinder SCONE adoption among applications that currently aren't throttled\u2014being (mis)classified as video flows would lead to lower throughput.\n\nFor type B elements, Indications might be beneficial during SCONE\u2019s early adoption phase. These elements can distinguish between potentially SCONE flows and definitely non-SCONE flows just by inspecting the first client packet. They could treat the small number of SCONE flows differently while continuing to apply DPI + CC-based throttling to the non-SCONE majority.\n\nBut as SCONE adoption grows and the number of SCONE flows approaches or exceeds the capacity of these network elements, what happens then? As far as I can tell, their only practical option is to revert to applying CC-based throttling to SCONE flows. That\u2019s the only viable path forward.\n\nFor such elements, it's possible they would behave similarly even without Indications. While inspecting the first packet is easier, they can still analyze later packets if needed.\n\nHowever, the key point is this: network elements that behave in this manner\u2014like type A\u2014would deter SCONE adoption at the endpoint, or cause users to disable SCONE, because using SCONE would result in degraded performance.\n\nFor type C elements, Indications are unnecessary. These elements can assume all flows are SCONE by default and only apply CC-based throttling if no SCONE packets are observed for a certain duration, or if long-term throughput exceeds a threshold.\n\nIn summary:\n* Indications are likely to be misused by type A elements, leading to reduced SCONE adoption.\n* Indications might help type B elements early on, but as SCONE scales, such elements may become harmful.\n* Indications are meaningless for type C elements.\n\nPeople may have different visions for SCONE, but in my view, the best-case scenario is:\n* most, if not all, internet traffic becomes SCONE;\n* network elements can recommend appropriate video bitrates to *any* flow, rather than relying on a static list of SNIs (win for network operators);\n* and bursts are allowed, enabling non-video data to transfer quickly\u2014regardless of whether the flow is application-specific or mixed (win for applications).\n\nFrom this perspective, misuse by type A elements is purely detrimental. Moreover, type A elements are the most commonly deployed today. If they begin applying CC-based limiting based on Indications, there would be little incentive for new applications to adopt SCONE. This, in turn, would remove any reason for future network elements to properly support SCONE, stalling its adoption altogether.\n\nType B elements are landmines best avoided, and we should refrain from providing incentives that would facilitate their development.",
          "createdAt": "2025-05-13T05:20:51Z",
          "updatedAt": "2025-05-13T05:46:37Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@kazuho \nScope of SCONE (if I understand it correctly) is for the UE to signal to the mobile network that it can \"self-regulate its bit rate\" provided the mobile network tells it, \"what the 'self regulate bit-rate' can be\". This is completely outside of the scope of how mobile networks manage congestion in the network (mobile packet core, the radio network and the access network). SCONE is meant for adaptive bit-rate applications such as video.\n\nSCONE signal, if adopted by content publishers + mobile operators, would only apply to QUIC flows, so even if SCONE adoption grows, in its current charter, excludes apps that do not use QUIC, for example, TCP/IP flows.\n\nLastly, mobile networks do not regulate non-video flows, so any non-video application does not gain any advantage (or disadvantage) for wanting to use SCONE signal. \n\n",
          "createdAt": "2025-05-18T02:32:35Z",
          "updatedAt": "2025-05-18T02:37:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@smishra1200 \n> Scope of SCONE (if I understand it correctly) is for the UE to signal to the mobile network that it can \"self-regulate its bit rate\"\n\nI\u2019m not sure. As the draft is currently written, [Section 3.5](https://ietf-wg-scone.github.io/scone/draft-thoji-scone-protocol.html#name-advisory-signal) notes that \u201cthe fact that an endpoint requests bitrate signals does not necessarily mean that it will adhere to them; in some cases, the endpoint cannot\u201d (see also issue #29).  In other words, SCONE does **not** promise self-regulation; it merely conveys rate-limit advice.\n\nMoreover, even if SCONE packets *did* reliably indicate self-regulation, an **Indication** in the client's very first packet cannot be trusted to mean the same thing: few clients have out-of-band knowledge that the server supports SCONE.\n\nHence an Indication is, at best, a weak hint, with, by looking so similar to SNI, carrying the risk of being misused as a replacement for congestion-control-based throttling via existing mechanisms.\n\n> SCONE signal \u2026 would only apply to QUIC flows \u2026\n\nThat is correct. Sorry if I have confused you by stating \u201call internet traffic becomes SCONE\u201d; of course I meant \u201call internet traffic using QUIC.\u201d With that clarification, the concerns above about reliability and potential misuse remain unchanged.",
          "createdAt": "2025-05-19T00:57:31Z",
          "updatedAt": "2025-05-19T01:05:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho. SCONE is defined as a way for the network to provide information to the host -- not the other way around. It only provide limited information about the host, i.e., that the host is capable to format and parse the SCONE packets.\n\nTake the example of a network that really want to provide a different service to a subset of the connections. It will probably determine some kind of pacing rate based on the information in the UDP header, possibly augmented by inspection of the\ninitial packet. The network element could document that rate in the SCONE packets, so the application can be parameterized accordingly.\n\nBut that DPI-and-pacing network is just an example. A home router may simply document the maximum data rate of the local connection, without any kind of DPI or per-connection state.\n\nIf SCONE is successful, yes, pretty much every QUIC connection will be using it, because they find the information provided by the network useful. That's the definition of success.",
          "createdAt": "2025-05-19T04:39:06Z",
          "updatedAt": "2025-05-19T04:39:06Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@kazuho, agree on [section 3.5](url) you point to above, my main point is,  _intent_ of SCONE is to not have the NE [capable of rate-limiting adaptive bit-rate video applications] throttle ABR video-traffic. Instead, send an advisory throughput signal to the endpoints video application. The expectation is that this change can result in  better \"end-user\" experience and reduce packet retransmission. Of course, if the endpoint chooses to not use the throughput advisory signal then SCONE wont be applied to that QUIC 4-tuple. \n\nSo, the question is, does any indication to the NE here helpful? Does the indicator tells NE that there is a willing app interested in self regulating traffic and therefore look to send throughput advisory signal on both direction of end-points on the first opportunity.\n\n",
          "createdAt": "2025-05-19T23:58:14Z",
          "updatedAt": "2025-05-19T23:58:14Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@huitema \nI'm trying to understand the incentive for networks to adopt SCONE. You mentioned that SCONE is designed for the network to provide information to the host, offering limited information about the host's capability to handle SCONE packets.\n\nGiven that networks already rate-limit ABR video applications without using SCONE, what would be the key reason for these networks to prefer SCONE as their tool of choice in the future? What specific advantages does SCONE offer to the networks to make the switch in this context?\n\n\n",
          "createdAt": "2025-05-20T02:28:49Z",
          "updatedAt": "2025-05-20T02:28:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@smishra1200 \n> So, the question is, does any indication to the NE here helpful?\n\nMy view is that the answer is no, assuming we measure success using the criteria stated concisely by @huitema, with which I fully agree. In a world where pretty much all QUIC connections use SCONE, there is little benefit\u2014if any\u2014in identifying at an early moment the few connections that do not.\n\n> Does the indicator tells NE that there is a willing app interested in self regulating traffic ...\n\nSCONE, as currently drafted, does not provide such a signal. Privacy concerns aside, the practical problem is that endpoints often do not know how a connection will be used at establishment time. Video-only clients talking to a dedicated server might be able to assert that, but they represent only a fraction of all Internet traffic.\n\n> Given that networks already rate-limit ABR video applications without using SCONE, what would be the key reason for these networks to prefer SCONE as their tool of choice in the future? What specific advantages does SCONE offer to the networks to make the switch in this context?\n\nFor networks, the issues with the status quo is that they do not have the capability to rate-limit *all* long-term traffic, and that CC-based rate-limiting is sub-optimal.\n\nStatus quo = lose-lose:\n\n* Networks: can rate-limit only the flows they identify as video (via DPI). Radio-resource usage is sub-optimal because data cannot be sent in bursts.  \n* Endpoints: CC-based throttling worsens user experience, and misclassification of non-video flows as video remains a persistent problem.\n\nSCONE = win-win:\n\n* Networks: can expect endpoints to self-regulate every long-term flow. Unlike DPI, SCONE still works when endpoints adopt ECH. Radio-resource usage becomes more efficient because long-term flows that follow throughput advice can transmit in bursts.  \n* Endpoints: see better user experience thanks to fewer packet losses.",
          "createdAt": "2025-05-20T04:30:29Z",
          "updatedAt": "2025-05-20T04:30:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho.  \n\nThere's also a leap of faith involved. Networks might be trusting clients more when they disengage or loosen policers and shapers in favour of SCONE.  Similarly, clients are trusting networks more when they engage rate limits in applications, rather than pushing usage up to the limits the network tolerates.  If neither is willing to extend that trust, then this whole thing fails.  But we're seeing that it can deliver that win-win outcome, so it's worth a shot.",
          "createdAt": "2025-05-20T04:37:27Z",
          "updatedAt": "2025-05-20T04:37:27Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I am trying to understand your different classification of network elements. The network elements that exist today which are relevant to the indication discussion basically do the following:\n\n1. Observe all new flows through them, with state being created per flow as they are initiated from the client direction.\n2. They try to classify these flows. They do this by applying what we are calling \"DPI\" but more concretely is being able to parse the entire packet.\n3. The classification as ABR video is often done by trying to find the SNI of known ABR video hostnames.\n4. If they classify as ABR video they apply what we're calling \"CC throttling\" or similar in this thread, by applying a token bucket queueing that either buffers or drops packets or some combination thereof.\n\nThe indication basically exists to make obviate the need for doing 2-4 while we work to make SCONE ubiquitous. This is the \"trust\" on the part of the network, and in exchange they get improved video performance for the humans and lower cost for the network elements per flow.\n\nHow exactly that \"trust but verify\" plays out will probably vary (is it active and online or is it aggregates and offline, etc.). But that's not what the indication is trying to solve. \n\nI honestly think we are spending far too much time on hypotheticals here when the systems we are trying to change are extant. We are also getting side tracked debating the \"philosophy of SCONE\" which is largely irrelevant to whether we spend time trying to develop a reasonable indication optimization for the scenario described above. ",
          "createdAt": "2025-05-20T05:04:15Z",
          "updatedAt": "2025-05-20T05:05:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mjoras\n> I am trying to understand your different classification of network elements\u2026.\n\nLet\u2019s focus on one type of network element for the moment.\n\n> The indication basically exists to make obviate the need for doing 2-4 while we work to make SCONE ubiquitous.\n\nI think the word \u201cwhile\u201d might be the crux of the problem.\n\nIf I understand correctly, the premise behind Indication is that\u2014during the initial deployment phase\u2014operators might want to deploy network elements that can handle only a limited number of SCONE-enabled QUIC flows. If they could handle QUIC flows all with SCONE attached, there would be no need for Indications at all.\n\nBut what would these network elements start doing once SCONE does become ubiquitous?  \n\nThe most pragmatic option for them will be to keep classifying flows by the presence of Indication _and apply CC-based throttling_, as they do not have the capacity to handle 100% SCONE flows.\n\nIn other words, the network elements meant to smooth the path for early deployment would end up backfiring once SCONE is widespread, turning Indication into nothing more than another \u201cthrottle flag.\u201d\n\nI don\u2019t think we should encourage deployment of network elements that would undermine SCONE\u2019s objectives the moment the protocol becomes a success.\n\nInstead, we should focus on encouraging the development of network elements that can handle 100% SCONE flows.",
          "createdAt": "2025-05-20T09:07:20Z",
          "updatedAt": "2025-05-20T09:07:20Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If they could handle QUIC flows all with SCONE attached, there would be no need for Indications at all.\n\nThis depends. An indication can be interpreted as an endpoint opting in to the strictest possible ceiling. Flows that do not include the indication might still benefit form SCONE signals, even if the communicated ceiling is less strict.\n\n> Instead, we should focus on encouraging the development of network elements that can handle 100% SCONE flows.\n\nThese network elements can work with 100% SCONE flows. As an example, a 5G UPF can apply multiple sets of policies at different scopes:\n\n-  Flow- or application-based policies that apply to packets that match some packet filter (e.g., through the use of DPI).\n-  Session-based policies that govern the session Aggregate Maximum Bitrate (AMBR) for a subscriber session.\n\nOften, the flow/application-based policy is more strict than the session AMBR. A flow that opts in to the strictest ceiling using an indication will get the lowest of the two policies. Flows that do not explicitly opt-in to the strictest ceiling will get the AMBR value. \n\nIt would be great if a fully SCONE capable world changes policy enforcement such that there is no need for differentiation on application type or use of indications (and I do understand that the indication and its meaning as a policy toggle is not pretty). But I think there is a long way to get that world, and if we design a solution for an idealized world we run the risk of getting little to no deployment at all. \n\nTherefore, given the current reality, a _strictly optional_ indication with clear guidance text that endpoints SHOULD only send it for flows they control (e.g., don't use this if you're a browser) and that networks MUST NOT penalize its absence, seems to me as a pragmatic way to increase SCONE deployment incentives.\n\nAnd fwiw I'd be totally ok to define an optional MUFFIN packet as @ianswett suggests further up in the thread, but perhaps not copying the SNI, but simply being an indication of opt-in to the strictest ceiling regardless if it's enforced by SCONE or CC-based throttling.",
          "createdAt": "2025-05-21T17:24:59Z",
          "updatedAt": "2025-05-21T17:24:59Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "It is very hard to understand where we are at this issue? Do we have a decision here?\n\n@smishra1200, as a network operator do you plan to give the throughput advice to any QUIC connection that goes through you UPF/NE? Or this is really based on subscriber policy meaning different subscriber get different advice or does not get anything at all?\n",
          "createdAt": "2025-05-23T17:00:52Z",
          "updatedAt": "2025-05-23T17:00:52Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "[@zaheduzzaman](https://github.com/zaheduzzaman)\n\n> It is very hard to understand where we are at this issue? Do we have a decision here?\n> \n> [@smishra1200](https://github.com/smishra1200), as a network operator do you plan to give the throughput advice to any QUIC connection that goes through you UPF/NE? \n\nNo.  Traffic policing is not universally applied across our network. Specifically, video policing is designed for video-playing applications utilizing adaptive bitrate video, and it does not extend to non-video traffic. Responding with a throughput advice to every QUIC connection would be impractical due to a couple of key reasons: first, within the context of SCONE, its application would be limited solely to ABR video; second, it would introduce an unwelcome and unpredictable processing load on the network\n\n> Or this is really based on subscriber policy meaning different subscriber get different advice or does not get anything at all?\n\nDetermining the appropriate video policy for a session does involve assessing both the subscriber's data plan and the radio access technology being used (4G/5G). A Throughput advice for SCONE will need to consider the subscriber's plan and the network they are connected to. For example, subscribers with a premium 5G plan will experience less strict video policing compared to those on other plans within the 5G network and on a 4G network.",
          "createdAt": "2025-05-25T18:11:20Z",
          "updatedAt": "2025-05-25T18:11:20Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assume that we have defined a \"scone capable\" indication and that all connections are using it, whether or not they are sending videos. The connections will then send SCONE packets at interval. Do I understand correctly that:\n\n* if your network has recognized the application as \"doing video\", the SCONE packet will be updated to indicate the target throughput, which will depend on the user's subscription.\n* otherwise, the SCONE packet will not be modified, and the throughput parameter will be left to a default value?",
          "createdAt": "2025-05-25T18:50:03Z",
          "updatedAt": "2025-05-25T18:50:03Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "\n> Assume that we have defined a \"scone capable\" indication and that all connections are using it, whether or not they are sending videos. The connections will then send SCONE packets at interval. Do I understand correctly that:\n> \n> * if your network has recognized the application as \"doing video\", the SCONE packet will be updated to indicate the target throughput, which will depend on the user's subscription.\n> * otherwise, the SCONE packet will not be modified, and the throughput parameter will be left to a default value?\n\nUse of  SNI in combination with subscriber policy and RAT type guides the ABR video optimization. If the \"scone capable\" indication is applied only to ABR-video QUIC connections, the SCONE protocol would not only eliminate the need for SNI in flow detection but also provide a stronger rationale for its deployment.\n\nHowever, applying the \"scone capable\" indication to all QUIC connections would mean our network would need to inspect every QUIC connection, regardless of whether it's a video flow. We would still need to rely on SNI to determine if a specific QUIC connection is a video flow to decide whether to populate the throughput parameter in the SCONE packet.\n\nIf my understanding is correct, it seems that implementing SCONE in this way would add to CPU processing, and the benefit compared to our current process is unclear to me. Additionally, SCONE's applicability is limited to QUIC, and TCP connections will still exist.\n\nCould you please clarify if my understanding is correct?",
          "createdAt": "2025-05-26T00:14:33Z",
          "updatedAt": "2025-05-26T01:30:30Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Trying to summarize the issue, based on the discussion here and in the recent interim meeting.\nThere is broad agreement that giving networks an incentive to deploy SCONE is valuable. Early indications have been proposed as one such incentive, because they could reduce DPI load while SCONE adoption ramps up.\n\nThe main disagreement is what an indication should imply.\n* Some want a flag that means \"this flow is ABR video,\" so they can skip DPI and save CPU.\n* Others worry that a dedicated \"video flag\" becomes a new fingerprint and might be used as a trigger for immediate short-term policing instead of the intended long-term throughput monitoring.\n\nA suggested compromise is to allow indications but encourage all flows, video and non-video, to set them. That reduces the fingerprinting concern and makes the bit less attractive as a throttle toggle. It does, however, leave operators with a choice:\n* Replace video-specific policies with generic \u201cSCONE policies\u201d where throughput advice is communicated, and long-term throughput is measured and potentially enforced on all SCONE flows.\nIndications are helpful during the transition when legacy and SCONE rules coexist.\n* Keep DPI to detect video and apply differentiated policies, possibly using SCONE to signal these policies.\nIn this model, indications provide no additional value.\n\n",
          "createdAt": "2025-05-28T22:29:36Z",
          "updatedAt": "2025-05-28T22:29:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We may also mention that \"Keep DPI to detect video and apply differentiated policies\" fails in presence of ECH or migration.",
          "createdAt": "2025-05-29T01:45:10Z",
          "updatedAt": "2025-05-29T01:45:10Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@ihlar, I understand you are only summarizing the conversation and greatly appreciate you doing this. I'd appreciate a bit more clarity on a few points in the summary:\n\n> Replace video-specific policies with generic \u201cSCONE policies\u201d where throughput advice is communicated, and long-term throughput is measured and potentially enforced on all SCONE flows.\n\nCould you please clarify what constitutes a \"SCONE\" flow? Is it defined as \"applications capable of adjusting their bit-rate based on network conditions,\" or is the definition different?\n\n> Indications are helpful during the transition when legacy and SCONE rules coexist.\n\n It would be helpful if these indications were limited to \"SCONE\" flows. For example, a large file download that cannot adjust its bit-rate might not benefit from an indication, and the resulting throughput advice may not be useful since the download might not be subject to rate limits. (or any none ABR content)\n\n> Keep DPI to detect video and apply differentiated policies, possibly using SCONE to signal these policies.\n\nI'm wondering about the value of SCONE over existing methods if it still relies on DPI. If SCONE's functionality is contingent on DPI, similar to the current approach, what would be the future role of SCONE, especially with the emergence of ECH?\n\n",
          "createdAt": "2025-06-03T21:32:48Z",
          "updatedAt": "2025-06-03T21:32:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SCONE is very much not dependent on DPI.  The question at hand is whether networks would change how they condition their actions on DPI.  That is, if they currently rely on DPI for policing/shaping, would SCONE change that?\n\nWe have some answers to that question and the answers are (unsurprisingly) not consistent.",
          "createdAt": "2025-06-04T00:35:58Z",
          "updatedAt": "2025-06-04T00:35:58Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "A mechanism that replaces SNI when used for video flow optimization is a change in the right direction. SCONE can give an alternative to networks over current methods in so far as identifying video flows.  \n",
          "createdAt": "2025-06-04T18:28:26Z",
          "updatedAt": "2025-06-04T18:28:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Policies that shape or police an _entire connection_ based on the presence of ABR video flows on that connection are counterproductive to QoE.  We've found that coalescing video traffic with photos and dynamic requests generally gives us better control of response prioritization and corresponding QoE wins overall, except in networks that throttle, where non-video traffic experiences collateral damage.\n\nWe'd prefer that networks offer SCONE throughput advice (and remove shaping) regardless of the SNI, \"video/non-video\" or any other properties of the traffic.  Tell us what bitrate is sustainable and we will deliver the best possible QoE within that limit.",
          "createdAt": "2025-06-04T18:59:20Z",
          "updatedAt": "2025-06-04T18:59:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Summing up my understanding from the WG meeting in Madrid, where we decided to include a client-side first-packet SCONE signal, we will:\n\n- include a \"client support\" signal in the SCONE protocol, \n- with brief guidance in the protocol document as to when to use it TBD (noting there is explicitly *no* consensus that this is signal is intended to mean \"this is a video biflow\")\n- and place expanded discussion of the applicability of the signal in the A&M document.\n\nShould we expect a new PR for this issue, or modify/reuse #23?",
          "createdAt": "2025-07-23T08:49:04Z",
          "updatedAt": "2025-07-23T08:49:04Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDON1dwo86u5RKN",
      "title": "Network Element initiate TRONE packet for Dynamic update of Throughput advise based on changing RAT or subscription plan",
      "url": "https://github.com/ietf-wg-scone/scone/issues/6",
      "state": "CLOSED",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 states \"A network element detects a TRONE packet by observing that a packet has a QUIC long header and the TRONE protocol version of 0xTBD.\" A network element then conditionally replaces the Rate Signal field with values of its choosing\"\n\nAbove implies that 'network element\" has to wait/rely on server to originate a TRONE packet for the NE to send advisory bit-rate towards the client.\n\nThis may not work well when we consider a use case such as the mobile user may move from one Radio Access Technology to another (4G to 5G or vice-versa) during an ongoing video session. Ideally, the NE should be in a position to send dynamically an  updated Throughput advisory bit-rate on its own without having to wait for server to originate a TRONE packet.\n\nIn another use case, there can be a need for the NE to send an updated Throughput advisory bitrate, if there is any change in consumption of subscribers' data plan.\n\nThere is also a requirement added in mishra-scone-usecase-00 that calls out:\nDynamic update - \"throughput advice\" MAY change during the ongoing flow and UPF/PGW SHOULD be able to send \"throughput advice\" to client-application-endpoint as soon as possible.\n\nPlease refer to https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.5.1\n\n",
      "createdAt": "2025-03-20T06:26:49Z",
      "updatedAt": "2025-07-22T12:59:24Z",
      "closedAt": "2025-07-22T12:59:24Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, we do want the ability to signal rate changes in a timely fashion. \nThere are however, a number of ways to achieve this. \nIf we make it cheap enough to update the rate signal field, we can provide guidance to endpoints to generate TRONE packets at a relatively high frequency. One such advice would be to send a new advice for every new application layer \"burst\" such as the transmission of a set of HLS/DASH video segments. \nFurthermore, it is possible for network elements to insert TRONE packets of its own and expand UDP datagrams. Hopefully this will not be needed, but can be a last resort if the TRONE packet frequency is too low. Special care needs to be taken to not run into Path MTU issues, so guidance around not expanding datagrams to sizes larger than 1200 bytes (smallest maximum datagram payload size that needs to be supported for QUIC v1/v2)  could be needed.",
          "createdAt": "2025-03-20T06:54:52Z",
          "updatedAt": "2025-03-20T06:54:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have a lot more discussion on this issue on #5.  I'm going to mark this as a duplicate of that.",
          "createdAt": "2025-07-22T12:59:17Z",
          "updatedAt": "2025-07-22T12:59:17Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDON1dwo86u5cxB",
      "title": "Client-side explicit ACK for receipt of TRONE packet",
      "url": "https://github.com/ietf-wg-scone/scone/issues/7",
      "state": "CLOSED",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "7.3.  Feedback To Sender About Signals \n\nSuggest that the TRONE draft consider a use case for client to send an explicit ACK to the \"network element\" upon receiving a TRONE packet. Without an explicit ACK, a NE may not know if the client has received the latest Throughput advisory bit-rate. This may help the scenario where a client may not self regulate due to loss of TRONE packet with the most recent Throughput advisory bit-rate.\n\nAdding a requirement that support the ACK from client to the network element. \n\nI-D mishra-scone-usecase-00 listed the following requirement: \n\nClient-application endpoint SHOULD send acknowledgement receipt of throughput advisory signal from the network element using the SCONE (TRONE) signal\n\nhttps://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.3.1",
      "createdAt": "2025-03-20T06:50:46Z",
      "updatedAt": "2025-07-23T08:57:35Z",
      "closedAt": "2025-07-23T08:57:35Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if acknowledging the receipt of a specific TRONE packet adds much value. \nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place. \nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not. ",
          "createdAt": "2025-03-20T09:37:12Z",
          "updatedAt": "2025-03-20T09:37:12Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "Hi Marcus, I'm cross referring a comment posted on my GitHub RE client ACK. Please see below:\n\nhttps://github.com/smishra1200/SCONE-Use-Case/issues/1",
          "createdAt": "2025-04-01T23:21:41Z",
          "updatedAt": "2025-04-01T23:21:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The clients use TRONE because they seek the advice. You have to assume that they will heed that advice, largely because of self interest. Nobody want application data thrown out randomly and causing terrible UI artefacts.\n\nAs @ihlar says, if the network wants to enforce something, it has to implement it using some kind of active queue management. Preferably signalling to the client using ECN/L4S. ",
          "createdAt": "2025-04-09T06:32:15Z",
          "updatedAt": "2025-04-09T06:32:15Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@ihlar \n\n> Not sure if acknowledging the receipt of a specific TRONE packet adds much value.\nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place.\nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not.\nWhat you say is correct but what if the TRONE advisory packet is not received or that there is some time between the receipt of the TRONE signal and the client-app actually stepping down the bit-rate ladder?\n\nAnd as @rjt-ietf noted (below), the ACK offers network to not enforce any throughput limitation when the end-point is in the process of following the advice.\n\n> ...the throughput advice will be average bitrate within a time window, so I think it's necessary to let the CSPs know that the endpoint is following the advice \n\nBTW, for this [requirement](url) in the use case document, we have downshifted it to a \"MAY\" for FWIW",
          "createdAt": "2025-04-15T13:47:21Z",
          "updatedAt": "2025-04-15T13:47:21Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The TRONE model is for the network to provide advice. The design assume that the TRONE packet does not change the state of the network. For example, a network may be already programmed to apply a rate limiter to packets with certain characteristics, or to all packets. The TRONE packets will inform endpoints about those characteristics, so they can make useful decisions such as picking a video codec that remains within those envelopes. For that usage, we do not need acknowledgement: it is the responsibility of the endpoints to repeat packets if they cannot get information.",
          "createdAt": "2025-04-16T15:01:07Z",
          "updatedAt": "2025-04-16T15:01:07Z"
        },
        {
          "author": "rjt-ietf",
          "authorAssociation": "NONE",
          "body": "I'm ok with networks assuming an endpoint will follow the advice if TRONE packets are sent.\nBut I think the TRONE communication **may** change the state of a network.\nA network may have a generic limiter that looks at data at a 3-second window. But with TRONE, it should switch to a SCONE limiter that looks at the data window specified by SCONE, for example, 20 seconds.",
          "createdAt": "2025-04-16T15:08:09Z",
          "updatedAt": "2025-04-16T15:08:09Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "This doesn't seem necessary to me, unless the expectation is that packet loss is very high and the TRONE packets are relatively infrequent.",
          "createdAt": "2025-04-16T15:22:40Z",
          "updatedAt": "2025-04-16T15:22:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My position here is that the closing of the feedback loop is something that belongs at the application layer.  We don't need this in the protocol.  As Sanjay's requirement says (eliding 2119 language and adding emphasis) \"**Client-application** endpoint [sends] acknowledgement receipt of throughput advisory signal [...]\".\n\nChanging QUIC to handle this might seem like a good idea.  It smooths the path for feedback and ensures consistent implementation.  However, this protocol operates outside of QUIC for the most part; you might equally ask why we aren't providing the feedback in HTTP/3.\n\nThe clincher for me is that it depends very much on application regarding the exact form that feedback takes.  HLS applications won't need to send any direct advice feedback, the client only needs to use the information to choose a different chunk at the next opportunity.",
          "createdAt": "2025-04-30T21:25:20Z",
          "updatedAt": "2025-04-30T21:25:20Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At IETF 123 it was agreed to not pursue this issue further. ",
          "createdAt": "2025-07-23T08:57:35Z",
          "updatedAt": "2025-07-23T08:57:35Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDON1dwo86vExP6",
      "title": "Detail interaction with congestion control",
      "url": "https://github.com/ietf-wg-scone/scone/issues/8",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "This came on repeatedly during the Bangkok IETF session. Congestion control and Trone are complementary, but we need to explain how that complementing works.",
      "createdAt": "2025-03-21T04:53:23Z",
      "updatedAt": "2025-07-09T11:32:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "Totally agreed @huitema . We tried to describe the distinction between SCONE and ECN in an [earlier draft](https://datatracker.ietf.org/doc/draft-tomar-scone-ecn/) but I am glad you are owning up to describe the complementarity of Trone and congestion control wholistically.",
          "createdAt": "2025-03-26T15:48:42Z",
          "updatedAt": "2025-03-26T15:48:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "During the 4/16/25 interim, we agreed to only merge part of PR #16, leaving aside a bunch of text:\n\n1. Speculative text about using congestion control signals to trigger TRONE packets when congestion eases: Consider then a condition in which congestion eases, either because the\ncompeting connections end or because the wireless transmission capacity\nimproves. The endpoints will notice that the rate of ECN marking rate has\nbecome low enough, and that the path is not congested anymore. However,\nthey don't know by how much they can increase their sending rate. Most\ncongestion control algorithms will proceed cautiously, allowing the\napplication to increase its sending rate step by step and verifying at each\nstep that they are not causing congestion. In these cases, a TRONE\nsignal can inform them about the changed capacity of the path and allow\nthem to increase capacity faster.\n\n2. Speculative text about using the TRONE signal to inform congestion control at the beginning of a connection: The TRONE signal can be particularly useful at the very beginning of a\nconnection. Congestion control algorithms typically start with a\nslow start process in which the application is allowed to double\nits sending rate after each RTT, until congestion is notified. This\nresults in a burst of excess transmission during the last RTT,\ncreating queues and possibly causing packet losses. Queues and\nlosses will affect not just the new connection that is testing the\ncapacity of the path, but also all established connections that\nshare the bottleneck. If the endpoints are using TRONE and learned the\nmaximum capacity of the path, they can exit the slow start process\nas soon as the maximum capacity has been tested, and avoid creating\nqueues or causing packet losses.\n\n3. Speculative text linking TRONE and \"careful resume\": The TRONE signal can also be useful if the applications remembers the\ncongestion control parameters of previous connections, and uses a\n\"careful resume\" process to quickly ramp up capacity as specified\nin  ({{?I-D.ietf-tsvwg-careful-resume}}). The endpoints could use\nTRONE to verify that the path characteristics have not changed\nsince the last connection before applying the careful resume\nprocess.\n\n4. General advice that if congestion uses the TRONE signal, it should be aware that if could be spoofed: In all cases, the endpoints should consider that the TRONE signal could\nhave been spoofed (see {{security}}). The congestion controller can use\nthe maximum capacity indicated by TRONE as a guide, but it\ncan also cautiously probe for available\ncapacity beyond the limit until receiving congestion signals.\n\nWe may want to use some of this text to specify whether and how congestion control use the TRONE signal. This is not obvious, because the general advice is that the two are independent, but it would be naive to believe that nobody would try plugging the capacity signaled by TRONE in their congestion controller. It might be better to explain the pitfalls of doing that, and perhaps signal the rare points where it makes sense.\n\nWe may also want to look at how \"easing of congestion\" could be used as a trigger for sending SCONE packets. This is somewhat experimental, because current congestion algorithms only detect easing of congestion if the application can push more data. An application working under the TRONE specified rate limit would not be able to do that. Updated congestion control algorithms might be able to detect easing of congestion by monitoring the rate of ECN marks, or the evolution of the RTT, but this is still a research area.",
          "createdAt": "2025-04-16T17:15:24Z",
          "updatedAt": "2025-04-16T17:15:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All of these seem to be variants on the scenario where known limits from the congestion controller is (much) lower than the throughput advice.  I think that we can do a few things:\n\nFirstly, note that throughput advice is a cap, not a guarantee.\n\nThen, note that throughput advice comes from a single network element, which cannot always make claims about other elements or links on the full end-to-end path.\n\nTherefore, while it might suggest a target bitrate, there is no guarantee that that rate can be achieved.  This is weaker still than the careful resumption case, where at least you have recent evidence that a path between nominally the same endpoints supported a given throughput in the path.  Tweaking the probing of the congestion controller to move more aggressively toward the limit implied by throughput advice could be possible, but endpoints need to be especially sensitive to any congestion signals that might indicate a lower throughput in practice.\n\nI fear that attempts to use this advice as a target rate will end up doing bad things if we aren't extremely careful in how we frame guidance.",
          "createdAt": "2025-07-09T01:31:38Z",
          "updatedAt": "2025-07-09T01:31:38Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The prudent way to include TRONE advice is startup is indeed different from careful resume. Careful resume provides a target. TRONE provides an upper bound. Not the same, but valuable in its own right. Typical startup algorithm involve exponential increase and are probe to overshoot. Limiting startup to \"probe up to this limit\" would avoid overshooting, and the large queues that it causes.",
          "createdAt": "2025-07-09T03:49:44Z",
          "updatedAt": "2025-07-09T03:49:44Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema I'm not sure if I agree.\n\nSCONE signals advise bandwidth over a time scale of ~60 seconds for sustained flows, whereas congestion signals indicate that per round trip regardless of the characteristics of the flow.\n\nIMO, it makes sense for congestion controllers to shoot up to their limits regardless of what SCONE signals indicate.",
          "createdAt": "2025-07-09T06:07:09Z",
          "updatedAt": "2025-07-09T06:09:45Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was very specific. \"When to stop startup\" is a big issue. Typical startup process figures exponential growth, which means by the time the process has reached the desired capacity, there are twice too many packets flying. If you care about real time performance, that's not good. That does not mean the controller has to completely stop exploring. It could, but it would probably be wise to do that in a cautious way, maybe like the 2nd phase of Hystart++.",
          "createdAt": "2025-07-09T06:20:04Z",
          "updatedAt": "2025-07-09T06:20:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree about the problem. What I'm struggling to follow is how we could apply SCONE signals to Slow Start in case of real-time applications.\n\nIf the flow is going to last long (or is likely to last long), I'd argue that the applications should respect SCONE. As they are real-time applications (like video conference), they will be application-limited at the rate advice provided by SCONE. Therefore, we do not need to decide how CC should behave when going above the SCONE advice.\n\nIf the flow is to be spontaneous, then there might be benefits to go above the SCONE limit. But what exactly are those kind of applications that require low latency and but communicate only for a few seconds? How much improvement can we expect by incorporating the SCONE signals assuming that CC is tuned already for low latency?",
          "createdAt": "2025-07-09T11:32:09Z",
          "updatedAt": "2025-07-09T11:32:09Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDON1dwo86vE006",
      "title": "Consider a way to do greasing",
      "url": "https://github.com/ietf-wg-scone/scone/issues/9",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is a bit of ambiguity in the specification of \"who uses TRONE\". The original Scone WG appears to have focused on adaptive bit rate video. If we strictly kept that focus, we have a privacy issue. Third parties could observe the presence of Trone headers, and infer that the end to end QUIC connection is engaged in video streaming.\n\nTo reduce the privacy issue, we could adopt a combined strategy, and ask more applications to support Trone, thus weakening the correlation between Trone and video.\n\nWe could also envisage greasing, with applications sending datagrams composed of a Trone packet, followed by a short header and random content. If the peer is not Trone capable, such greasing packets will be discarded because they do done decrypt correctly. But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.",
      "createdAt": "2025-03-21T05:04:11Z",
      "updatedAt": "2025-08-06T02:12:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "> But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.\n\nI am assuming you are referring to the network element as the \"third party\" here. If you prevent the network element from distinguishing the \"real\" Trone packets from the Greased packets, then how will the network element decide which packet to add the rate advisory to?",
          "createdAt": "2025-03-26T08:32:29Z",
          "updatedAt": "2025-03-26T08:32:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@atiwariphd the network element cannot distinguish between grease and real TRONE packet. I documented that as an attack in a separate PR #13 ",
          "createdAt": "2025-03-26T17:43:14Z",
          "updatedAt": "2025-03-26T17:43:14Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I don't think that using scone automatically implies that it is or has to be video traffic (even thought is our main, or maybe only (?), use case). However, note that if you sent any scone packets on a flow, this might be taken as a signal by a throttling device that this flow is okay or even requested to be throttled (because it is adaptive and actually achieves a better user experience with a stable rate rather than the maximum rate). Not all network devices might enforce throttling but some might simply apply throttling to all scone flows (if they exceeded the singled rate). Thus you should maybe not use scone on any kind of traffic that really needs maximum bandwidth. Having that said, I would think that e.g. for short flows like web traffic, it doesn't matter if you use scone or not as it will anyway not run into the throttling limit. However, also note that if too many flows use scope and that would cause unnecessary use of resources in the network device to check rate compliance, a network device might fall-back to DPI to actually detect video traffic. Therefore I recommend to rather avoid using scone when it is know to be not necessary.",
          "createdAt": "2025-08-05T17:14:58Z",
          "updatedAt": "2025-08-05T17:14:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I generally agree.  I'm inclined to leave this to implementations rather than invent some mechanism.\n\nNote that you can grease the indication, but not packets, because if you sent a SCONE packet to a peer that doesn't support the protocol, it causes self-inflicted packet loss as they are forced to drop the entire datagram.",
          "createdAt": "2025-08-06T00:30:34Z",
          "updatedAt": "2025-08-06T00:30:34Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can send a Scone packet to a peer. You just must expect it to be lost. So sending a Scone packet concatenated with a fake 1RTT packet is completely fine. The peer will just drop it.",
          "createdAt": "2025-08-06T02:12:23Z",
          "updatedAt": "2025-08-06T02:12:38Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDON1dwo86vE3Wm",
      "title": "Could network elements mangle innocent packets?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/10",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is already discussed in the [TRAIN issue 32](https://github.com/martinthomson/train-protocol/issues/32). A Trone intermediary can mistake packets of some other applications for Trone packets. If it reqrite 6 bits, that will cause the packet to be eithre dropped or misinterpreted.\n\nAs explained by @ihlar during the IETF meeting in Bangkok, we need to distinguish:\n\n1. random collision: the end to end application issues some random first bytes that happen to mimic Trone. It will happen at low frequency.\n2. systematic collision: the end to end collision had negotiated some header that happens to Mimic Trone. All packets with that header will be mangled.\n\nThe proposed solution is for intermediaries to keep flow state and stop marking if too many packets of a flow match Trone. We need to develop that.\n",
      "createdAt": "2025-03-21T05:11:54Z",
      "updatedAt": "2025-04-08T09:29:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree we should document this and give some guidance on when to stop marking.\n\nThe use of two versions could help here as well. If the protocol mandates that endpoints send packets of both versions, only  observing packets of a single version could be an indication that these packets are mimicked and not real TRONE.\n\nSo, something like - stop marking if:\n\n1. After observing N packets, the ratio of TRONE to non-TRONE packets is close to 1.\n2. After observing M TRONE packets, the ratio of TRONE-1 to TRONE-2 (or vice versa) is close to 1.  ",
          "createdAt": "2025-04-08T09:29:05Z",
          "updatedAt": "2025-04-08T09:29:05Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDON1dwo86vE_RE",
      "title": "Spoofing attacks against intermediaries",
      "url": "https://github.com/ietf-wg-scone/scone/issues/11",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In issue #9 we discuss the possibility of greasing TRONE. Greasing is cool for privacy, but the same mechanisms can be used as an attack. Suppose something like:\n\n~~~\n+------------+    +----------+       /---------------\\       +-------------+\n|end point A | -- | Trone NE | ---- ( Big bad Internet) ---- | end point B |\n+------------+    +----------+       \\---------------/       +-------------+\n                                          |\n                                          |\n                                    +-------------+\n                                    | wily hacker |\n                                    +-------------+\n~~~\n\nThe hacker creates Trone packets with:\n\n* IP / UDP header: set IP source to address of B, IP destination to address of A\n* SCONE packet: pick a destination CID and a destination CID\n* 1RTT header: same destination  CID as SCONE packet\n* 1 RTT content: enough random bytes to look plausible\n\nThe attacker needs to know at least a valid address for end point A, so the packets will be routed through the target NE, but after that there are many possibilities:\n\n* an off path attacker can pick random values for the source address of \"B\" and for the CID.\n* an on path attacker can pick pairs of addresses that match existing hosts \"A\" and \"B\" and either random CID or CID copied from observed traffic.\n\nThe possible effects would be:\n\n* trick the NE into \"remembering\" lots of TRONE context, thus consuming lots of memory\n* force the NE to process a vast quantity of TRONE packets, thus consuming lots of resource\n* trick the NE into detecting a \"systematic collision\" (see issue #10) and thus disable TRONE for that flow.\n ",
      "createdAt": "2025-03-21T05:38:19Z",
      "updatedAt": "2025-04-30T20:12:49Z",
      "closedAt": "2025-04-30T20:12:49Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDON1dwo86vv_gA",
      "title": "Is the \"version=range\" paradigm appropriate?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/14",
      "state": "CLOSED",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As presented at IETF 122, we define a \"version\" field that is used to choose between possible ranges.\nThis seems strange both from a cleanliness standpoint and from a greasing standpoint.\n\nWhen there are only two versions, the version field amounts to an extra bit in the range specifier - by including it directly in the range specifier (making it 0-127 rather than 0-63), we gain an unified range with a larger span (or a finer resolution, if we choose to reduce the multiplier in the exponential spacing).\n\nIf we desire to ensure that we can introduce more versions of the TRONE signal later, two versions with near-identical semantics are not enough.\n",
      "createdAt": "2025-03-26T07:03:56Z",
      "updatedAt": "2025-04-30T08:17:09Z",
      "closedAt": "2025-04-30T08:17:09Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think there could be discussions regarding how endpoints / network elements act and how the bit rates are encoded.\n\nRegarding the former, at the moment, the draft defines two versions of TRONE covering different ranges. Senders send both. Network elements modify both independently. Receivers calculate the minimum of the two. There is indeed some complexity, when the goal is to signal just one value (i.e., the bit rate).\n\nAn alternative design will be to allow network elements rewrite TRONE2 packets (carrying larger bit rates) to TRONE1 packets (carrying smaller rates).\n\nIf we adopt such a design, senders just need to send one TRONE packet (i.e., TRONE2). Receivers will no longer be required to calculate the minimum.\n\nNetwork elements would still be required to observe two versions and rewrite them as necessary (possibly to a different version), but considering that we only have 6 spare bits in the QUIC invariants before variable length fields, I think we have to either squeeze all bit rates into 6 bits or live with having multiple versions indicating different bit rates.",
          "createdAt": "2025-04-16T10:16:13Z",
          "updatedAt": "2025-04-16T10:16:13Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the idea of rewriting is an good one. The one thing we have to be careful about, in my opinion, is that not _every_ future version of TRONE can be rewritten.\n\nSo for example, suppose the initial protocol has 0xTRONE1 and 0xTRONE2 and a network element can rewrite 0xTRONE1 <->0xTRONE2. Suppose subsequently we figure out we need a 0xTRONE3 for some purpose. I think any network element that only understands 0xTRONE1/2 should not rewrite 0xTRONE3 packets, and simply ignore them.",
          "createdAt": "2025-04-16T15:57:09Z",
          "updatedAt": "2025-04-16T15:57:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The idea of version rewriting is in line with the general design of using 2 version numbers to get an extra bit for the range of values.",
          "createdAt": "2025-04-17T18:12:28Z",
          "updatedAt": "2025-04-17T18:12:28Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDON1dwo86v0U91",
      "title": "TRONE with other protocols - ICE in particular?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/15",
      "state": "CLOSED",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As specified, the TRONE protocol only works with QUIC. And given that it can prepend data to a datagram, it is not a drop-in with anything but QUIC.\n\nThis form of signalling is interesting to other use cases. Would it be reasonable/possible/hard/impossible to carry a TRONE packet as an ICE extension?\n",
      "createdAt": "2025-03-26T14:02:31Z",
      "updatedAt": "2025-07-11T02:09:42Z",
      "closedAt": "2025-07-11T02:09:42Z",
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "@alvestrand \n\n> This form of signalling is interesting to other use cases.\n\nCan you please articulate the use case?",
          "createdAt": "2025-03-26T15:43:02Z",
          "updatedAt": "2025-03-26T15:43:02Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "The classical WebRTC VC use case is one where we set up a video call (usually between the user and a datacenter), and we want to adapt the codec configuration to the available bandwidth.\nToday we do that using congestion control only.\n",
          "createdAt": "2025-03-26T16:30:28Z",
          "updatedAt": "2025-03-26T16:30:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See issue #9 about greasing. The intermediaries do not know that a TRONE packet is in fact a QUIC packet. They merely see a TRONE packet followed by a QUIC like byte, a repeat of the connection identifier bytes, and a bunch of random looking bytes. If you want to add more complexity to ICE, your ICE implementation could certainly send UDP packets that match that format. QUIC enpoints use the \"random bytes\" for verifying that the packet is legit; you could use this random bytes to carry some kind of verifier in your ICE/TRONE packets.",
          "createdAt": "2025-03-26T17:54:06Z",
          "updatedAt": "2025-03-26T17:54:06Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "ICE packets are distinguished from other packets by looking at the first byte. TRONE packets, as specified, would put a different value in the first byte. See https://datatracker.ietf.org/doc/html/rfc7983#section-7\nIt would be trivial to specify a TRONE packet as an ICE attribute, and ICE even has support for protecting only some of the attributes in an ICE packet (it uses a hash over the message + a shared secret), but it's a non-trivial job for the router to find the TRONE packet inside the ICE message.\n",
          "createdAt": "2025-03-26T21:00:02Z",
          "updatedAt": "2025-03-26T21:00:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alvestrand that's why I suggested sending two messages, the ICE message proper, and a separate \"TRONE\" message on the same 4-tuple.",
          "createdAt": "2025-03-26T23:29:28Z",
          "updatedAt": "2025-03-26T23:29:28Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification - I imagined that you were suggesting sending a single UDP packet with a TRONE message followed by the ICE message, but sending two UDP makes much more sense. Specifying a payload that would pass the TRONE inspector and be verifiable with the ICE credentials shouldn't take much more than a page.",
          "createdAt": "2025-03-27T08:22:08Z",
          "updatedAt": "2025-03-27T08:22:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alvestrand does this address the concern?  I think that this is a general question about how QUIC (all QUIC versions) and ICE/STUN/TURN might interact.  That's not really in scope for this work, so I'm not clear that we should really spend words on it in the draft.  If you disagree, I'd like to understand what we might then need to say.",
          "createdAt": "2025-07-10T01:34:25Z",
          "updatedAt": "2025-07-10T01:34:25Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Given that we can solve this by sending 2 messages, I think this is follow-on work, not impacting the document that's currently the working group focus.\n\nLet's close this for now.\n",
          "createdAt": "2025-07-10T11:09:46Z",
          "updatedAt": "2025-07-10T11:09:46Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDON1dwo86wCKw4",
      "title": "Clarify rounding behavior for bitrate-to-signal value conversion",
      "url": "https://github.com/ietf-wg-scone/scone/issues/17",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft needs clear guidance on rounding when converting between bitrates and signal values.\n\n- Should implementers round up or down when converting from bitrates to signal values?\n- What are the practical implications of each choice? (rounding down ensures staying under capacity limits; rounding up maximizes bandwidth utilization when rate adaptation algorithms rarely use full capacity)\n- Recommend specific approach with rationale, noting the logarithmic scale means adjacent steps differ by at most ~11%\n- Include example calculations demonstrating the recommended approach\n\n\n\n",
      "createdAt": "2025-03-27T15:07:00Z",
      "updatedAt": "2025-07-23T16:10:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we're OK now.  It's clear how the limit is interpreted, so that creates the right set of conditions.  We don't need to hold their hands through this.",
          "createdAt": "2025-07-23T16:10:15Z",
          "updatedAt": "2025-07-23T16:10:15Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDON1dwo86wCPkw",
      "title": "Confusion between \"No limit\" and \"TRONE not supported on path\"",
      "url": "https://github.com/ietf-wg-scone/scone/issues/18",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently conflates two distinct conditions in signal value 63 to mean either:\n- The network can support unlimited bandwidth (higher than max range)\n- TRONE is not supported by network elements on path\n\nThis creates ambiguity for applications interpreting signal 63 - should they assume unlimited bandwidth or cautiously rely on congestion control? We could disambiguate this by using different signal values:\n\n- 62: No limit (bandwidth exceeds maximum range)\n- 63: TRONE not supported on path\n\nOr clearly specify how applications should interpret signal 63, acknowledging its dual meaning requires caution.",
      "createdAt": "2025-03-27T15:11:45Z",
      "updatedAt": "2025-04-08T11:28:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.",
          "createdAt": "2025-03-27T15:12:48Z",
          "updatedAt": "2025-03-27T15:12:48Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.\n\nI agree, there is no need to distinguish between these. I take 63 to mean there is no limit in this range, whether that is due to an active policy or absence thereof makes no difference. ",
          "createdAt": "2025-04-08T11:28:45Z",
          "updatedAt": "2025-04-08T11:28:45Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDON1dwo86wDn_2",
      "title": "Privacy considerations when sending different TRONE protocol versions",
      "url": "https://github.com/ietf-wg-scone/scone/issues/19",
      "state": "CLOSED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently recommends alternating between TRONE1 and TRONE2 versions without addressing the privacy implications. We should think about this more and at least add some considerations to the text.\n\nTo ensure network elements know TRONE is supported while minimizing information disclosure, one idea would be:\n\n- Send at least one packet of each version initially even if the application only operates in one range.\n- Subsequently prioritize sending the version most relevant to current bandwidth usage\n",
      "createdAt": "2025-03-27T16:50:15Z",
      "updatedAt": "2025-04-30T09:27:10Z",
      "closedAt": "2025-04-30T09:27:09Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be fine to keep alternating the versions at all times, just use two datagrams to send TRONE probes. I suppose that would be the best solution from a privacy perspective (unless I'm missing something). The additional cost of alternating should be low, and there are other potential benefits as discussed in #10 .",
          "createdAt": "2025-04-08T11:58:15Z",
          "updatedAt": "2025-04-08T11:58:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be precise, will it be:\r\na) for the first burst send TRONE1 and for the next burst send TRONE 2, or\r\nb) for each burst send both TRONE 1 and TRONE2?\r\n\r\nI assume it'd be _b\", but trying to confirm.\r\n\r\nRegarding the overhead, I agree that it'd be negligible. The lowest bitrate being proposed is 100Kbps which is ~10pps assuming 1200 byte packets. That'd mean that, if endpoints are to receive updated TRONE signals one per every 10 seconds (see #20), the difference is sending one or two QUIC packets with TRONE headers for every 100 UDP datagrams.",
          "createdAt": "2025-04-09T04:50:22Z",
          "updatedAt": "2025-04-09T04:50:22Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes agree that it should be _b_.",
          "createdAt": "2025-04-09T05:32:05Z",
          "updatedAt": "2025-04-09T05:32:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As stated in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526, we could allow network elements rewrite TRONE2 packets (carrying higher bit rates) to TRONE1.",
          "createdAt": "2025-04-16T15:44:13Z",
          "updatedAt": "2025-04-16T15:44:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that #25 has been merged, I think we can close this issue too.",
          "createdAt": "2025-04-30T09:06:08Z",
          "updatedAt": "2025-04-30T09:06:08Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #25 ",
          "createdAt": "2025-04-30T09:27:09Z",
          "updatedAt": "2025-04-30T09:27:09Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDON1dwo86xr5d8",
      "title": "Time window for suggested bitrate",
      "url": "https://github.com/ietf-wg-scone/scone/issues/20",
      "state": "OPEN",
      "author": "rjt-ietf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue is mostly in regard to  slide 11 of https://datatracker.ietf.org/meeting/122/materials/slides-122-scone-trone-questions-01, which was discussed at IETF 122.\n\nThe current draft doesn't mention this perspective so I want to open up the discussion.\n\nIn general, I think that a fixed window length specified by SCONE is preferable as it simplifies works for network elements. But meanwhile, we need to find a window that works for all users of SCONE.\n\nDifferent video applications choose to buffer different lengths of videos during playbacks. For example, App A may buffer 10s while App B buffers 20s. A 10-second window will work for app A but not work for app B. A 20-second window will work for both.\n\nA flow that complies with a short window will also comply with a longer one.\n\nThis means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection. ",
      "createdAt": "2025-04-08T22:27:05Z",
      "updatedAt": "2025-07-21T16:20:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection.\r\n\r\nAgreed.\r\n\r\nSince network devices cannot identify the actual application protocol being used (e.g., HLS, WebRTC, MOQ), the responsiveness to TRONE signals they can expect corresponds to that of the least responsive application protocol.\r\n\r\nAssuming that HLS would use chunks as large as 10 seconds, and assuming that each chunk would be sent at full speed, window of 20 seconds is a good ball-park figure, IMO.",
          "createdAt": "2025-04-09T04:42:48Z",
          "updatedAt": "2025-04-09T04:42:48Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "For realtime video, the interesting timeframe  is the next 20 ms - we don't buffer on the HLS timescale.\nPermitted burst size is of interest, but mainly because we don't want the L4S problem of sending a keyframe and having the last packet of the frame be marked as congestion-experienced because the whole keyframe was sent at line rate.\n\n",
          "createdAt": "2025-04-09T06:20:51Z",
          "updatedAt": "2025-04-09T06:20:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are two separate questions:\n* time window of the signals being emitted by network elements (which would be the window that they would use for detecting abuse)\n* how frequent endpoints request / receive updates\n\nFor the first question, unless endpoints agree to expose what type of application they are, the time window has to be that of the application that takes the longest time to adopt to the SCONE signal. My guess is that that application would be HLS, and that therefore the time window should be in the order of 10 seconds.\n\nFor the second question, I think there is no need to forbid endpoints requesting SCONE signals more frequently, e.g., by sending TRONE packets.",
          "createdAt": "2025-04-09T23:47:54Z",
          "updatedAt": "2025-04-09T23:48:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "SCONE is intended for timeframes of multiple RTTs at a minimum, so I would expect 30 seconds or a minute to be a reasonable timeframe.",
          "createdAt": "2025-04-16T15:26:16Z",
          "updatedAt": "2025-04-16T15:26:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion at Interim 3: we need to pick a value now for the doc to be adopted. 20 seconds seems to be a good starting point. Keeping this issue open to make sure we don't lose the finer points here.",
          "createdAt": "2025-04-16T15:35:22Z",
          "updatedAt": "2025-04-16T15:35:22Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "This is what we presented at SCONE interim #6. https://datatracker.ietf.org/meeting/interim-2025-scone-06/materials/slides-interim-2025-scone-06-sessa-time-window-duration-for-bitrate-measurement-00.pdf",
          "createdAt": "2025-06-12T21:11:21Z",
          "updatedAt": "2025-06-12T21:11:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unfortunately, I missed the presentation, but the results are very useful.  The question I have, which relates more to how applications using this might operate is: If we have a 120s window, does that potentially mean that the entire budget can be expended in one hit?  \n\nLet's say that the limit is a relatively modest 5Mbps.  Over a 120s window, that's ~75 megabytes of data.  I can confirm that modern networks are capable of delivering that much data in a very short time.  If that data ends up being delivered, but not useful, is the application expected to sit on its hands for the remainder of those two minutes?\n\nFor me, that argues for a shorter window on the basis that we need to limit the potential dead air, even if the ideal might be that the rate is applied over that longer window.  Any value we pick is also the amount of time that someone might have to sit watching their device do nothing.\n\nThe other factor, of course, is that the longer radio timers tend to run in the order of 30s, so any window shorter than 30s might not allow battery-powered devices to enter the most power-efficient modes.  Of course, there are shorter radio timers that allow for significant savings short of the full idle state and re-awakening from that state is somewhat costly.  So perhaps it is better to avoid that state for a device that is actively being used, so maybe 30s is not that big a deal.\n\nAll of this leads me to suggest that, while 120s might be an ideal at the low end, there are reasons other than those used in the presentation to suggest a shorter value.  Could we perhaps split the difference?\n\nSeparately, I think we'd want to suggest a sliding window, though perhaps we can allow larger quanta than 0.01s.  The results show some differences (the sliding window needs more time in a few cases, probably because it is less forgetful), but they aren't particularly large differences.  Block windows risk having applications accidentally synchronize their resets, which might lead to load spikes.",
          "createdAt": "2025-07-02T21:49:11Z",
          "updatedAt": "2025-07-02T21:49:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "Sliding windows do seem slightly better, and even 1 second granularity would likely be fine.\n\nThe tests only indicated 120s was needed when the SCONE indicated bitrate was fairly low.  I suspect the max bandwidth was quite high in those cases, so the SCONE rate might have been 2Mbits and the congestion controller might have seen 100Mbits?  \n\nI don't expect applications to ruthlessly follow this guidance.  If you start one video playback and then skip to the next one, you might exceed the intended bitrate for a bit if those video playbacks use the same connection.  But the individual videos would still be trying to conform to the guidance.",
          "createdAt": "2025-07-03T18:59:51Z",
          "updatedAt": "2025-07-03T18:59:51Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "\n\n\n\n> Unfortunately, I missed the presentation, but the results are very useful. The question I have, which relates more to how applications using this might operate is: If we have a 120s window, does that potentially mean that the entire budget can be expended in one hit?\n> \n> Let's say that the limit is a relatively modest 5Mbps. Over a 120s window, that's ~75 megabytes of data. I can confirm that modern networks are capable of delivering that much data in a very short time. If that data ends up being delivered, but not useful, is the application expected to sit on its hands for the remainder of those two minutes?\n> \n> For me, that argues for a shorter window on the basis that we need to limit the potential dead air, even if the ideal might be that the rate is applied over that longer window. Any value we pick is also the amount of time that someone might have to sit watching their device do nothing.\n\nVideo duration size is not fixed and can vary from few seconds to many minutes.  Typically user plays/swipes many videos consecutively on a short form streaming video app so this should address the point you raised above. Key point we wanted to highlight by sharing the results that if advised bit-rate is 2 mbps or less (which is very common in the mobile n/ws ) and if window duration is less than 120 second, then in order to meet the advised bit-rate CAPs may need to flatten (aggressive pacing) the data flow  (this may end up making the video flow less bursty and may impact the QoE negatively like we saw with n/w shapers.). ",
          "createdAt": "2025-07-21T13:30:33Z",
          "updatedAt": "2025-07-21T13:30:33Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> The other factor, of course, is that the longer radio timers tend to run in the order of 30s, so any window shorter than 30s might not allow battery-powered devices to enter the most power-efficient modes. Of course, there are shorter radio timers that allow for significant savings short of the full idle state and re-awakening from that state is somewhat costly. So perhaps it is better to avoid that state for a device that is actively being used, so maybe 30s is not that big a deal.\n\nIt is rather other way round. Larger window duration would allow apps to deliver the videos in large burst followed by longer idle period. And bursty data flows by capacity seeking, non-latency sensitive applications (for e.g. VOD applications) helps with UE battery power saving. This allows UEs/devices to go into longer sleep cycle. We tested this in live n/w;  with n/w shaper and w/o n/w shaper. With n/w shaper  (which flattens the data flow) UE was not able to go into CDRX(Connected mode Discontinuous Reception), resulting into more battery power consumption. Shorter window duration may force apps to pace the data transfer to meet the bit-rate conformance and it would lead to data xfer being less bursty (continuous data transfer) and would not let UE/device to go into CDRX ( long sleep cycle). ",
          "createdAt": "2025-07-21T13:43:24Z",
          "updatedAt": "2025-07-21T13:43:24Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> Separately, I think we'd want to suggest a sliding window, though perhaps we can allow larger quanta than 0.01s. The results show some differences (the sliding window needs more time in a few cases, probably because it is less forgetful), but they aren't particularly large differences. Block windows risk having applications accidentally synchronize their resets, which might lead to load spikes.\n\nDuring our testing we used both sliding window and block window based measurement. We just wanted to check if we see significantly different results. Takeaway was that the results were close enough that which method to use did not matter much. However it would help if CSPs provide more insight into how they plan to measure avg bit rate over a time-window. For e.g if CSPs are not particular about window start time then they can use block window avg. However if they are particular about window start time then they may want to use sliding window to measure bit-rates with all possible start time. But in general with 120 second as a window duration it should not matter much. ",
          "createdAt": "2025-07-21T16:11:55Z",
          "updatedAt": "2025-07-21T16:11:55Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> Sliding windows do seem slightly better, and even 1 second granularity would likely be fine.\n> \n> The tests only indicated 120s was needed when the SCONE indicated bitrate was fairly low. I suspect the max bandwidth was quite high in those cases, so the SCONE rate might have been 2Mbits and the congestion controller might have seen 100Mbits?\n> \n> I don't expect applications to ruthlessly follow this guidance. If you start one video playback and then skip to the next one, you might exceed the intended bitrate for a bit if those video playbacks use the same connection. But the individual videos would still be trying to conform to the guidance.\n\n\n\n> Sliding windows do seem slightly better, and even 1 second granularity would likely be fine.\n\nWith sliding window, measured bit-rate for a given duration was higher than the measured bit-rate with block window for some instances mainly during app start time as expected. ",
          "createdAt": "2025-07-21T16:15:15Z",
          "updatedAt": "2025-07-21T16:15:15Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> The tests only indicated 120s was needed when the SCONE indicated bitrate was fairly low. I suspect the max bandwidth was quite high in those cases, so the SCONE rate might have been 2Mbits and the congestion controller might have seen 100Mbits?\n\nLab cellular Setup had good channel condition , FDD , 5 MHz, 2*2  ( 37 Mbps overall bandwidth in DL ). ",
          "createdAt": "2025-07-21T16:17:58Z",
          "updatedAt": "2025-07-21T16:17:58Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> I don't expect applications to ruthlessly follow this guidance. If you start one video playback and then skip to the next one, you might exceed the intended bitrate for a bit if those video playbacks use the same connection. But the individual videos would still be trying to conform to the guidance.\n\nVideo duration size is not fixed and can vary from few seconds to many minutes. Typically user plays/swipes many videos consecutively so the scenario of measuring bit-rate for a connection which played only one video of less than 120 sec may not be that common.  ",
          "createdAt": "2025-07-21T16:20:43Z",
          "updatedAt": "2025-07-21T16:20:43Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDON1dwo86yoU-z",
      "title": "Network inserted TRONE packets",
      "url": "https://github.com/ietf-wg-scone/scone/issues/21",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The topic of whether network elements should be able to generate TRONE packets and insert them into expanded datagrams was discussed at IETF 122. Also discussed in #6.\nIdeally this should not be needed, given that there is proper guidance on when to send TRONE packets and making sure that updating the rate limit field of the TRONE packets is sufficiently cheap. The risk of expanding datagrams in the network is that it can result in path MTU issues with lost packets as a consequence. \n\nThere are a few paths we can take on this topic:\n\n1. Say nothing about it.\n2. Mention the possibility and give guidance on potential MTU issues that can arise. \n3. Explicitly forbid network inserted TRONE packets and design protocol mechanisms to enforce it.",
      "createdAt": "2025-04-15T15:59:14Z",
      "updatedAt": "2025-07-08T07:04:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I believe we should have normative text advising against doing this and why, but I doubt it's worth building a mechanism to enforce that unless it's quite simple.",
          "createdAt": "2025-04-16T15:16:54Z",
          "updatedAt": "2025-04-16T15:16:54Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suspect it would be easy for the encrypted envelope to carry such protection of the TRONE info ... and an on-path observer would never know if the endpoint did this, or not. (However, realising the mechanism could be done later -  there may be pain in making an efficient implementation).",
          "createdAt": "2025-04-16T15:53:06Z",
          "updatedAt": "2025-04-16T15:53:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way I would recommend enforcement, though I don't think we need it, is to define a new QUIC frame that is enabled by the existing extension.  That frame would be included by the sender in any packet that it constructs with a SCONE packet.  If the recipient receives a SCONE packet, the validation process involves not just accepting a coalesced packet (as presently recommended), but checking for the frame.  The frame could be designated probing and non-ack-eliciting and use a 2 byte codepoint, so the overhead would be low.\n\nThat's a simple mechanism and very easy to implement for all involved.  It's also not worth it in my view.  It's not hard to retrofit this specific design cleanly, but it would eat another transport parameter codepoint if we added something later, so it's better to decide now.\n\nA protocol-free approach is to simply remember which packets were coalesced with a SCONE packet, and ask the peer to report where it saw SCONE packets.  That doesn't depend on any protocol at all, but depends on having a reporting channel at the application layer or somewhere else.  The downside of this is that it might be awkward for those applications to integrate, especially for those applications that don't have any need for signaling,\n\nLike @ianswett, I don't see much upside for either.  I'm inclined to stick with the silence option.  That discourages the practice, for all but the most technically competent networks, who are in a position to recognize the opportunity AND the risk that comes with inflating packets past the MTU.  If we say something, we inevitably encourage the practice, even if it says \"SHOULD NOT\". I don't to do that.",
          "createdAt": "2025-07-03T05:33:45Z",
          "updatedAt": "2025-07-03T05:33:45Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would point out that we already have the capability to drop SCONE packets that are simply inserted, and that that is sufficient for preventing misuse.\n\n[Section 8.1 ](https://ietf-wg-scone.github.io/scone/draft-ietf-scone-protocol.html#name-providing-opportunities-to-) states that _an endpoint that receives and discards a SCONE packet without also successfully processing another packet from the same datagram SHOULD ignore any throughput advice signal._\n\nQUIC endpoints process each packet only once, dropping duplicates.\n\nTherefore, the only case the current design does not prevent is on-path observers creating a duplicate of an observed packet, attaching a fake SCONE packet to it, and racing it to the receiver so that it reaches the receiver earlier than the original packet; a sophisticated type of attack that we deemed impossible to have a defense against in QUIC v1.",
          "createdAt": "2025-07-08T01:04:10Z",
          "updatedAt": "2025-07-08T01:04:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An on-path element can drop the original; no need to race, just insert the SCONE packet in an existing packet.  (Assuming that it was valid in the first place, of which there is no guarantee.)",
          "createdAt": "2025-07-08T02:54:18Z",
          "updatedAt": "2025-07-08T02:54:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, so the threat comes only from on-path \u201cobservers\u201d; i.e., those that can observe and inject but cannot drop. As said, I do not think can (or need to) prevent them, based on the precedents.",
          "createdAt": "2025-07-08T03:12:48Z",
          "updatedAt": "2025-07-08T03:12:48Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On path routers are explicitly authorized to change the advice contained in the packet -- that's the whole point. That means it will be very hard to prevent off path observers to change the advice and race a packet. Changing the advice seems as bad as dropping the option. Given a gaping hole like that, I would rather try some complicated solution.",
          "createdAt": "2025-07-08T07:04:52Z",
          "updatedAt": "2025-07-08T07:04:52Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDON1dwo86y0OE3",
      "title": "How frequently should endpoints send TRONE packets?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/24",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This has been discussed extensively both privately, at IETF 122, and in the latest interim. We should give guidance to endpoints on how often and under what circumstances they should send TRONE packets to give an opportunity to generate new advice.",
      "createdAt": "2025-04-16T15:38:18Z",
      "updatedAt": "2025-06-10T15:25:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I were to propose an answer, I think the frequency should reflect how fast the application can adopt.\n\nTo give an example, in the case of HLS, it'd make sense to obtain one TRONE signal for each chunk but no more, because clients can switch between different bandwidths only once per chunk.\n\nIn case of applications that can adopt more rapidly, I think there is no need to constrain them from asking for an update every RTT.\n\nThe remaining question would be if sending one TRONE packet is sufficient for obtaining one signal, considering packet loss. I think the strategy can be different between the applications; some can send two packets, others can send one but use an ACK to see if the datagram that has the TRONE packet attached reached the peer. Absent ACKs, such endpoints can resend a TRONE packet.",
          "createdAt": "2025-04-22T03:54:40Z",
          "updatedAt": "2025-04-22T03:54:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not only how fast they *can* adapt, but how fast the application might need to learn about changes.  Streaming applications might be OK with several chunks of lag if their buffers are deep enough to absorb a network fluctuation.  Per-chunk might be faster than an HLS app needs, which provides it with a degree of redundancy.\n\nApps will know when marked packets are lost -- in exactly the same way that ECN markings are accounted for in QUIC -- so they can account for that in their sending, so I don't think we need anything special, other than a note about that.",
          "createdAt": "2025-04-22T04:14:15Z",
          "updatedAt": "2025-04-22T04:14:15Z"
        },
        {
          "author": "DanDruta",
          "authorAssociation": "NONE",
          "body": "Another way to look at this would be for the network to send a \"best by\" indicator along with the network advice so the endpoint would take stop sending scone packets during that \"freshness\" period. That would align with the frequency the network expects the signal to change ",
          "createdAt": "2025-06-10T15:25:56Z",
          "updatedAt": "2025-06-10T15:25:56Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDON1dwo86zZ_iG",
      "title": "Multipath",
      "url": "https://github.com/ietf-wg-scone/scone/issues/26",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The multipath extension allows sending data on multiple paths, including multiple paths bound to the same 4 tuple. I think that a QUIC application could split its traffic along multiple paths, all identified by different connection IDs. Applications could request some of these paths to announce Trone support, other not, and maybe others still to advertise the Non-Queue-Building type.\n\nDo we fill the need to say anything about that?",
      "createdAt": "2025-04-22T05:40:54Z",
      "updatedAt": "2025-07-07T23:35:24Z",
      "closedAt": "2025-07-07T23:35:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not that much.  We can point out that this is information that applies to a single path, not the entire connection.",
          "createdAt": "2025-04-22T07:19:55Z",
          "updatedAt": "2025-04-22T07:19:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe. Mostly, I am worried that network elements will combine Trone signalling and per-flow enforcement. This begs the question: what is the unit of enforcement? Four tuple? Four tuple plus CID? Address pair? Network subscription? ",
          "createdAt": "2025-04-22T18:06:02Z",
          "updatedAt": "2025-04-22T18:06:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The unit of enforcement is unclear.  All that the network is saying is that **at some scope that includes this flow** (and it might only be this flow, but probably not) there is a policy in place to limit throughput.  It's pretty useless, except when you only have one flow that is consuming most of that limit.  The reason it works is that there is often just one active flow from a home or mobile subscription.",
          "createdAt": "2025-04-23T01:42:53Z",
          "updatedAt": "2025-04-23T01:42:53Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Unit of enforcement seems like a different issue; my impression from initial discussions was that the incremental improvement desired was to handle the situation of one dominant flow and one policer that enforced per \"customer\" (typically 6G handset or cable subscriber), and that choosing how to guide the end system to distribute the available bandwidth between multiple flows was left \"for further study\".\n",
          "createdAt": "2025-04-23T09:54:56Z",
          "updatedAt": "2025-04-23T09:54:56Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I'm unsure how frequently multipath will be used, but path changes are somewhat common today and may become more common.  There are some deployments of Server Preferred Address, which substantially changes the 5-tuple after the handshake, for example.",
          "createdAt": "2025-05-21T22:15:36Z",
          "updatedAt": "2025-05-21T22:15:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The draft presently says:\n\n> Indicated rate limits only apply to the path on which they are received.  A\nconnection that migrates or uses multipath {{?QUIC-MP=I-D.ietf-quic-multipath}}\ncannot assume that rate limit indications from one path apply to new paths.\n\nI think that is enough.",
          "createdAt": "2025-07-07T09:36:01Z",
          "updatedAt": "2025-07-07T09:36:01Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree. The multipath draft ended up saying something very similar about congestion control.",
          "createdAt": "2025-07-07T14:20:39Z",
          "updatedAt": "2025-07-07T14:20:39Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "I also think the current text in the draft should be fine.",
          "createdAt": "2025-07-07T15:00:30Z",
          "updatedAt": "2025-07-07T15:00:30Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "LGTM",
          "createdAt": "2025-07-07T15:15:21Z",
          "updatedAt": "2025-07-07T15:15:21Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDON1dwo86zaAay",
      "title": "CID rotation and Trone",
      "url": "https://github.com/ietf-wg-scone/scone/issues/27",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "QUIC stacks will commonly \"rotate\" the connection identifiers used on a given path. Assume a connection obtained Trone information with the old connection ID. Is it still valid with the new one?",
      "createdAt": "2025-04-22T05:43:10Z",
      "updatedAt": "2025-07-28T08:47:23Z",
      "closedAt": "2025-07-28T08:47:23Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the endpoint that received the signal considers the path to be the same, then it still applies.  Worth noting, but not particularly difficult to reason about.",
          "createdAt": "2025-04-22T07:21:04Z",
          "updatedAt": "2025-04-22T07:21:04Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's again really a question about expectation and enforcement. Per 4-tuple, or per combination of 4-tuple and CID? What about DS marks? ",
          "createdAt": "2025-04-22T18:08:24Z",
          "updatedAt": "2025-04-22T18:08:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't expect different DS markings to be applied to the same flow, but it's worth a note.  Maybe one that says \"if you use multiple DSCP markings, the throughput advice you receive from packets with one marking might not apply if packets are marked differently\".",
          "createdAt": "2025-04-23T01:44:54Z",
          "updatedAt": "2025-04-23T01:44:54Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDON1dwo860w1A_",
      "title": "How hard can network elements throttle connections that seemingly abuse SCONE?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/29",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some of the interesting comments last meeting I've heard are:\n* Network elements can track usage per user and punish users or connections of such users that seemingly abuse SCONE, more so than users / connections that do not use SCONE at all.\n* Web browsers might expose SCONE rate signals to JavaScript so that JavaScript can make the decision regarding what to fetch next.\n\nI am concerned if we can allow both at the same time. I doubt that, if web browsers are going to expose SCONE rate signals to JavaScript, then there'd be a non-negligible probability of misuse (either intentional or accidental), and that we'd not want to punish web browsers for such mistakes.",
      "createdAt": "2025-04-30T22:35:36Z",
      "updatedAt": "2025-05-05T14:40:12Z",
      "closedAt": "2025-05-05T14:40:12Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, my preference would be to acknowledge that such misuse can happen ~~by accident~~, and RECOMMEND network elements just fall back to CC-based throttling as if the flow was not using SCONE at all.",
          "createdAt": "2025-04-30T22:42:53Z",
          "updatedAt": "2025-04-30T22:48:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, there is no way in which we can guarantee that an application will treat the *advice* as a limit.  Not only because they don't know about it, even if the stack they use has the necessary hooks.  There's no way to guarantee compliance other than via enforcement.  It's almost nonsensical that we're contemplating writing that down, but if there is any doubt, and some words might lay that to rest, sure.",
          "createdAt": "2025-04-30T22:54:04Z",
          "updatedAt": "2025-04-30T22:54:04Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point I was trying to make in the meeting was that there is no clear way to define what abuse of a SCONE signal means because there are different reasons for sending throughput advice and each operator will ultimately define its own enforcement policies.\n\nThe video throttling case is the one where we might see operators turning off policers while monitoring bitrates over some period; detecting non-conformance here should likely just result in fallback to the original throttling policy. Networks should expect to see this happen and I wouldn't necessarily call it abuse or misuse. That short flows might avoid getting throttled in this case is a feature imo.\n\nFor enforcement of subscriber-level data rate caps I don't think operators will turn off policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.",
          "createdAt": "2025-05-01T00:16:27Z",
          "updatedAt": "2025-05-01T00:30:40Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> there is no way in which we can guarantee that an application will treat the _advice_ as a limit\n\n+1\nThis is the most important point, as long as this is clear enough I don't think we should spend much time on discussing potential abuses and mitigations. \n",
          "createdAt": "2025-05-01T00:20:54Z",
          "updatedAt": "2025-05-01T00:21:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For enforcement of subscriber-level data rate caps I don't think operators will turn of policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.\n\nThey already do. My ISP does throttle the uplink connection to 20Mbps, even if the hardware would allow 50. That is prevalent enough that BBRv1 had special code to recognize these throttlers and avoid tripping them.\n\n",
          "createdAt": "2025-05-01T00:27:13Z",
          "updatedAt": "2025-05-01T00:27:13Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > For enforcement of subscriber-level data rate caps I don't think operators will turn of policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.\n> \n> They already do. My ISP does throttle the uplink connection to 20Mbps, even if the hardware would allow 50. That is prevalent enough that BBRv1 had special code to recognize these throttlers and avoid tripping them.\n\nThat's what I meant: they use policers now, and even with SCONE in place, I think they'll continue to enforce bitrates using policers.",
          "createdAt": "2025-05-01T00:32:49Z",
          "updatedAt": "2025-05-01T00:32:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you folks, I think we are more or less on the same page?\n\n>> there is no way in which we can guarantee that an application will treat the advice as a limit\n>\n> +1\n> This is the most important point, as long as this is clear enough I don't think we should spend much time on discussing potential abuses and mitigations.\n\n+1 that this is the most important point. But I continue to think that we should be more clear what it means to network operators; i.e., that if you handle flows that exchange SCONE signals but do not adhere to them differently than non-SCONE flows, that might lead to unexpected behaviors.\n\nPlease see #30.",
          "createdAt": "2025-05-01T01:22:58Z",
          "updatedAt": "2025-05-01T01:22:58Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDON1dwo862PkrX",
      "title": "Scope is restricted to 'rate limiting' networks only",
      "url": "https://github.com/ietf-wg-scone/scone/issues/32",
      "state": "OPEN",
      "author": "Kevsy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "propose-no-action"
      ],
      "body": "draft-00 does not include the use of SCONE by networks that do not apply rate limit policies. For example, a cellular network that provides throughput advice based on its view of network congestion and channel conditions.  I've drafted PR which adds that as a use of SCONE, and hence changes 'rate limit signal' to throughput advice' throughout:  #31",
      "createdAt": "2025-05-12T16:38:30Z",
      "updatedAt": "2025-07-23T16:08:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aside from a few tweaks (I don't think we need to update the abstract or expand too much on why a network might want to send the advice) I'm OK with making changes along these lines.  The details matter and the change is fairly far-reaching, but it's not as large a change as it seems at first glance.",
          "createdAt": "2025-05-13T04:29:07Z",
          "updatedAt": "2025-05-13T04:29:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Belay that.  On a second more thorough pass, the suggestion that this provide information about congestion is something that should be taken to the list.  Thus far, my understanding is that we agreed (several times) that there needed to be a bright dividing line between congestion signals (like ECN) and throughput advice (SCONE).  This change seems to be aimed at erasing that line.",
          "createdAt": "2025-05-13T04:44:02Z",
          "updatedAt": "2025-05-13T04:44:02Z"
        },
        {
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @martinthomson and @huitema for the review and suggestions: limiting the PR to (1) changing 'rate limit signals' to 'throughput advice signals', and (2) including your amended text that allows cases beyond conveying rate limiting policy, is fine by me. \n\nI've applied the suggested commits accordingly to make that clearer, reverting the contentious parts.",
          "createdAt": "2025-05-13T10:53:23Z",
          "updatedAt": "2025-05-13T10:53:23Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "It would seem to me that a perfectly legitimate use of SCONE is to signal that \"you are connected via a 10 Mbit/sec Ethernet-over-copper connection, no matter what else happens, your throughput won't get higher than 10 Mbit/sec\".\n\nCongestion (the normal kind) changes too fast to be worth signalling.",
          "createdAt": "2025-05-15T08:44:41Z",
          "updatedAt": "2025-05-15T08:44:41Z"
        },
        {
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(answering from a cellular perspective)\n\n> It would seem to me that a perfectly legitimate use of SCONE is to signal that \"you are connected via a 10 Mbit/sec Ethernet-over-copper connection, no matter what else happens, your throughput won't get higher than 10 Mbit/sec\".\n\nYeah, I was also thinking indoor cellular (constrained 800Mhz) and cell edge, i.e. conditions unlikely to change for the duration of a video session. \n\n> Congestion (the normal kind) changes too fast to be worth signaling.\n\n+1, at least for now. Radio channel conditions are signaled constantly to the radio access network, but they are ephemeral and not shared to the core in real time. So 'rapidly changing urban environment' signal strength is not worth attempting to convey at this stage, but as mentioned above, there could be a way to determine when a signal strength (and hence throughput constraints) are likely to last for the session.   ",
          "createdAt": "2025-05-15T09:00:30Z",
          "updatedAt": "2025-05-15T09:00:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that we're in good shape already here.  Those networks that have changing conditions can use whatever opportunities they get to update advice.  There's advice we need to give about how often to make it possible to update advice; we can take that into account there.",
          "createdAt": "2025-07-07T09:38:33Z",
          "updatedAt": "2025-07-07T09:38:33Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDON1dwo866MLaS",
      "title": "Provide rationale for signaling rates beyond those enforced by congestion control",
      "url": "https://github.com/ietf-wg-scone/scone/issues/33",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft jumps straight into the SCONE mechanism without first explaining *why* an operator would want an explicit long-term-rate signal at all. Adding a short, non-normative \u201cMotivation\u201d paragraph would give readers, _including the operators of neutral-connectivity networks_, better context.\n\nThe paragraph can cover:\n* **Short-term fairness of congestion control.**\nModern CC algorithms equalise throughput only among flows that are simultaneously backlogged.\n\n* **Long-term unfairness between flow types.**\nWhen an always-on bulk transfer (e.g., software update or congested video) shares a path with an intermittent or bursty flow, the bulk flow can send far more data over wall-clock time than the intermittent flow, despite CC\u2019s short-term fairness.\n\n* **SCONE as the improvement.**\nSCONE lets network elements declare their desired long-term rate in-band, giving operators a transparent, standards-based tool for achieving long-horizon fairness\u2014without heuristic classification or DPI.",
      "createdAt": "2025-06-06T06:08:55Z",
      "updatedAt": "2025-07-07T23:35:08Z",
      "closedAt": "2025-07-07T23:35:08Z",
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDON1dwo866zI50",
      "title": "Include semantics definition of the \u201cthroughput advice\u201d  in the merged draft with clarifications on what it means and how it can be measured by CSPs and CAPs",
      "url": "https://github.com/ietf-wg-scone/scone/issues/34",
      "state": "OPEN",
      "author": "DanDruta",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "propose-no-action"
      ],
      "body": "Current merged draft talks about rate limit signals and throughput advice but it falls short of defining what that is and more importantly how it gets computed so both CSPs and CAPs have a common understanding of the meaning as well as measure it.\nSuggest adding a section  to provide clarity. For reference the scone video session data rate  draft https://datatracker.ietf.org/doc/html/draft-druta-scone-video-session-data-rate-00",
      "createdAt": "2025-06-10T15:06:26Z",
      "updatedAt": "2025-07-23T16:11:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe that this is largely addressed by the fixes in #37.  It doesn't have nice pictures, but I don't know that pictures are necessary for something as simple as \"bits transferred over a period of time\".  It does have code.",
          "createdAt": "2025-07-08T07:27:39Z",
          "updatedAt": "2025-07-08T07:27:39Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDON1dwo866_-BB",
      "title": "Aggregate or Per-Flow Measurement?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/35",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "propose-no-action"
      ],
      "body": "At the June 11 2025 interim, Marcus mentioned that some operators enforce bit rates on a per-flow basis and others aggregate flows, and (in my perception) implied that we should not try to discourage them from either approach.\n\nI have no opinion on the merits of that implication. However, if SCONE network elements are allowed to enforce on an aggregate basis, it seems critical for interoperability to have a signal in SCONE packets indicating which mode it's in.\n\n@kazuho had a response in the meeting that rate control should be on a per-flow basis, because aggregate rates are not always actionable.",
      "createdAt": "2025-06-11T15:49:23Z",
      "updatedAt": "2025-08-06T00:29:16Z",
      "closedAt": "2025-08-06T00:29:16Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I will note, FWIW, that the charter specifically refers to \"UDP 4-tuples\", not flow aggregates.",
          "createdAt": "2025-06-11T15:57:14Z",
          "updatedAt": "2025-06-11T15:57:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whatever the charter says, I will argue that what is in the draft is the right answer.  Is there something there that you think we need to change?  Please review https://ietf-wg-scone.github.io/scone/draft-ietf-scone-protocol.html#section-3.2",
          "createdAt": "2025-07-23T16:07:19Z",
          "updatedAt": "2025-07-23T16:07:19Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, the current text is saying the right thing. \nOperators might or might not enforce per-flow throughput, regardless of what we were to write in the document.\nMaking the document more specific on this would be misleading. ",
          "createdAt": "2025-07-23T17:42:28Z",
          "updatedAt": "2025-07-23T17:44:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "Regarding \"might or might not, .. regardless of what we write\" - I find this strange. Surely a bit that says \"this is definitely per-flow\" would only be set by people who really are sure that that's always the case? and why wouldn't that be useful information to have?",
          "createdAt": "2025-07-27T08:30:53Z",
          "updatedAt": "2025-07-27T08:30:53Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl per 4 tuple enforcement makes sense in some cases, but most contractual arrangements are per subscription, so we have to expect that this will be the level of enforcement in many cases. Not a 4 tuple. Probably more like a subscriber IP address. Then we have to consider green-lighting, which typically be set by server IP, maybe resulting in enforcement by pairs of IP address. Whatever we write, contractual arrangements are going to matter more.",
          "createdAt": "2025-07-27T15:24:09Z",
          "updatedAt": "2025-07-27T15:24:09Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "I get that - I'm just arguing for (well, really: testing the waters for) a \"this is definitely per-flow\" bit which would often be 0, as per your explanation. Right now, we don't know what devices might be doing SCONE at some point in the future.",
          "createdAt": "2025-07-27T17:36:01Z",
          "updatedAt": "2025-07-27T17:36:01Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Looking at Sec 3.2 as recommended by @martinthomson, I'm happy to close this issue.",
          "createdAt": "2025-07-28T14:21:35Z",
          "updatedAt": "2025-07-28T14:21:35Z"
        },
        {
          "author": "wesley-eddy",
          "authorAssociation": "NONE",
          "body": "I think the envisioned usage is per-flow, since the focus problem motivating SCONE is the throttling of video traffic in mobile networks to specific qualities/rates (which are indicated specifically for video in subscription plans, not aggregate rates).",
          "createdAt": "2025-08-04T13:06:30Z",
          "updatedAt": "2025-08-04T13:06:30Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I'm fine with the existing text (and close the issue). I don't think there is more we can say; we can't enforce anything and the rate advise is always just an upper limit and does not replace congestion control. If you have multiple flows \"competing\" for the same rate limit, that's simply congestion and you need congestion control to figure out a rate share. The scone signal is simply telling you, that you don't even need to try a higher rate than this. That signal is equally true not matter how many flow are shaped to the same max rate.",
          "createdAt": "2025-08-05T17:03:39Z",
          "updatedAt": "2025-08-05T17:03:39Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDON1dwo86_xdZD",
      "title": "Make suggestions about how to maintain limits",
      "url": "https://github.com/ietf-wg-scone/scone/issues/39",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Do we want to talk about approaches other than asking the peer to rate-limit, such as:\r\n* the endpoint selecting different resources (like video chunks), or\r\n* using flow control to limit the amount of data being sent by the peer?\r\n\r\n_Originally posted by @kazuho in https://github.com/ietf-wg-scone/scone/pull/37#discussion_r2194954920_",
      "createdAt": "2025-07-09T23:30:33Z",
      "updatedAt": "2025-07-23T07:50:08Z",
      "closedAt": "2025-07-23T07:50:08Z",
      "comments": []
    },
    {
      "number": 41,
      "id": "I_kwDON1dwo87Bb0p1",
      "title": "value of the scone_supported transport parameter",
      "url": "https://github.com/ietf-wg-scone/scone/issues/41",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the draft is silent regarding what the value of the scone_supported parameter should be.\n\nAssuming that this parameter is boolean, I believe the value should be zero-length, like the disable_active_migration TP defined in RFC 9000.",
      "createdAt": "2025-07-19T13:08:41Z",
      "updatedAt": "2025-07-28T08:45:52Z",
      "closedAt": "2025-07-28T08:45:52Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, zero length is the simplest.",
          "createdAt": "2025-07-19T22:06:44Z",
          "updatedAt": "2025-07-19T22:06:44Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDON1dwo87Bb9T5",
      "title": "Mention UDP checksum update",
      "url": "https://github.com/ietf-wg-scone/scone/issues/42",
      "state": "CLOSED",
      "author": "wesley-eddy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think in the protocol spec it would be good to include a specific reminder for network elements to update the UDP checksum.\n\nIf a network element updates the rate guidance in a SCONE packet, it MUST adjust the UDP checksum accordingly.  The efficient incremental update approach can be used (based on the old and new rate guidance values), rather than recomputing across the entire packet.  It MUST NOT zero the checksum.",
      "createdAt": "2025-07-19T14:08:55Z",
      "updatedAt": "2025-07-28T08:35:45Z",
      "closedAt": "2025-07-28T08:35:45Z",
      "comments": []
    },
    {
      "number": 43,
      "id": "I_kwDON1dwo87B3nf3",
      "title": "Don't require an update to every packet",
      "url": "https://github.com/ietf-wg-scone/scone/issues/43",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "One equipment vendor requested that we not require network elements to update every packet.  This seems reasonable to me.\n\nA proposed option here is that endpoints retain the lowest throughput advice received over the XX second window that we have for enforcement.  There is no sense in changing any faster than that, because it is possible that senders will have already consumed the available bandwidth at the start of any given window.\n\nThis increases the load on any endpoint because it means that you have to retain the time at which advice was last refreshed at a given level.  You might also have to retain advice at higher levels (though this is not mandatory, it would allow you to take advantage of an increase in the advice more quickly).  That seems pretty modest as far as I'm concerned.",
      "createdAt": "2025-07-22T12:54:50Z",
      "updatedAt": "2025-07-23T16:04:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe dumb question: how is it better than discouraging endpoints sending SCONE packets more frequently than once per Y seconds?\n\nThe complexity for network elements would be the same, as these network elements have to skip modifying SCONE packets showing up too frequently, regardless of the solution.\n\nFor endpoints, retaining state to calculate the min for XX seconds sounds more complicate than having a timer to control how frequent they send SCONE packets.",
          "createdAt": "2025-07-22T15:30:23Z",
          "updatedAt": "2025-07-22T15:30:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't this tied to the debate about enforcement period? The discussion in the WG seemed to go along the following lines:\n\n- multimedia applications have variable data rate, peaks followed by lower level of traffic;\n- to give them flexibility, bandwidth usage should be averaged over a long period, maybe 120 seconds;\n- if enforcement is over 120 seconds, it follows that the advice is good for that period;\n- if advice only changes every 120 seconds, Nyquist's theorem says that the advice should be sampled at least every 60 seconds.\n\nOf course, Nyquist says that, but if we accept that network elements will sometimes let the packets pass without touching them, we should recommend probing a bit more frequently and filtering advice at the receiving endpoint, such as \"min of the last 3 values\". That would mean sampling at least every 20 seconds.\n\nThen we should notice that it is probably better to send the packet at random intervals to avoid synchronized peaks of load for the intermediate elements. I would thus recommend sending the SCONE packets at random intervals between 10 and 20 seconds.\n\nEndpoints may want to send the SCONE packets sooner than the expected interval if they notice a change in network conditions, such as a congestion event. But there is of course the risking of noticing that wrong, and then repeat probing at too short intervals. \n",
          "createdAt": "2025-07-22T19:21:56Z",
          "updatedAt": "2025-07-22T19:21:56Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "If the network marks only some SCONE probe packets, the endpoints will send more of them in order to get the signal they want. Seems like a destructive strategy to me.\n",
          "createdAt": "2025-07-22T21:10:46Z",
          "updatedAt": "2025-07-22T21:10:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All of this (Nyquists theorem etc) should be addressed in the pull requests.  Note that the pull requests are all stacked.",
          "createdAt": "2025-07-23T16:04:22Z",
          "updatedAt": "2025-07-23T16:04:22Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDON1dwo87CDjOr",
      "title": "create a 7-bit rate signal field, by allocating two QUIC versions that differ only with MSB",
      "url": "https://github.com/ietf-wg-scone/scone/issues/45",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "SCONE uses a 7-bit value (128 code points) for representing the rate signal.\n\nAt the moment, the most significant bit of the rate signal affects the selection of the QUIC version, and the rest of the bit is stored in the first byte of the datagram.\n\nThis construction is sub-optimal and is a pain in terms of both specification and implementation.\n\nI propose to allocate two QUIC versions that are identical for all bits expect the most significant bit.\n\n```\nSCONE Packet {\n  Header Form (1) = 1,\n  Reserved (1),\n  Rate Signal (7),\n  Common Bits of SCONE Versions (31) = 0xSCONE1 & 0x7fffffff,\n  Destination Connection ID Length (8),\n  Destination Connection ID (0..2040),\n  Source Connection ID Length (8),\n  Source Connection ID (0..2040),\n}\n```\n\nWith this change, detecting SCONE packets becomes as simple as `(first64bit & 0xc07f_ffff_ffff_ffff) == (0xc000_0000_0000_0000 | (0xSCONE1 << 24))`, and the rate signal becomes a 7-bit value that can be directly processed (without looking up different base values based on the QUIC version).",
      "createdAt": "2025-07-23T09:54:43Z",
      "updatedAt": "2025-07-23T15:53:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can certainly select version numbers with that pattern.  That's easy.",
          "createdAt": "2025-07-23T15:53:26Z",
          "updatedAt": "2025-07-23T15:53:26Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDON1dwo87EjfiH",
      "title": "Dynamic update of rate-signal field by network element - Needs clarity in draft to specify the server, client and n/w element requirements",
      "url": "https://github.com/ietf-wg-scone/scone/issues/55",
      "state": "OPEN",
      "author": "anooptomar29",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some related aspects are covered in https://github.com/ietf-wg-scone/scone/issues/24, https://github.com/ietf-wg-scone/scone/issues/43 and https://github.com/ietf-wg-scone/scone/issues/6. However draft still lacks clarity to specify the role of server, client and n/w element to support Dynamic update of rate-signal field by network element. \n\nOne of the CSPs/equipment provider is looking for more clarity in the draft doc to cover following aspects;\n\nA. What is the periodicity of server sending SCONE packet coalesced with QUIC packet ?\n\nThis clarity will help in analyzing how fast new bit-rates can be configured in apps whenever there is a need to change the bit-rate for a flow due to any trigger in CSP n/w \n\n================================================================\nB. If the Server is sending SCONE packets with very high frequency/periodicity and if network element (PGW/UPF) does want to update the rate-signal field with for each and every SCONE packet (if there is no change in previously sent bit-rate for the subscriber) to avoid CPU usage.   How this can supported by server and client is not clearly specified in the draft. \n\nReason for asking clarification B;  In below section sec 7.1  it is stated that ***A network element might receive a packet that already includes a rate signal*** !! Does it mean that client is expected to inform server about the bit-rate it has received from n/w element and server is required to send the updated bit-rate in subsequent scone packets ? \n \nPer IETF Sec 7.1:\n \n  A network element then conditionally replaces the Version field and\n   the Rate Signal field with values of its choosing.\n \n   ****A network element might receive a packet that already includes a rate\n   signal**.**  The network element replaces the rate signal if it wishes to\n   signal a lower rate limit; otherwise, the original values are\n   retained, preserving the signal from the network element with the\n   lower policy\n \n ===========================================================\nFor e.g. can we specify following in the draft to bring clarity to B. \n\n\n- By default, Server to set rate-signal field to a value which is not valid for the client. However client is expected to inform server about the bit-rate it has received from n/w element and server is required to send the updated bit-rate in subsequent scone packets \n- Client to use whatever rate-signal value present in last received SCONE packet and stop using the value received in the past. \n\nOR,  if above is not the case  ( i.e if client is not required to update the server about the bit-rate and server is not required to set the rate-signal field to this updated value) can we specify following ; \n\n - Server to set rate-signal field to a value in every scone packet which is not valid for the client \n- And client to ignore the rate-signal field if rate-signal is set to this invalid value.(For e.g. 63) and continue to use previously received valid rate-signal value. \n\nWith this clarity in draft,  n/w element providers would get the clarity that \n1. If they don't update subsequent scone packets during the life time of the flow,  application continues to use bit-rate that was sent by n/w element initially. \n\n\n  ",
      "createdAt": "2025-08-06T18:23:43Z",
      "updatedAt": "2025-08-08T23:17:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The pull requests answer Question A.\n\nThe network element needs to ensure that they send at least once every enforcement period (67s in the PR presently).  Because they do not control opportunities, they should try to update a small number of packets over that period.  I would go with every 20-30s based on that, but there is flexibility.\n\nQuestion B is answered in #46.\n\nThe current design requires that network elements update every SCONE packet they see, which is likely impractical.  At a minimum, there is a chance that the network element misses a packet. ECMP might virtually guarantee this for some network elements.\n\nThat's not the same as saying you have to update less often: if a network element can update every packet in a flow, then there is no harm in doing that.\n\n#46 proposes a change so that:\n\n1. Increases in rate take effect once the lower rate limit expires, which happens after one enforcement period.\n2. Reductions in rate take effect immediate, but with no memory of previously expended capacity.\n\nIn practice, a network element cannot expect reductions in rate to take effect before the enforcement period lapses because we don't prevent traffic spikes and all the capacity might already have been spent.  This is also why the first item has no memory (there's an analogy to workforce reductions/firing, where firing people almost always costs more in the short term than keeping them on payroll...)\n\nIncreases are simpler: they can't be immediate, because another network element might have asked the sender to use a lower limit and that might still be active.\n\nSo, no, I don't think that we can \"clarify\" in the ways you suggest.  Reactions to changes, no matter how fast they are *signaled* need to fit the above constraints.  Even if network elements are able to constantly signal (we've established that some cannot), there is no way to have *reductions* take immediate effect.  The only thing that might help with is an increase in rate.\n\n> If they [network element, I assume] don't update subsequent scone packets during the life time of the flow, application continues to use bit-rate that was sent by n/w element initially.\n\nI can't see how this is consistent with what you are asking for.  If you fail to update a packet, that's the same as the network signaling \"unlimited\" bandwidth, or that SCONE is not supported (any more).\n",
          "createdAt": "2025-08-07T06:26:17Z",
          "updatedAt": "2025-08-07T06:26:17Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> The pull requests answer Question A.\n> \n> The network element needs to ensure that they send at least once every enforcement period (67s in the PR presently). Because they do not control opportunities, they should try to update a small number of packets over that period. I would go with every 20-30s based on that, but there is flexibility.\n> \n> Question B is answered in [#46](https://github.com/ietf-wg-scone/scone/pull/46).\n> \n> The current design requires that network elements update every SCONE packet they see, which is likely impractical. At a minimum, there is a chance that the network element misses a packet. ECMP might virtually guarantee this for some network elements.\n> \n> That's not the same as saying you have to update less often: if a network element can update every packet in a flow, then there is no harm in doing that.\n> \n> [#46](https://github.com/ietf-wg-scone/scone/pull/46) proposes a change so that:\n> \n> 1. Increases in rate take effect once the lower rate limit expires, which happens after one enforcement period.\n> 2. Reductions in rate take effect immediate, but with no memory of previously expended capacity.\n> \n> In practice, a network element cannot expect reductions in rate to take effect before the enforcement period lapses because we don't prevent traffic spikes and all the capacity might already have been spent. This is also why the first item has no memory (there's an analogy to workforce reductions/firing, where firing people almost always costs more in the short term than keeping them on payroll...)\n> \n> Increases are simpler: they can't be immediate, because another network element might have asked the sender to use a lower limit and that might still be active.\n> \n> So, no, I don't think that we can \"clarify\" in the ways you suggest. Reactions to changes, no matter how fast they are _signaled_ need to fit the above constraints. Even if network elements are able to constantly signal (we've established that some cannot), there is no way to have _reductions_ take immediate effect. The only thing that might help with is an increase in rate.\n> \n> > If they [network element, I assume] don't update subsequent scone packets during the life time of the flow, application continues to use bit-rate that was sent by n/w element initially.\n> \n> I can't see how this is consistent with what you are asking for. If you fail to update a packet, that's the same as the network signaling \"unlimited\" bandwidth, or that SCONE is not supported (any more).\n\n\n\n> The pull requests answer Question A.\n> \n> The network element needs to ensure that they send at least once every enforcement period (67s in the PR presently). Because they do not control opportunities, they should try to update a small number of packets over that period. I would go with every 20-30s based on that, but there is flexibility.\n\n>> Few points: \n\n1. Not sure why there is an enforcement period for the n/w element to update the scone pkt ?  \n\nProtocol draft shall provide the option to network element (PGW/UPF), that it is not expected from n/w element to update the rate-signal field for each and every SCONE packet (if there is no change in previously sent bit-rate for the subscriber) to optimize the n/w element CPU usage. \nThis point is related to Question B. \n\nEnforcement period shall be enforced for the server to ensure server sends scone packet with a periodicity which allows timely update of bit-rate( to address the case when n/w element wants to send updated bit-rate to client). \nAdditionally refer below point that also puts additional requirement on enforcement period. \n\n2. At present, protocol draft does not all n/w element to insert scone packet so it has to rely on SCONE packets sent by the server.  Since there is no ack mechanism specified in protocol draft so in order to address potential packet loss scenario b/w n/w element and client, n/w element may want to send scone packet (with advised bit-rate) more than once (at-least 3-4 retx or whatever makes sense) in quick succession. It seems to me that gap of 67 sec ( or 20-30 sec) is bit too long between 2 successive retx attempts ? To address this , should we rethink of adding ack ? or what other options do we have ? \n\n3. I am not sure what is the relation (inter dependency) between time_window duration and scone enforcement period?",
          "createdAt": "2025-08-08T21:51:39Z",
          "updatedAt": "2025-08-08T21:51:39Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> I can't see how this is consistent with what you are asking for. If you fail to update a packet, that's the same as the network signaling \"unlimited\" bandwidth, or that SCONE is not supported (any more).\n\nSorry, it seems, I was not clear. Let me try to explain the requirement clearly.\n\n- Server to set rate-signal field to a value which suggests \"no-action\" (SCONEv2 this value is 63 and we should reserve 63 for SCONEv1 also i.e, no-action)\n\n- Client to ignore the rate-signal field if rate-signal is set to no-action.(For e.g. 63) and client to continue to use previously received valid rate-signal value, if any.\n\n- N/w element to update the rate-signal field only when it needs to send a value other than 63 or when it needs to send updated bit-rate value (which is different from the value that was sent by the n/w earlier)\n\nAdding an example below to make it clear;\n\n- Connection gets established\n- Server sends SCONE packet. rate-signal = 63 (scone v1 or scone v2 )\n- N/w element updates rate-signal to some value say 15. rate-signal (n)= 15 ( and for e.g scone version = version 1)\n- N/W element updates a few subsequent scone pkts to update rate-signal (n)= 15 to do proactive retx to address potential pkt loss\n- Client reads scone pkt and calculates bit-rate based on n = 15 and performs self-adaptation\n- Server keeps sending SCONE packet. rate-signal = 63 (scone v1 or scone v2 )\n- N/w element does not update SCONE pkt as it does not want to change the bit-rate\n- Client receives SCONE packet. rate-signal = 63 (scone v1 or scone v2 ) i.e no-action\n- Client keeps using bit-rate based on n = 15 and keeps perform self-adaptation\n- Some point in time during the ongoing media flow, n/w element needs to update bit rate value to lower or higher value. In this case, n/w element waits for next SCONE pkt from server and updates rate-signal field to new value say 10.\n- Client reads scone pkt and calculates bit-rate based on n = 10 and performs self-adaptation .\n\nThis way , protocol provides the flexibility to n/w element to not to update every scone pkt if there is no need (to optimize CPU usage). And if some n/w element/s wants to update every scone pkt (I am not sure why) then they can do it w/o any change in the final outcome.\n\nOnly open question is ( question A) - What is the frequency at which server is required to send SCONE pkt ? And this should consider ability to support retx of scone pkts with updated bit-rate by the n/w element whenever there is a change in the bit-rate.\n\nIf we ignore retx requirement, frequency at which server is required to send SCONE, is not required to be very high. May be we want to address retx issue by adding ack based retx instead of proactive retx !!",
          "createdAt": "2025-08-08T23:16:47Z",
          "updatedAt": "2025-08-08T23:17:57Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDON1dwo87Ej4nt",
      "title": "Clarification on Enforcement of Notable Values for Rate Signal and Bit-Rates",
      "url": "https://github.com/ietf-wg-scone/scone/issues/56",
      "state": "OPEN",
      "author": "udaykiranbokam",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\nWe are currently evaluating the IETF specifications related to Rate Signal and bit-rates, specifically the Notable values defined therein. We would like to clarify whether these Notable values are intended as strict, hard-enforced limits or if they serve merely as recommendations or suggestions.\n\nOne of our CSP's are interested in using bit-rate values that differ from the Notable values listed in the IETF documents. Before proceeding, we want to understand if deviating from these values would be compliant or if it might cause interoperability or compliance issues.\n\nCould you please clarify on:\n\n1. Are the Notable values for Rate Signal and bit-rates in the IETF specifications mandatory to implement as-is?\nOr are they flexible guidelines that can be adjusted based on specific use cases or operator requirements?\n\n2. Will the Client and Server owners follow the logarithmic scale to derive the bit-rate sent in SCONE packet if the rate-signal value is not as per the table defined in IETF. \n\n",
      "createdAt": "2025-08-06T18:59:59Z",
      "updatedAt": "2025-08-08T00:17:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are 63 different values that can be signaled and the mapping from the signal to the rate signal is fixed by the exponential formula in the document.  You can't signal any other values.\n\nTo be fair, I'm not sure that \"Notable\" is the right characterization of these.  The values in the table are just examples.  They aren't much good for anything other than testing your code, if you are into that sort of thing.",
          "createdAt": "2025-08-07T08:37:38Z",
          "updatedAt": "2025-08-07T08:37:38Z"
        },
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> To be fair, I'm not sure that \"Notable\" is the right characterization of these. The values in the table are just examples. They aren't much good for anything other than testing your code, if you are into that sort of thing.\n\nI think \"notable\" word can be confusing. Changing it to \"example\" may avoid the confusion. ",
          "createdAt": "2025-08-08T00:17:28Z",
          "updatedAt": "2025-08-08T00:17:28Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDON1dwo86MqU5p",
      "title": "Transparent Rate Optimization for Network Endpoints (TRONE)",
      "url": "https://github.com/ietf-wg-scone/scone/pull/3",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An attempt at TRONE.\r\nWe can bikeshed the name in #2.\r\n\r\nThe PR uses TRAIN as a baseline so that it's easier to review the changes from TRAIN.\r\nNote that this version changes the rate signal field to a field with explicit values, located after the CIDs.\r\nIf we're very unsure about the design tradeoffs we could consider doing both the TRAIN and TRONE ways as discussed in #1.\r\n\r\nThere's also a discussion on how network elements are capable of crafting TRONE packets. ",
      "createdAt": "2025-02-26T15:03:17Z",
      "updatedAt": "2025-03-05T13:18:41Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "b568f3314171b26d5bc38891e21c4f5f714a4c55",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "advice-format",
      "headRefOid": "946f94dac013f33e4c29520a5bdcb13f877e212c",
      "closedAt": "2025-03-03T17:42:04Z",
      "mergedAt": "2025-03-03T17:42:04Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "681b12c446391332da002b4b3cf33a0d51ab3f64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86d7v0C",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T04:25:32Z",
          "updatedAt": "2025-02-28T04:25:33Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Even if I thought that this was necessary, this is probably not the right logic to use here.  You are going to independently reduce the rate and window size.  If you don't reduce one, but you reduce the other, that is sometimes going to reduce the actual send rate below your target.  That's another reason I don't like this design.",
              "createdAt": "2025-02-28T04:25:33Z",
              "updatedAt": "2025-02-28T04:25:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86d9h0k",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T09:02:21Z",
          "updatedAt": "2025-02-28T09:02:21Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Yeah, composability makes this solution a bit messy. I've been a bit back and forth on this.  My original thinking was to only check the rate and update the window unconditionally:\r\n`if packet_rate == 0 or target_rate < packet_rate:`\r\n`    write_uint32(packet[offset : offset + 4], target_rate)`\r\n`    write_uint32(packet[offset + 4 : offset + 8], target_aw)`\r\n\r\n    \r\nThat could lead to the sending of bursts that are not tolerated by the element further upstream. \r\nIt might be the least messy thing to do with this design though. (And I still think the case with chained elements who wish to signal rates is a rather exceptional one).",
              "createdAt": "2025-02-28T09:02:21Z",
              "updatedAt": "2025-02-28T13:10:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eFfDm",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T04:40:27Z",
          "updatedAt": "2025-03-01T04:40:27Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Thank for getting together baking this draft among authors, thanks for Martin to enage this discussion, I am wondering\r\nIs there possible to leave this as one open issue or split it from PR#3 and move to new PR. \r\nI hope we can have one posted version before submission deadline, let us know what we can do to help move the way forward.",
              "createdAt": "2025-03-01T04:40:27Z",
              "updatedAt": "2025-03-01T04:40:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eF4Fl",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T07:53:46Z",
          "updatedAt": "2025-03-01T07:53:47Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "The latest commit contains an update in response to Martin's comment, fixing the logic so that average window is not updated separately from updating the rate limit. Which is probably the right thing to do, given this design. \r\n\r\nThere is a larger issue around the structure and placement of the rate signal, something the WG needs to resolve. I would hope that the merged document can contain the latest commit and then we have the broader discussion as an open issue, see #1 for instance. ",
              "createdAt": "2025-03-01T07:53:46Z",
              "updatedAt": "2025-03-01T07:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eOFsQ",
          "commit": {
            "abbreviatedOid": "2b0ef2f"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T15:35:01Z",
          "updatedAt": "2025-03-03T15:35:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86enOJN",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T13:18:41Z",
          "updatedAt": "2025-03-05T13:18:41Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "To be clear, I did not approve this document.",
              "createdAt": "2025-03-05T13:18:41Z",
              "updatedAt": "2025-03-05T13:18:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDON1dwo86P8JWx",
      "title": "Initial attempt at adding version-dependent logarithmic rates",
      "url": "https://github.com/ietf-wg-scone/scone/pull/12",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First pass, expecting there will be further changes needed. There seemed to be general consensus around this approach, which we believe we need to take before an adoption call.",
      "createdAt": "2025-03-24T22:03:34Z",
      "updatedAt": "2025-04-09T05:30:13Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "5764ba5c4c979069d5c841889845133a61fae8c7",
      "closedAt": "2025-04-09T05:30:13Z",
      "mergedAt": "2025-04-09T05:30:13Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "a4f79332ca9e716f7c255932d800191385ef33f4"
      },
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Took all the suggestions and punted some things to issues. Are we okay with this now?",
          "createdAt": "2025-03-27T16:51:01Z",
          "updatedAt": "2025-03-27T16:51:01Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Note the question in #14 - not an objection to merging this PR, but a heads-up that we may want to revisit this.\r\n",
          "createdAt": "2025-03-28T04:28:21Z",
          "updatedAt": "2025-03-28T04:28:21Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @kazuho @martinthomson any further thoughts or are we okay to merge this and iterate?",
          "createdAt": "2025-04-03T15:35:36Z",
          "updatedAt": "2025-04-03T15:35:36Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Who actually has merge approval perms? @britram could I get it provisionally just to h it the button? \ud83d\ude42 ",
          "createdAt": "2025-04-07T20:12:52Z",
          "updatedAt": "2025-04-07T20:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86ho3fT",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR. Looks good overall.",
          "createdAt": "2025-03-24T22:45:22Z",
          "updatedAt": "2025-03-24T23:06:41Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n| 10 | 316 Kbps | 31.6 Mbps |\r\n```",
              "createdAt": "2025-03-24T22:45:22Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 75,
              "body": "I think we do not have these in the proposed encoding? (and IMO we probably do not need them)",
              "createdAt": "2025-03-24T22:46:27Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 89,
              "body": "Do we need this change? Not that it is incorrect, but seems a bit verbose, as the Rate Signal field is defined to be six bits.",
              "createdAt": "2025-03-24T22:48:01Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n```\r\nAs we read `version` from the packet later (see `packet[1..5]`), maybe it makes sense to delay the invocation of `convert_rate_to_signal` after that. Something like below.",
              "createdAt": "2025-03-24T22:51:30Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\npacket_version = packet[1..5]\r\nif is_long and (packet_version == TRONE1_VERSION or packet_version == TRONE2_VERSION):\r\n  target_rate_value = convert_rate_to_signal(target_rate, packet_version)\r\n```",
              "createdAt": "2025-03-24T22:54:25Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nshould signal the minimum value (0) for rates below the range and preserve the\r\noriginal value for rates above the range.\r\n```\r\nWhen there are multiple network elements, the Rate Signal field might convey a value other than 63.",
              "createdAt": "2025-03-24T23:02:53Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-03-24T23:03:14Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Do we want to state that values 0 to 62 represents the ceiling values?",
              "createdAt": "2025-03-24T23:05:53Z",
              "updatedAt": "2025-03-24T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpc5V",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:58:13Z",
          "updatedAt": "2025-03-25T00:58:13Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "You're right I got my wires crossed from my notes.",
              "createdAt": "2025-03-25T00:58:13Z",
              "updatedAt": "2025-03-25T00:58:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpT6C",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:29:04Z",
          "updatedAt": "2025-03-25T01:21:17Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I would not do it this way.  Instead, I would set the target rate value for each version as follows:\r\n\r\n```python\r\nversions = [TRONE_VERSION1, TRONE_VERSION2]\r\ntarget = [63, 63]\r\nfor i in 1..len(versions):\r\n    target[i] = convert_rate(target_rate, versions[i])\r\n\r\n# then when a packet arrives\r\nif packet[0] & 0x80 != 0x80:\r\n    skip\r\ni = find(versions, packet[1..5])\r\nif i is not None and packet[0] & 0x3f > target[i]:\r\n    packet[0] = packet[0] & 0xc0 | target[i]",
              "createdAt": "2025-03-25T00:29:04Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n* Support for both very low bitrates (down to 100 Kbps) and very high bitrates\r\n  (up to 12.5 Gbps)\r\n* Graceful handling of network elements that might only recognize one version\r\n  or some subset of future versions.\r\n```\r\n\r\nThis is unordered.",
              "createdAt": "2025-03-25T00:29:47Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n* When sending TRONE packets, endpoints SHOULD alternate between versions\r\n```\r\nUnordered",
              "createdAt": "2025-03-25T00:30:41Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n* Network elements SHOULD apply appropriate rate signals to all packets that\r\n   include a TRONE version they support.\r\n```",
              "createdAt": "2025-03-25T00:31:45Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 170,
              "body": "We need to talk about rounding.\r\n\r\nIn practice, if the bitrate formula is $r=b * 10^{\\frac{n}{20}}$, the inverse is $n=\\left\\lceil 20 * \\log_{10}(\\frac{r}{b})\\right\\rceil$  or $n=\\left\\lfloor 20 * \\log_{10}(\\frac{r}{b})\\right\\rfloor$ but we should offer guidance on which to choose.",
              "createdAt": "2025-03-25T00:36:56Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqTg8",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:24:09Z",
          "updatedAt": "2025-03-25T03:25:23Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "We should talk about the privacy trade-offs with respect to sending each.  I think that it is reasonable to send both unconditionally, but it might be better to only send these when the estimated bandwidth availability enters the range covered by each.\r\n\r\nAn application that is currently operating in the TRONE1 range could decide that it only needs to send TRONE1 packets.  That limits the number of markings that are needed and does not reveal anything extra.  The challenge being in ensuring that the network element is aware that TRONE markings are available.  For that, I would recommend always sending one packet at least once, even when the active usage is well outside of the protocol-defined ranges.\r\n\r\n\r\nHowever, an application that MIGHT operate in just the TRONE2 range reveals information that the network does not otherwise obtain if it sends the TRONE2 signal.",
              "createdAt": "2025-03-25T03:24:09Z",
              "updatedAt": "2025-03-25T03:25:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqVP1",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:28:07Z",
          "updatedAt": "2025-03-25T03:28:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Or more clever:\r\n\r\n```python\r\ni = find(versions, packet[1..5]) if packet[0] & 0x80 == 0x80 else None\r\nif i is not None and ...\r\n```",
              "createdAt": "2025-03-25T03:28:07Z",
              "updatedAt": "2025-03-25T03:28:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrFXa",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:31:29Z",
          "updatedAt": "2025-03-25T05:31:30Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Agreed. Should I leave the text here while we work through this nuance or do you think there's something better to put in its place for now?",
              "createdAt": "2025-03-25T05:31:30Z",
              "updatedAt": "2025-03-25T05:31:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrGof",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:34:29Z",
          "updatedAt": "2025-03-25T05:34:29Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "An issue for followup is fine.",
              "createdAt": "2025-03-25T05:34:29Z",
              "updatedAt": "2025-03-25T05:34:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86htdY0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T09:38:15Z",
          "updatedAt": "2025-03-25T09:38:15Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "In the current state, I do not think we need to talk about rounding.\r\n\r\nWe state that the code points represent the ceiling. That means code points 0, 20, 40, 60 represent `<= 100Kbps`, `<= 1Mbps`, `<=10Mbps`, `<=100Mbps`, as they are divisible. OTOH, other values are indivisible. For example, 10<sup>1/20</sup> is 112201.84..., meaning that code point 1 represents bit rate up to 112,201bps.\r\n\r\nMaybe all we need to provide is these examples.\r\n\r\nOf course, we could go the other way and state that the 3 (or 4) most significant digits of the log function represents the bit rate...",
              "createdAt": "2025-03-25T09:38:15Z",
              "updatedAt": "2025-03-25T09:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2MB3",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think this is fine, except for the confusion between \"no TRONE on this path\" and \"no limit\".",
          "createdAt": "2025-03-25T22:21:17Z",
          "updatedAt": "2025-03-25T22:27:26Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think saying \"63 = No limit\" conflates two separate notions:\r\n\r\n* the TRONE protocol is not supported by network elements on the path (definition of 0x3F above)\r\n* the limit is higher that either 126Mbps or 12.6 Gbps.\r\n\r\nWe could remove that issue by defining the last lines of the table as:\r\n\r\n| 60 | 100 Mbps | 10 Gbps |\r\n| 62 | No limit | No limit |\r\n| 63 |  TRONE not supported on path |  TRONE not supported on path |\r\n\r\n\r\n",
              "createdAt": "2025-03-25T22:21:17Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 122,
              "body": "Would be \"up to 10Gbps\" if we use only 62 actual ranges.",
              "createdAt": "2025-03-25T22:22:38Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 170,
              "body": "I think it is fine to base the rounding on the table. I think we should say \"pick the highest rate signal that correspond to a value lower or equal to the rate\", but it might be a local decision.",
              "createdAt": "2025-03-25T22:25:20Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2_U7",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T00:54:09Z",
          "updatedAt": "2025-03-26T00:54:10Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "We should offer advice to network operators on the consequences of different choices.  Rounding down has the effect of guaranteeing that the used capacity is lower than the target.  However, given that applications that employ rate adaptation will rarely be able to completely use the given bandwidth, it might be better to pick a higher number.  Especially given that any excess is never more than about 11% higher than the previous step.",
              "createdAt": "2025-03-26T00:54:10Z",
              "updatedAt": "2025-03-26T00:54:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Khj",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:16:12Z",
          "updatedAt": "2025-03-26T04:16:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm not convinced that we need that feature.  What would  you do with that information?",
              "createdAt": "2025-03-26T04:16:12Z",
              "updatedAt": "2025-03-26T04:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4UB0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:47:48Z",
          "updatedAt": "2025-03-26T04:47:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think there is a difference between \"more than 10Gbps\" and \"don't know\". In one case, the app has the go ahead to use a vast amount of bandwidth. In the other, the app has to proceed cautiously and rely on congestion control for a bandwidth estimate.",
              "createdAt": "2025-03-26T04:47:48Z",
              "updatedAt": "2025-03-26T04:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Ymh",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:04:16Z",
          "updatedAt": "2025-03-26T05:04:16Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "`10M*10^{62/20}` = 12.589G; `10M*10^{61/20}` = 11.220G.  We only get 10G if we decide to use 61 ranges.",
              "createdAt": "2025-03-26T05:04:16Z",
              "updatedAt": "2025-03-26T05:04:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Zl7",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:07:16Z",
          "updatedAt": "2025-03-26T05:07:16Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I can't conceive of a scenario where an app would see an \"uncapped\" signal and decide that it can switch to sending at line rate.  You are taking the word of one path element and extrapolating to the entire path.\r\n\r\nLet's say that you get a 1Mbps signal.  You are currently at ~30kbps.  It might be reasonable to skip a few steps in your capacity probing to get closer to 1Mbps.  But that might be based on an assumption about the relative availability of bandwidth in modern networks and maybe past experience with the same network; I doubt you would make the same guess at 1Tbps (if that were a possible signal, that is).\r\n\r\nI conclude that while the congestion controller might be nudged a little, senders still need to have one and use that to probe the actual path availability.  The network still has queues and other users.  Expressions of policy limitations don't necessary entail guarantees, even at the node that is making that assertion.",
              "createdAt": "2025-03-26T05:07:16Z",
              "updatedAt": "2025-03-26T05:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4m8S",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:51:58Z",
          "updatedAt": "2025-03-26T05:51:58Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Sorry, I didn't do the math. But yes, that's the crux of the debate. We have 64 code points, from 0 to 63. If we reserve one to say \"don't know\", that means using only 62 code points, the last one marking the unbounded range.",
              "createdAt": "2025-03-26T05:51:58Z",
              "updatedAt": "2025-03-26T05:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4pOz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:58:46Z",
          "updatedAt": "2025-03-26T05:58:47Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I really need to get going on writing the congestion control part. There are a couple of ways to use a \"bandwidth cap\". It could solve one specific problem, stop the \"slow start\" exponential growth early. It could fit with the \"careful resume\" mechanism -- very that the new connection has the same cap as the previous one before reusing values learned before. It could inform of bandwidth drop, controlling the building of queues when the congestion controller discovers the new capacity. It could inform \"resume after congestion\" mechanisms, to grow sending rate quicker after transient congestion stops. At the application level, it can inform choice of codecs...",
              "createdAt": "2025-03-26T05:58:46Z",
              "updatedAt": "2025-03-26T05:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iP_c_",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:07:14Z",
          "updatedAt": "2025-03-27T15:07:14Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Filed #17 ",
              "createdAt": "2025-03-27T15:07:14Z",
              "updatedAt": "2025-03-27T15:07:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iQGWk",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:13:34Z",
          "updatedAt": "2025-03-27T15:13:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Filed #18 for followup though I'm largely in agreement with @martinthomson on this.",
              "createdAt": "2025-03-27T15:13:34Z",
              "updatedAt": "2025-03-27T15:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iSFuB",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T16:50:24Z",
          "updatedAt": "2025-03-27T16:50:24Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Filed #19 ",
              "createdAt": "2025-03-27T16:50:24Z",
              "updatedAt": "2025-03-27T16:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZV-N",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-03T22:21:54Z",
          "updatedAt": "2025-04-03T22:21:54Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "We can come back to that after merging this PR.",
              "createdAt": "2025-04-03T22:21:54Z",
              "updatedAt": "2025-04-03T22:21:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZWRw",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Let's merge this. We can iterate later.",
          "createdAt": "2025-04-03T22:22:55Z",
          "updatedAt": "2025-04-03T22:22:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86j3Gwz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to merge, one small editorial nit that we can fix now or later.",
          "createdAt": "2025-04-08T08:29:54Z",
          "updatedAt": "2025-04-08T08:31:08Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "This reads a bit like a single TRONE packet can have two versions, perhaps rewrite as:\r\n``````suggestion\r\nA network element applies the same rate policy to TRONE packets of both \r\nversions, accounting for the different scales of each version. When a\r\n",
              "createdAt": "2025-04-08T08:29:54Z",
              "updatedAt": "2025-04-08T19:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86kCEii",
          "commit": {
            "abbreviatedOid": "5764ba5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "+1 to merging.",
          "createdAt": "2025-04-09T04:34:16Z",
          "updatedAt": "2025-04-09T04:34:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDON1dwo86QF6Tw",
      "title": "Description of DOS attack against intermediaries",
      "url": "https://github.com/ietf-wg-scone/scone/pull/13",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding a description of the attack listed in #11.\r\n\r\nClose #11",
      "createdAt": "2025-03-25T18:25:44Z",
      "updatedAt": "2025-04-30T20:12:48Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "sec-rec-inter",
      "headRefOid": "2ab4aaf3a97e170832d069c6898bc362d1141b43",
      "closedAt": "2025-04-30T20:12:48Z",
      "mergedAt": "2025-04-30T20:12:48Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "1489b93c4da78eb247271e6aa9116589adfdd96f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lC-nU",
          "commit": {
            "abbreviatedOid": "7433288"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is good, except for the terminology nits.\r\nI think we can expand on the guidance to network elements (e.g., requiring that you observe TRONE packets in both uplink and downlink directions of a 5-tuple makes the attacks somewhat more difficult to pull off), but that can be done later.",
          "createdAt": "2025-04-15T16:12:12Z",
          "updatedAt": "2025-04-15T16:17:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nis invalid or because decryption fail, but network elements cannot do these checks,\r\n```",
              "createdAt": "2025-04-15T16:12:13Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nand will have to process the packets. All the network elements between the injection\r\n```",
              "createdAt": "2025-04-15T16:12:51Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\na denial of service (DOS) attempt against network elements. The attack will\r\n```",
              "createdAt": "2025-04-15T16:13:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nforce the intermediaries to process the fake packets. If network elements\r\n```",
              "createdAt": "2025-04-15T16:13:56Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nthe rate of TRONE packets that a network element is willing to process;\r\n```",
              "createdAt": "2025-04-15T16:14:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\na processing error at network elements. For example, they might pick connection\r\nidentifiers of arbitrary length. Network elements can mitigate these attacks\r\n```",
              "createdAt": "2025-04-15T16:15:16Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lSRzw",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for writing this!",
          "createdAt": "2025-04-16T15:52:45Z",
          "updatedAt": "2025-04-16T15:52:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lasB9",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:04:02Z",
          "updatedAt": "2025-04-17T10:04:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDON1dwo86QQjgP",
      "title": "First cut for congestion and TRONE interaction",
      "url": "https://github.com/ietf-wg-scone/scone/pull/16",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that we need to explicitly describe the interaction between congestion control and TRONE, if only to dispel any notion that TRONE replaces congestion control, as stated in issue #8. This is a first cut for describing such interactions. ",
      "createdAt": "2025-03-26T18:51:48Z",
      "updatedAt": "2025-04-30T10:02:35Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "first-congestion",
      "headRefOid": "37699bd37d10f56e306d78e055f3a13c884d3e6f",
      "closedAt": "2025-04-30T10:02:35Z",
      "mergedAt": "2025-04-30T10:02:35Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "649c6c08c4dd166071fd4bd23e33acf2d0ca67fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lJDps",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T04:08:16Z",
          "updatedAt": "2025-04-16T04:08:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think text up to this paragraph if fine.\r\n\r\nBut for the remainder, I'm not sure if it'd be a good idea to imply TRONE as a signal that supplements congestion signals that indicate that more bandwidth might be available.\r\n\r\nI wonder if it would be better to explain the difference of the time scales congestion signals and TRONE signals act upon.\r\n\r\nThe time scale of congestion signals is in the unit of RTT, while I'd presume TRONE signals to indicate average b/w available across ~10 seconds; see https://github.com/ietf-wg-scone/trone/issues/20. For video playback using chunked files, the two signals would be handled differently; congestion control applies to the transport, while the TRONE signal would be used for choosing the chunks with the appropriate bitrate. Note each chunk can be sent much faster than the rate indicated by TRONE, as long as the average bitrate (including the idle period) remains below the TRONE value.",
              "createdAt": "2025-04-16T04:08:17Z",
              "updatedAt": "2025-04-16T04:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lTVJf",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T17:28:03Z",
          "updatedAt": "2025-04-16T17:28:03Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Agreed. The following paragraphs are cut in the next commit.",
              "createdAt": "2025-04-16T17:28:03Z",
              "updatedAt": "2025-04-16T17:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lXf23",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the updates! LG",
          "createdAt": "2025-04-17T03:08:54Z",
          "updatedAt": "2025-04-17T03:08:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86larO4",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:02:40Z",
          "updatedAt": "2025-04-17T10:02:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDON1dwo86SskzI",
      "title": "Remove text on expanding datagrams.",
      "url": "https://github.com/ietf-wg-scone/scone/pull/22",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "How to handle network generated TRONE packets is a topic that requires WG discussion. \r\nI recommend that we remove any text on this topic for now and add something back based on the conclusion of #21.",
      "createdAt": "2025-04-15T16:05:26Z",
      "updatedAt": "2025-04-16T12:39:54Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "a4f79332ca9e716f7c255932d800191385ef33f4",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "ihlar-patch-1",
      "headRefOid": "8e0cd81a46e403c12e5e28b63109e6ebc3ec1f63",
      "closedAt": "2025-04-16T12:39:54Z",
      "mergedAt": "2025-04-16T12:39:54Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lDJtL",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T16:26:20Z",
          "updatedAt": "2025-04-15T16:26:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJGCc",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-16T04:11:23Z",
          "updatedAt": "2025-04-16T04:11:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDON1dwo86SsueK",
      "title": "Add \"TRONE Indication\" strawman.",
      "url": "https://github.com/ietf-wg-scone/scone/pull/23",
      "state": "CLOSED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the meeting, and mentioned in #5, it is useful for an endpoint to signal its potential usage of TRONE to a network element. This initial pass uses a \"TRONE Indication\" packet which is probably excessive but is a fully reversed TRONE packet that's meant to go at the end of a datagram. This allows for the network element to first detect a QUIC initial, and then check the end of the packet for TRONE.\r\n\r\nAn alternative would be a more bespoke indicating like a concatenation of versions, or something like that.",
      "createdAt": "2025-04-15T16:23:30Z",
      "updatedAt": "2025-07-24T21:47:13Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "2bc8257da0eda4e29639c1eca3da903f555332c8",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "2f3548f3523392f20915d3b492a258e288188cab",
      "closedAt": "2025-07-24T21:47:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @martinthomson thoughts on this?\r\n\r\nWe can merge as-is and remove fields later, or if we think it's important enough to cut them now I can change it to just be a QUIC version field.",
          "createdAt": "2025-04-16T16:34:53Z",
          "updatedAt": "2025-04-16T16:34:53Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we can merge this pull request (it'd be good to have all features being written down before the adoption call, but we can fix issues after adoption).\r\n\r\nHowever, I realize that indications cannot be designed based solely on Invariants, because packet coalescing is a version-specific concept defined in RFC 9000. So the text has to reflect that at some point at least, and the fact might have an affect on what we append.\r\n\r\nPS. Please see \u2193 for what I mean exactly.",
          "createdAt": "2025-04-18T00:45:20Z",
          "updatedAt": "2025-04-18T04:41:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still unconvinced about the utility of this indication.  I know that we talked about it, but after thinking about it more, I don't think that it helps as much as you think it does.  Can we talk about this at the interim?",
          "createdAt": "2025-04-22T02:25:27Z",
          "updatedAt": "2025-04-22T02:25:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whatever we decide, we have to document what the concatenation of multiple Trone packets means, and whether it should be allowed. The draft assumes that a trone packet will be composed as:\r\n~~~\r\nTronePacket [*LongHeaderPacket] { LongHeaderPacket | ShortHeaderPacket }\r\n~~~\r\nThis PR proposes to assign a meaning to:\r\n~~~\r\nLongHeaderPacket *LongHeaderPacket TronePacket \r\n~~~\r\nI am not a great fan of that, and in particular not a great fan of encoding something at the tail of initial packets that must be padded to a fixed length. Implementation is a bit more complicated than it appears, and I am not really convince of the utility. But in any case, if we do that, we need to say something about potential combinations like:\r\n~~~\r\nTronePacket  InitialPacket TronePacket  \r\nInitialPacket TronePacket_Vx TronePacket_Vy\r\nInitialPacket TronePacket  0RTTPacket\r\nInitialPacket TronePacket  HandshakePacket\r\nTronePacket_Vx TronePacket_Vy ShortHeaderPacket \r\netc.\r\n~~~",
          "createdAt": "2025-04-22T05:32:01Z",
          "updatedAt": "2025-04-22T05:34:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this is just a regular SCONE(TM) packet, then I would expect that it doesn't matter which one is used or where it appears.  At least to the network element.  But safe negotiation of QUIC depends on this being *after* QUIC packets.  Otherwise, a QUIC implementation that doesn't implement SCONE will be forced to throw out the rest of the datagram.  That's no good.\r\n\r\nI'm more concerned that this doesn't help a network element much.  Even after this signal appears, the network element still doesn't know if the *server* is going to use the protocol.  So it still needs to put itself in a \"SCONE-pending state\", until it sees a SCONE(TM) packet.",
          "createdAt": "2025-04-22T06:05:01Z",
          "updatedAt": "2025-04-22T06:05:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema Based on my understanding that we want to build SCONE (TRONE) on top of QUIC Invariants, I do not think think we should be considering how coalescing affects TRONE.\r\n\r\nInvariants does not have the concept of coalesced packets.\r\n\r\nIf the version is TRONE, it is a TRONE packet. If it is not, then it is not.\r\n\r\nIf we are to have an indication, I think it has to be some junk being attached at the end of the datagram; please see https://github.com/mjoras/trone/pull/1. Regardless, it is not a coalesced packet.",
          "createdAt": "2025-04-22T06:22:58Z",
          "updatedAt": "2025-04-22T06:22:58Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I think that your [PR 1](https://github.com/mjoras/trone/pull/1) has the advantage of not muddying the concept of Trone packet, i.e., that they can only be found at the beginning of a datagram. We should say so.",
          "createdAt": "2025-04-22T06:33:03Z",
          "updatedAt": "2025-04-22T06:33:03Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quoting MT from https://github.com/mjoras/trone/pull/1#discussion_r2053501602:\r\n> (Indication at the end of the datagram) only works if all packets are understood enough to ignore them AND know their length. We have an existence proof of that not working in QUIC v1 (the short header packets) and there is no guarantee that other QUIC versions will retain a usable length.\r\n\r\nI agree that this is the concern.\r\n\r\nIf some feel strongly about having the indication, we could look for an alternative design.\r\n\r\nOne way forward would be to prepend TRONE Indication packets before QUIC v1 Initials (or any other version of QUIC that works end-to-end), and use SvcParamKey to advertise support of TRONE. If we take this path, the only case in which we would see an additional delay would be when the client does not have out-of-band knowledge and the name resolution uses A/AAAA records. How much do we need to care about such deployments?",
          "createdAt": "2025-04-22T08:25:30Z",
          "updatedAt": "2025-04-22T08:25:30Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Quoting MT from [mjoras#1 (comment)](https://github.com/mjoras/trone/pull/1#discussion_r2053501602):\r\n> \r\n> > (Indication at the end of the datagram) only works if all packets are understood enough to ignore them AND know their length. We have an existence proof of that not working in QUIC v1 (the short header packets) and there is no guarantee that other QUIC versions will retain a usable length.\r\n> \r\n> I agree that this is the concern.\r\n\r\nHow much of a concern is this? \r\nSending a TRONE indication packet is optional, a sender will know whether it is possible or not to append an indication. \r\n \r\n> If some feel strongly about having the indication, we could look for an alternative design.\r\n> \r\n> One way forward would be to prepend TRONE Indication packets before QUIC v1 Initials (or any other version of QUIC that works end-to-end), and use SvcParamKey to advertise support of TRONE. If we take this path, the only case in which we would see an additional delay would be when the client does not have out-of-band knowledge and the name resolution uses A/AAAA records. How much do we need to care about such deployments?\r\n\r\nThis would be a cleaner solution though.  \r\n\r\n",
          "createdAt": "2025-04-22T14:54:51Z",
          "updatedAt": "2025-04-22T14:54:51Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm more concerned that this doesn't help a network element much. Even after this signal appears, the network element still doesn't know if the _server_ is going to use the protocol. So it still needs to put itself in a \"SCONE-pending state\", until it sees a SCONE(TM) packet.\r\n\r\nYou're right, this is all the network element knows until it sees a downlink SCONE packet.\r\nHowever, current networks perform heavy DPI to determine whether flows are candidates for rate\u2011limiting policies. Early SCONE indications allow operators to omit that step.\r\nEven in a \u201cSCONE\u2011pending state,\u201d a network element can initiate rate monitoring and potentially revert to throttling at some point, regardless of whether SCONE packets are observed in the downlink.",
          "createdAt": "2025-04-22T15:12:32Z",
          "updatedAt": "2025-04-22T15:12:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ihlar \r\n> How much of a concern is this?\r\n> Sending a TRONE indication packet is optional, a sender will know whether it is possible or not to append an indication.\r\n\r\nI think the concern is that protocols other than QUIC v1 might not support TRONE, or that TRONE would become a constraint to the protocol designers, as it requires having a packet format that allows ignoring junk at the end. The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).",
          "createdAt": "2025-04-22T23:33:27Z",
          "updatedAt": "2025-04-23T00:15:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  Even in a \u201cSCONE\u2011pending state,\u201d a network element can initiate rate monitoring and potentially revert to throttling at some point, regardless of whether SCONE packets are observed in the downlink.\r\n\r\nThis seems to be key.  If you think that this state is distinct from a \"SCONE-pending\" state where you don't get an indicator, why would you not do that for all QUIC flows once you hit a certain adoption threshold?",
          "createdAt": "2025-04-23T01:49:49Z",
          "updatedAt": "2025-04-23T01:49:49Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the concern is that protocols other than QUIC v1 might not support TRONE, or that TRONE would become a constraint to the protocol designers, as it requires having a packet format that allows ignoring junk at the end. \r\n\r\nMakes sense, thanks.\r\n\r\n> The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).\r\n\r\noth we should be able to send \"real\" SCONE packets at that point though?\r\n",
          "createdAt": "2025-04-28T14:48:04Z",
          "updatedAt": "2025-04-28T14:48:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).\r\n> \r\n> oth we should be able to send \"real\" SCONE packets at that point though?\r\n\r\nNot really, because SCONE packets and Indication are sent in different directions. The Indication as defined by this PR has only one form: appended at the end of the datagram, which is incompatible with short header packets of QUIC v1.\r\n\r\nBut separately, I think @martinthomson is raising an interesting question.\r\n\r\nNo matter how we design indications, they will not work when the client migrates involuntarily. Therefore, we will have to consider how we handle SCONE-compatible flows that do not send indications.\r\n\r\nConsidering that, I think it's worth discussing if network elements could handle all flows as potentially being SCONE-compatible, rather than relying on indications that might or might not work.",
          "createdAt": "2025-04-29T22:55:59Z",
          "updatedAt": "2025-04-29T23:00:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lFchD",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T20:05:41Z",
          "updatedAt": "2025-04-15T20:05:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJINs",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR.",
          "createdAt": "2025-04-16T04:15:03Z",
          "updatedAt": "2025-04-16T04:28:03Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe QUIC handshake by attaching a TRONE indication packet after the last QUIC long header\r\npacket in the first UDP datagram. The TRONE indication provides an\r\n```\r\n\r\nTrone is designed to be QUIC-version-neutral, so it is better to avoid referring to concepts specific to QUIC v1. Also, even in v1, the first datagram that an endpoint sends might contain an Initial and a Handshake (consider servers).",
              "createdAt": "2025-04-16T04:15:03Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nTRONE support by observing a full TRONE packet after the handshake completes.\r\n\r\nWhen sending QUIC short header packets in the first flight, endpoints SHOULD send them\r\nseparately from the first datagram carrying the TRONE indication packet, to avoid\r\nreceivers incapable of decoding TRONE packets from dropping the short header packet.\r\n```",
              "createdAt": "2025-04-16T04:21:56Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 27,
              "body": "I think there is a question around what TRONE indication packets signal.\r\n\r\nIIRC, TRONE is unidirectional.\r\n\r\nAssuming the use of a TRONE indication packet signals that the sender is capable of _receiving_ TRONE packets, I do not think we need the Rate Signal field here (and separately, I think we can use a different version number for indication packets).",
              "createdAt": "2025-04-16T04:27:46Z",
              "updatedAt": "2025-04-16T14:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lR86Z",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T15:24:25Z",
          "updatedAt": "2025-04-16T15:24:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Agreed, I think all the fields here are likely excessive, but kept them in for now so we can discuss further. A new version is probably fine in terms of avoiding false positives.",
              "createdAt": "2025-04-16T15:24:25Z",
              "updatedAt": "2025-04-16T15:24:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo861Y1-5",
          "commit": {
            "abbreviatedOid": "2f3548f"
          },
          "author": "martinduke",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-22T14:08:29Z",
          "updatedAt": "2025-07-22T14:08:29Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Is this consistent with a Datagram that has a coalesced 0RTT packet, or Mozilla-like zero padding? The parsing rules indicate this should be the very last thing.",
              "createdAt": "2025-07-22T14:08:29Z",
              "updatedAt": "2025-07-22T14:08:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo861Y5fj",
          "commit": {
            "abbreviatedOid": "2f3548f"
          },
          "author": "martinduke",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-22T14:11:43Z",
          "updatedAt": "2025-07-22T14:11:43Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "It would be helpful for understanding to elaborate more on the implications of these actions? An operator can do whatever it wants, but it is not clear to me what actions we expect them to take in terms of treatment of the flow (besides not trying to extract the SNI)",
              "createdAt": "2025-07-22T14:11:43Z",
              "updatedAt": "2025-07-22T14:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo861Y8TJ",
          "commit": {
            "abbreviatedOid": "2f3548f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-22T14:14:39Z",
          "updatedAt": "2025-07-22T14:14:39Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Can you elaborate on how the network elements reacts to this indication? The network element needs to wait for a TRONE signal in the server-to-client direction in order to confirm that the flow supports TRONE. Why is this better than just having the network element look at the first packet in the server-to-client direction of each 5-tuple?",
              "createdAt": "2025-07-22T14:14:39Z",
              "updatedAt": "2025-07-22T14:14:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDON1dwo86S8gIt",
      "title": "allow network elements rewrite the version field",
      "url": "https://github.com/ietf-wg-scone/scone/pull/25",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526 and during yesterday's interim, we can simplify the design by allowing network elements rewrite the version field.\r\n\r\nNow, senders need to send only one packet (0xTRONE2 with rate=0x3f) instead of sending one for each of the two versions, and receivers no longer need to calculate the minimum of two values.\r\n\r\nMaybe closes #14 and #19.",
      "createdAt": "2025-04-17T07:09:13Z",
      "updatedAt": "2025-04-30T08:17:08Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/changing-versions",
      "headRefOid": "6cd6dac6489a78922f2b3b2b653c47a2b8bc014c",
      "closedAt": "2025-04-30T08:17:08Z",
      "mergedAt": "2025-04-30T08:17:08Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "ee3f5886f37fedc26d0ff01dd926dc2e26ec6e51"
      },
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this! Was writing up something basically the same.\r\n\r\nDo we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.",
          "createdAt": "2025-04-18T00:26:09Z",
          "updatedAt": "2025-04-18T00:26:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for checking!\r\n\r\n> Do we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.\r\n\r\nMaybe raise as a different issue?\r\n\r\nBut FWIW, I do not think we want to neither allow or prohibit endpoints from mangling other versions of QUIC. It is not our business, and in the future, we might see another version of QUIC that recommends endpoints doing such a thing (example: a super-ECN signal that changes the bits in UDP payload). I think what we might need to add is a pointer to RFC 8999 regarding the topic.",
          "createdAt": "2025-04-18T01:57:46Z",
          "updatedAt": "2025-04-18T01:57:46Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Do we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.\r\n> \r\n> Maybe raise as a different issue?\r\n\r\nAgree to handling this in a separate issue. The way the design is described is good enough for a document to get adopted. We can decide on additional guidance later on. \r\n",
          "createdAt": "2025-04-22T09:34:10Z",
          "updatedAt": "2025-04-22T09:34:10Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should merge this prior to an adoption call. Any concerns with that?",
          "createdAt": "2025-04-29T07:53:15Z",
          "updatedAt": "2025-04-29T07:53:15Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merge it!",
          "createdAt": "2025-04-29T21:12:33Z",
          "updatedAt": "2025-04-29T21:12:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lakq6",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for this PR. \r\nLooks really good, small nit commented below. ",
          "createdAt": "2025-04-17T09:52:01Z",
          "updatedAt": "2025-04-17T09:58:59Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "178 is at n = 61 \r\nn = 62 should be ~199.53. \r\n\r\n```suggestion\r\nWith two versions combined, bitrates between 100 Kbps and 199.5 Gbps can be\r\n```",
              "createdAt": "2025-04-17T09:52:01Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n| 0xTRONE2 | 62          | 199.5 Gbps  |\r\n```",
              "createdAt": "2025-04-17T09:53:17Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n   (up to 199.5 Gbps)\r\n```",
              "createdAt": "2025-04-17T09:53:57Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lbbuP",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-17T11:34:12Z",
          "updatedAt": "2025-04-17T11:34:12Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Thank you!",
              "createdAt": "2025-04-17T11:34:12Z",
              "updatedAt": "2025-04-17T11:34:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86m3hiF",
          "commit": {
            "abbreviatedOid": "6cd6dac"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T14:44:55Z",
          "updatedAt": "2025-04-28T14:44:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDON1dwo86ULi6t",
      "title": "trone -> scone",
      "url": "https://github.com/ietf-wg-scone/scone/pull/28",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As agreed at interim and confirmed with authors, let's use SCONE as the protocol name. ",
      "createdAt": "2025-04-28T14:43:02Z",
      "updatedAt": "2025-05-05T14:46:37Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "f6cf9f1ad983298eea9027d8a5bc2f4d49dbe68b",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "trone-to-scone",
      "headRefOid": "0cb881f4da13308f620972813e20e4dad81644c0",
      "closedAt": "2025-05-05T14:46:37Z",
      "mergedAt": "2025-05-05T14:46:36Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "3f18ab7745e0e0b158f298a3cd507a178d28d0db"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 @martinthomson. It would be natural to make that PR post adoption as a WG item, move from `draft-thoji-scone-trone-protocol-nn` to `draft-ietf-scone-protocol-00`, and have the new draft replace the old one.",
          "createdAt": "2025-04-29T07:25:18Z",
          "updatedAt": "2025-04-29T07:25:18Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To move repo, we have two options:\r\n1. rename repo\r\n2. create a new repo and delete old \"trone\" repo\r\nI would suggest to take option 1, since option 1 leaves freedom to change draft name by yourselves. If we take option 2, all PRs and open issues might be lost. \r\nMake sense?",
          "createdAt": "2025-04-30T08:09:46Z",
          "updatedAt": "2025-04-30T08:09:46Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> To move repo, we have two options:\r\n> \r\n> 1. rename repo\r\n> 2. create a new repo and delete old \"trone\" repo\r\n>    I would suggest to take option 1, since option 1 leaves freedom to change draft name by yourselves. If we take option 2, all PRs and open issues might be lost.\r\n>    Make sense?\r\n\r\nAgree, option 1 sounds best.",
          "createdAt": "2025-04-30T09:35:14Z",
          "updatedAt": "2025-04-30T09:35:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Marcus.  Also, when you rename a repo, all the current links to this name will redirect for a decent amount of time; there's no risk that someone will hit a broken link.",
          "createdAt": "2025-04-30T10:32:54Z",
          "updatedAt": "2025-04-30T10:32:54Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I have renamed repo as 'scone' repo. Hope everything works well.",
          "createdAt": "2025-04-30T10:36:52Z",
          "updatedAt": "2025-04-30T10:36:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given where things stand, I'm OK with merging this now.  @huitema suggested that our (prospective) WG-00 not include any text changes, but I don't think we need to worry about a simple s/trone/scone/i for that; we have to rename other things when submitting a -00 anyway.",
          "createdAt": "2025-04-30T10:42:55Z",
          "updatedAt": "2025-04-30T10:42:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86m_yfG",
          "commit": {
            "abbreviatedOid": "8e97da6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Should we ask the chairs to move the repo first, then we can ensure that the links don't need to update twice.",
          "createdAt": "2025-04-29T03:02:48Z",
          "updatedAt": "2025-04-29T03:02:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDON1dwo86Ul5t7",
      "title": "When detecting flows not adhering to SCONE signals, RECOMMEND acting as if SCONE was not used",
      "url": "https://github.com/ietf-wg-scone/scone/pull/30",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request expands what SCONE being advisory means to network elements (i.e., that they should handle non-adhering SCONE flows as if it was not a SCONE flow).\r\n\r\nCloses #29.",
      "createdAt": "2025-05-01T01:18:50Z",
      "updatedAt": "2025-05-05T14:40:11Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "1489b93c4da78eb247271e6aa9116589adfdd96f",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/endpoints-that-do-not-adhere",
      "headRefOid": "387b0287d682c480e19af2ee65782dd0e3245293",
      "closedAt": "2025-05-05T14:40:11Z",
      "mergedAt": "2025-05-05T14:40:10Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "f6cf9f1ad983298eea9027d8a5bc2f4d49dbe68b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86nbS7v",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Some suggestions, but thanks for doing the work here.",
          "createdAt": "2025-05-01T01:24:16Z",
          "updatedAt": "2025-05-01T01:27:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nthat it will adhere to them; in some cases, the endpoint cannot. For\r\nexample, a flow may initially be used to serve video chunks, with the client\r\n```",
              "createdAt": "2025-05-01T01:24:16Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nbulk download for which bitrate adaptation is not applicable. Composite flows\r\nfrom multiple applications, such as tunneled flows, might only have a subset of\r\nthe involved applications that are capable of handling SCONE signals. Therefore,\r\nwhen a network element detects a\r\n```",
              "createdAt": "2025-05-01T01:25:40Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nflow using more bandwidth than advertised via SCONE, congestion control\r\nsignals might be necessary to ensure that the flow does not exceed the\r\nlimits that are set in policy.\r\n```",
              "createdAt": "2025-05-01T01:27:28Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nbWwY",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T01:36:01Z",
          "updatedAt": "2025-05-01T01:36:01Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thank you for the review. Other changes made total sense, but I'm not fully certain about this one.\r\n\r\nWhile it is true that CC might be necessary to force flows to be in policy, the proposed change does not address the original issue; i.e., that network elements should not punish non-adhering flows more so than non-SCONE flows. If network elements start behaving as such, endpoint developers would have no choice but to disable SCONE.\r\n\r\nWhat about something like: \"congestion control signals can be used to ensure that the flow performs on par with non-SCONE flows.\"?",
              "createdAt": "2025-05-01T01:36:01Z",
              "updatedAt": "2025-05-01T01:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nbwu7",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T03:03:19Z",
          "updatedAt": "2025-05-01T03:03:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@martinthomson Went ahead with 387b028, please let me know what you think.",
              "createdAt": "2025-05-01T03:03:20Z",
              "updatedAt": "2025-05-01T03:03:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nb2hK",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "That's better than what I suggested, thanks @kazuho.",
          "createdAt": "2025-05-01T03:44:54Z",
          "updatedAt": "2025-05-01T03:44:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86ncE6G",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "No objection. ",
          "createdAt": "2025-05-01T04:40:50Z",
          "updatedAt": "2025-05-01T04:40:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86nuhZ3",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks.",
          "createdAt": "2025-05-05T07:22:52Z",
          "updatedAt": "2025-05-05T07:22:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDON1dwo86V3kpP",
      "title": "Add usage of SCONE for throughput advice outside of rate-limiting",
      "url": "https://github.com/ietf-wg-scone/scone/pull/31",
      "state": "CLOSED",
      "author": "Kevsy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR explicitly includes in scope networks that do not rate limit, but wish to advise on network conditions to help achieve the optimal sender rate. \r\n\r\nNotes on changes:\r\nThroughout: replaced 'rate limit signal' with 'throughput advice signal' to account for both uses of SCONE (to signal rate limits/to signal throughput advice based on current network conditions)\r\n\r\nLine 68: Changed 'Many access networks limit the maximum data rate that attached devices are able to attain'  (because all shared access networks do this due to finite bandwidth) to 'Many access networks apply rate limits to constrain the data rate of attached devices.' (to more explicitly indicate active rate limiting).\r\n\r\nLine 164: Removed \"In that case, capacity is less likely to be split between multiple active flows.\" because capacity will always be divided between multiple active flows (otherwise they would not be active)\r\n\r\nLine 165: Added that a SCONE signal based on the network's calculation of throughput advice would take into account congestion, whereas (as stated in the original) one simply stating a rate limit would not.\r\n\r\n(Other suggested changes are editorial)",
      "createdAt": "2025-05-12T16:37:48Z",
      "updatedAt": "2025-06-16T13:49:31Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "2bc8257da0eda4e29639c1eca3da903f555332c8",
      "headRepository": "Kevsy/scone",
      "headRefName": "patch-1",
      "headRefOid": "9fb083f9b629a1b55a818542839ed6b76a1535a7",
      "closedAt": "2025-06-16T13:49:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @kazuho : https://github.com/ietf-wg-scone/scone/pull/31#discussion_r2090372600 explains it so I have put the text back for now, but I'll suggest a rewording in another PR to avoid bloating this PR.",
          "createdAt": "2025-05-15T08:37:48Z",
          "updatedAt": "2025-05-15T08:37:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ihlar (or @Kevsy) do you think that one of you can take the task of rebasing?  GitHub is telling me that it's a bit too complicated.",
          "createdAt": "2025-06-16T08:41:08Z",
          "updatedAt": "2025-06-16T08:41:08Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR was merged manually. ",
          "createdAt": "2025-06-16T13:49:31Z",
          "updatedAt": "2025-06-16T13:49:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86o_lXd",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "DISMISSED",
          "body": "The global search and replace didn't account for capitalization properly.  The substance of other changes is also against some of the established agreements around the divide between this work and congestion control.",
          "createdAt": "2025-05-13T04:33:23Z",
          "updatedAt": "2025-05-21T21:08:43Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nThis document describes a protocol where on-path network elements\r\ncan give endpoints their perspective on what the maximum achievable\r\nthroughput might be for QUIC flows.\r\n```\r\n\r\nThis can be shorter, and I think we don't need to get into what might cause a network element to offer this advice, rather we just need to establish that network elements have a perspective and that that perspective might be useful to communicate.",
              "createdAt": "2025-05-13T04:33:24Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n```\r\n\r\nSee above.",
              "createdAt": "2025-05-13T04:33:36Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 35,
              "body": "I would instead say this:\r\n\r\n```suggestion\r\nNetwork elements are not limited to communicating information\r\nabout rate limiting policies.\r\nNetwork elements in access networks could provide information\r\nto endpoints that can help account for changes in network capacity\r\nthat are not suited to congestion control feedback. This might include\r\nreduced capacity due to overuse, equipment faults, or other transient issues; \r\nconversely, networks might choose to signal increased availability of capacity.\r\n```",
              "createdAt": "2025-05-13T04:38:12Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 62,
              "body": "I think we need a better word than \"suggest\" for CC signals.",
              "createdAt": "2025-05-13T04:38:28Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't like this one.  The idea that this mechanism is good for congestion feedback is not something that has broad support.  That's why ECN or similar mechanisms are for.",
              "createdAt": "2025-05-13T04:39:46Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 124,
              "body": "The tentative position thus far is that we will be specifying a time period, even if we do not define a scope.  I'd rather not touch this text just now if it is changing.",
              "createdAt": "2025-05-13T04:40:30Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\n## Applying Throughput Advice Signals {#apply}\r\n```",
              "createdAt": "2025-05-13T04:40:41Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThroughput advice signals are not a substitute for congestion feedback.  Congestion\r\n```",
              "createdAt": "2025-05-13T04:40:54Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pAAOC",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This PR is premature. We should have a discussion in the issue first, and when we do have consensus on the issue process a PR.\r\n\r\nThe issue discusses replacing \"rate limit\" by \"throughput advice\". We have first to agree that this is a good idea. I think it might be, but with a caveat:\r\n\r\n1. It should be completely OK for networks that do not perform any explicit rate limit to still provide an advice, such as \"this network is engineered to support at most 100Mbps per flow\".\r\n\r\n2. It is definitely not OK to expect the throughput advice to reflect instant conditions, such as \"the path from New York to LA is currently congested\". This is the role of congestion signals, which operate on a much shorter time scale.",
          "createdAt": "2025-05-13T05:54:51Z",
          "updatedAt": "2025-05-13T06:06:16Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I think that \"indicate\" is correct. The probability of setting ECN/CE marks is function of the length of queues observed in the node. ECN/EC marks set that way do indeed indeed \"indicate\" the state of the network.",
              "createdAt": "2025-05-13T05:54:51Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 88,
              "body": "+1\r\nThe feedback loop between network state and throughput advice can be very loose. ECN and other congestion signals react in 1 RTT; SCONE feedback takes much longer, relies on endpoint polling the network. Let's not mix these two.",
              "createdAt": "2025-05-13T05:57:43Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 94,
              "body": "This is a true statement. What's the rationale for removing it?",
              "createdAt": "2025-05-13T05:58:14Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 124,
              "body": "+1. This PR should be limited to replacing \"rate limit\" by \"Throughput advice\".",
              "createdAt": "2025-05-13T05:59:13Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 191,
              "body": "typo, combination",
              "createdAt": "2025-05-13T05:59:52Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pCqnw",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T09:52:51Z",
          "updatedAt": "2025-05-13T09:52:52Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "> This is a true statement. What's the rationale for removing it?\r\n\r\nQuite probably my misunderstanding - but my rationale is that  capacity will always be split between multiple active flows in a best effort access network. I'm also not clear why downlink is specified but not uplink..?",
              "createdAt": "2025-05-13T09:52:51Z",
              "updatedAt": "2025-05-13T09:52:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDFE2",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:23:28Z",
          "updatedAt": "2025-05-13T10:23:28Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks, that suggestion covers the motive for the PR in one paragraph :)",
              "createdAt": "2025-05-13T10:23:28Z",
              "updatedAt": "2025-05-13T10:23:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDFq9",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:24:25Z",
          "updatedAt": "2025-05-13T10:24:26Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nmarkings {{?ECN=RFC3168}} that indicate the real-time condition of a network\r\n```",
              "createdAt": "2025-05-13T10:24:25Z",
              "updatedAt": "2025-05-13T10:24:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDF-d",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:24:55Z",
          "updatedAt": "2025-05-13T10:24:56Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nmarkings {{?ECN=RFC3168}} that indicate the real-time condition of a network\r\n```",
              "createdAt": "2025-05-13T10:24:55Z",
              "updatedAt": "2025-05-13T10:24:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDGP5",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:25:22Z",
          "updatedAt": "2025-05-13T10:25:22Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Reverted to 'indicate'",
              "createdAt": "2025-05-13T10:25:22Z",
              "updatedAt": "2025-05-13T10:25:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDIcn",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:28:33Z",
          "updatedAt": "2025-05-13T10:28:33Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\npath.  Congestion signals might indicate a throughput that is different from the\r\n```",
              "createdAt": "2025-05-13T10:28:33Z",
              "updatedAt": "2025-05-13T10:28:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDJdK",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:30:11Z",
          "updatedAt": "2025-05-13T10:30:11Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Reverted to 'indicate'",
              "createdAt": "2025-05-13T10:30:11Z",
              "updatedAt": "2025-05-13T10:30:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDMcH",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:34:49Z",
          "updatedAt": "2025-05-13T10:34:50Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nexpected throughput.  That throughput will only be achievable when there is no\r\nsignificant data flowing in the same scope.  In the presence of other flows,\r\ncongestion limits are likely to determine actual throughput.\r\n```",
              "createdAt": "2025-05-13T10:34:49Z",
              "updatedAt": "2025-05-13T10:34:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDOEU",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:36:39Z",
          "updatedAt": "2025-05-13T10:36:40Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Reverted (except I have kept 'throughput' in place of the original 'rate limit')",
              "createdAt": "2025-05-13T10:36:39Z",
              "updatedAt": "2025-05-13T10:36:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDQ89",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:39:56Z",
          "updatedAt": "2025-05-13T10:39:56Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "> +1. This PR should be limited to replacing \"rate limit\" by \"Throughput advice\".\r\n\r\nI think it can also include Martin's text that says rate limiting is not the only use (line 83-86 in the PR), and together those would cover my motive for raising the PR",
              "createdAt": "2025-05-13T10:39:56Z",
              "updatedAt": "2025-05-13T10:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pMFVM",
          "commit": {
            "abbreviatedOid": "787e594"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "With the changes, this is fine.  It's not going to be an endorsement of using the signal for real-time adaptation, like network congestion, so I'm OK with the switch to \"throughput advice\".",
          "createdAt": "2025-05-14T02:01:38Z",
          "updatedAt": "2025-05-14T02:04:39Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "```suggestion\r\nin a position to drop datagrams and could apply a rate limit policy.\r\n```",
              "createdAt": "2025-05-14T02:01:38Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\nnetwork conditions, or a combination of the two.\r\n```",
              "createdAt": "2025-05-14T02:01:57Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n## Providing Opportunities to Apply Throughput Advice Signals {#extra-packets}\r\n```",
              "createdAt": "2025-05-14T02:02:09Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pNzfg",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T06:56:46Z",
          "updatedAt": "2025-05-14T06:56:46Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I'm OK with this generally now.  However, this no longer makes sense as a statement:\r\n\r\n> The effective throughput advice might change without being signaled.\r\n\r\nShould we drop that line?  Or is there a different statement for this?  I'm leaning toward cutting it.",
              "createdAt": "2025-05-14T06:56:46Z",
              "updatedAt": "2025-05-14T06:56:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pa6dL",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the efforts. Have minor comments but looks good overall.",
          "createdAt": "2025-05-15T06:23:10Z",
          "updatedAt": "2025-05-15T06:26:55Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "Isn't it still the case that when the advice changes while the endpoints is in quiescence, the endpoints would end up sending data without being signaled?",
              "createdAt": "2025-05-15T06:23:10Z",
              "updatedAt": "2025-05-15T06:26:55Z"
            },
            {
              "originalPosition": 94,
              "body": "I think the statement is suggesting that at the very last mile, it is likely that there is only one active connection at a time. I think that is true and relevant here.",
              "createdAt": "2025-05-15T06:26:21Z",
              "updatedAt": "2025-05-15T06:26:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcUWJ",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:31:04Z",
          "updatedAt": "2025-05-15T08:31:05Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nThis makes the application of signals most usefully applied to a downlink flow\r\nin access networks, close to an endpoint. In that case, capacity is less likely\r\nto be split between multiple active flows.\r\n```",
              "createdAt": "2025-05-15T08:31:05Z",
              "updatedAt": "2025-05-15T08:31:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcbBt",
          "commit": {
            "abbreviatedOid": "e9f071c"
          },
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:40:27Z",
          "updatedAt": "2025-05-15T08:40:28Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "The typical case that causes swearing at throughput is the adult watching TV and the teenager turning on his video game; the adult complains that the news is showing a spinner mid-stream; the teenager complains that his controller is sluggish. Multiple flows at the last mile are normal, expected, and should be engineered for.",
              "createdAt": "2025-05-15T08:40:27Z",
              "updatedAt": "2025-05-15T08:40:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcbin",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:41:06Z",
          "updatedAt": "2025-05-15T08:41:06Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Reverted, but I will raise another PR with suggested rewording",
              "createdAt": "2025-05-15T08:41:06Z",
              "updatedAt": "2025-05-15T08:41:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcf0O",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:46:37Z",
          "updatedAt": "2025-05-15T08:46:37Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "would removing 'advice' here cover it, i.e.  'The effective throughput might change without being signaled'?",
              "createdAt": "2025-05-15T08:46:37Z",
              "updatedAt": "2025-05-15T08:46:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86peeC_",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T11:27:46Z",
          "updatedAt": "2025-05-15T11:27:46Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@alvestrand, that's what a congestion controller ultimately has to be used for.  The design here doesn't address that case, except to the extent that the sluggish game might fit between the rate limit cap and the capacity that the video uses.\r\n\r\nLooking forward to what @Kevsy suggests here.",
              "createdAt": "2025-05-15T11:27:46Z",
              "updatedAt": "2025-05-15T11:27:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86p8aMY",
          "commit": {
            "abbreviatedOid": "e9f071c"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T15:24:37Z",
          "updatedAt": "2025-05-19T15:24:37Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "> would removing 'advice' here cover it, i.e. 'The effective throughput might change without being signaled'?\r\n\r\nTo me that misses the quiescence point that @kazuho makes, since \"effective throughput\" sounds like something active that you measure.\r\n\r\nPerhaps rephrasing it to something like:\r\n\r\n\u201cNetwork conditions and rate-limit policies can change in ways that make previously signaled advice obsolete, and there are no guarantees that updated advice will be sent.\u201d\r\n\r\n\r\n\r\n",
              "createdAt": "2025-05-19T15:24:37Z",
              "updatedAt": "2025-05-19T15:24:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86t4gYP",
          "commit": {
            "abbreviatedOid": "7b70509"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "With this small tweak I think this PR is ready to be merged.",
          "createdAt": "2025-06-11T13:46:13Z",
          "updatedAt": "2025-06-11T13:46:46Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nThe time and scope over which throughput advice applies is not specified.\r\nNetwork conditions and rate-limit policies can change in ways that make\r\npreviously signaled advice obsolete, and there are no guarantees that\r\nupdated advice will be sent at such events. The signaled\r\n```",
              "createdAt": "2025-06-11T13:46:13Z",
              "updatedAt": "2025-06-11T13:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86utZKF",
          "commit": {
            "abbreviatedOid": "9fb083f"
          },
          "author": "Kevsy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2025-06-16T08:37:02Z",
          "updatedAt": "2025-06-16T08:37:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86uvlqK",
          "commit": {
            "abbreviatedOid": "9fb083f"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-16T11:28:55Z",
          "updatedAt": "2025-06-16T11:28:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDON1dwo86dsZOs",
      "title": "Reformat and tweak code",
      "url": "https://github.com/ietf-wg-scone/scone/pull/36",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The use of multiple versions makes this worse,\r\nbut I think it's worth breaking out the version change from the rest.",
      "createdAt": "2025-07-07T06:48:05Z",
      "updatedAt": "2025-07-07T18:36:17Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "2bc8257da0eda4e29639c1eca3da903f555332c8",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "wrap-code",
      "headRefOid": "22464ac3a681d8f04efb026a9c3d9857503a8536",
      "closedAt": "2025-07-07T18:36:17Z",
      "mergedAt": "2025-07-07T18:36:17Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "e8eaf8f87e2a5c16b8b66366dfb198ec861cd645"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that I think on this more, I think that we need to make more changes...  Hold that for a moment.",
          "createdAt": "2025-07-07T07:48:21Z",
          "updatedAt": "2025-07-07T07:48:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think 7514f6b is fine in sense that we can assume the following:\r\n* bit rates in SCONE2_VERSION are above those in SCONE1_VERSION, and\r\n* within each version, bit rate signals are ordered by their bit rates.\r\n\r\nNot that 22464ac is bad, but I wonder if network elements would actually convert signals to bit rates.",
          "createdAt": "2025-07-07T08:49:10Z",
          "updatedAt": "2025-07-07T08:49:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's several things in there that are probably ripe for optimization; the point of pseudocode is not to highlight what is optimal, but to describe - in an unambiguous fashion - what is correct.  For instance, the conversion from target throughput to a signal is something you can cache for the target throughput.  I didn't do that.\r\n\r\nGiven the current versions we have, there is a unique mapping from any rate to just one pair of version and signal.  That's not guaranteed more generally though.  I think that I'd prefer the more general form.",
          "createdAt": "2025-07-07T09:05:18Z",
          "updatedAt": "2025-07-07T09:05:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86yXRY3",
          "commit": {
            "abbreviatedOid": "53c8634"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LG modulo the comment below.",
          "createdAt": "2025-07-07T07:05:47Z",
          "updatedAt": "2025-07-07T07:06:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n  if target_rate_version != packet_version:\r\n```\r\n\r\nThis is an issue in the original code, but I do not think we have defined ordering between the two version numbers.",
              "createdAt": "2025-07-07T07:05:47Z",
              "updatedAt": "2025-07-07T07:06:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86ydl8A",
          "commit": {
            "abbreviatedOid": "22464ac"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T14:17:14Z",
          "updatedAt": "2025-07-07T14:17:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86ydovx",
          "commit": {
            "abbreviatedOid": "22464ac"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T14:20:02Z",
          "updatedAt": "2025-07-07T14:20:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDON1dwo86dt5Tu",
      "title": "Add a time component of 60 seconds",
      "url": "https://github.com/ietf-wg-scone/scone/pull/37",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #20.",
      "createdAt": "2025-07-07T09:19:14Z",
      "updatedAt": "2025-07-30T04:30:40Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "5df97596fa6047432a605985af2177994955efe8",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "time",
      "headRefOid": "7896705a03ba2a35fa401c902016fec513dcb494",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "anooptomar29",
          "authorAssociation": "NONE",
          "body": "> Closes #20.\r\n\r\nNot sure how this addresses issue#20. ",
          "createdAt": "2025-07-21T16:23:21Z",
          "updatedAt": "2025-07-21T16:23:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86y5gRO",
          "commit": {
            "abbreviatedOid": "1a7eccd"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR. Looks good overall, just small nits.",
          "createdAt": "2025-07-09T12:46:45Z",
          "updatedAt": "2025-07-09T12:50:23Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We call `now()` here, but in `data_sent`, the time is fed from the caller. I think we should better be consistent regarding who manages the time (eitner the class or the caller).",
              "createdAt": "2025-07-09T12:46:45Z",
              "updatedAt": "2025-07-09T12:50:23Z"
            },
            {
              "originalPosition": 38,
              "body": "Do we want to talk about approaches other than asking the peer to rate-limit, such as:\r\n* the endpoint selecting different resources (like video chunks), or\r\n* using flow control to limit the amount of data being sent by the peer?",
              "createdAt": "2025-07-09T12:49:56Z",
              "updatedAt": "2025-07-09T12:50:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zA_Wq",
          "commit": {
            "abbreviatedOid": "1a7eccd"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-09T23:25:53Z",
          "updatedAt": "2025-07-09T23:25:53Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I wasn't planning to talk about the how in _this_ change, but it's worth noting for sure.",
              "createdAt": "2025-07-09T23:25:53Z",
              "updatedAt": "2025-07-09T23:25:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zBK91",
          "commit": {
            "abbreviatedOid": "1a7eccd"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-09T23:59:09Z",
          "updatedAt": "2025-07-09T23:59:09Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "+1 to opening an issue dedicated to the topic (so, thank you for doing that).",
              "createdAt": "2025-07-09T23:59:09Z",
              "updatedAt": "2025-07-09T23:59:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zBLA7",
          "commit": {
            "abbreviatedOid": "2cb56e7"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-09T23:59:18Z",
          "updatedAt": "2025-07-09T23:59:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86zBdDe",
          "commit": {
            "abbreviatedOid": "1a7eccd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-10T00:47:16Z",
          "updatedAt": "2025-07-10T00:47:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, let's discuss that in a separate issue.",
              "createdAt": "2025-07-10T00:47:16Z",
              "updatedAt": "2025-07-10T00:47:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zBmaN",
          "commit": {
            "abbreviatedOid": "2cb56e7"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-10T01:11:18Z",
          "updatedAt": "2025-07-10T01:11:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDON1dwo86duDUk",
      "title": "Some more positives",
      "url": "https://github.com/ietf-wg-scone/scone/pull/38",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #33.",
      "createdAt": "2025-07-07T09:35:03Z",
      "updatedAt": "2025-07-08T00:47:04Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "2bc8257da0eda4e29639c1eca3da903f555332c8",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "fair-share",
      "headRefOid": "06d27971bd40ea374a62816669d2e57d839ef39d",
      "closedAt": "2025-07-07T23:35:07Z",
      "mergedAt": "2025-07-07T23:35:07Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "d29ae5ea8becda2ecf653484a83d5948d2bed186"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for doing this!",
          "createdAt": "2025-07-08T00:47:04Z",
          "updatedAt": "2025-07-08T00:47:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86yctWF",
          "commit": {
            "abbreviatedOid": "80d0b08"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T13:22:40Z",
          "updatedAt": "2025-07-07T13:22:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86yjIMK",
          "commit": {
            "abbreviatedOid": "80d0b08"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T23:34:33Z",
          "updatedAt": "2025-07-07T23:34:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthroughput advice operates over a much longer period.\r\n```",
              "createdAt": "2025-07-07T23:34:33Z",
              "updatedAt": "2025-07-07T23:34:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDON1dwo86eNp7m",
      "title": "Add some discussion about compliance",
      "url": "https://github.com/ietf-wg-scone/scone/pull/40",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This includes the suggestions from #39.  I've put this in the applicability statement.  That's a bit unusual as a place to put what amounts to implementation guidance, but the framing here seemed natural.\r\n\r\nCloses #39.",
      "createdAt": "2025-07-10T01:35:18Z",
      "updatedAt": "2025-07-23T07:50:07Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "d29ae5ea8becda2ecf653484a83d5948d2bed186",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "how-to",
      "headRefOid": "5e10d57bc9a03140f38ffa4cdca3a266899a005a",
      "closedAt": "2025-07-23T07:50:07Z",
      "mergedAt": "2025-07-23T07:50:07Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "517e54b2c40db10df3f14f55f7efb7399c7fc8f2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86zCer1",
          "commit": {
            "abbreviatedOid": "6e28e56"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for doing this.\r\n\r\nAdded text looks good, and I agree that this is the right place.",
          "createdAt": "2025-07-10T03:44:11Z",
          "updatedAt": "2025-07-10T03:44:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86zNry7",
          "commit": {
            "abbreviatedOid": "6e28e56"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-07-10T17:51:11Z",
          "updatedAt": "2025-07-10T17:51:20Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I am a bit surprised by the section title. Compliance to what? Does \"discretionary\" means optional? It seems that you want to convey two different concepts: first, that endpoint receiving the TRONE advice may or may not decide to follow hit; and then, that if they decide to follow it, here are three ways they could go about it.\r\n\r\nThe first paragraph of the section hints at the discretionary part by stating that applications \"can follow [the] advice\". That's a pretty minimalist way of stating it, kind of passive-aggressive. I would suggest making it completely obvious:\r\n\r\n_The TRONE signal is advisory (see {{advisory-signal}}). Applications that chose to follow it will do so  in the way that best suits their needs._\r\n\r\nAs for the section title, could we change it to something like \"Following the Advice\" ?",
              "createdAt": "2025-07-10T17:51:11Z",
              "updatedAt": "2025-07-10T17:51:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zTXUB",
          "commit": {
            "abbreviatedOid": "6e28e56"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-11T02:12:30Z",
          "updatedAt": "2025-07-11T02:12:30Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Works for me.  Will do.",
              "createdAt": "2025-07-11T02:12:30Z",
              "updatedAt": "2025-07-11T02:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zTXZW",
          "commit": {
            "abbreviatedOid": "6e28e56"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-11T02:12:42Z",
          "updatedAt": "2025-07-11T02:12:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n## Following Advice\r\n```",
              "createdAt": "2025-07-11T02:12:42Z",
              "updatedAt": "2025-07-11T02:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zTYD1",
          "commit": {
            "abbreviatedOid": "4b70fd0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-11T02:13:42Z",
          "updatedAt": "2025-07-11T02:13:42Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nThe TRONE signal is advisory (see {{advisory-signal}}).\r\nApplications that chose to follow it will do so in the way that best suits their needs.\r\n```",
              "createdAt": "2025-07-11T02:13:42Z",
              "updatedAt": "2025-07-11T02:13:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zUh9m",
          "commit": {
            "abbreviatedOid": "48fcc97"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-11T04:20:48Z",
          "updatedAt": "2025-07-11T04:20:48Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe SCONE throughput advice is advisory (see {{advisory-signal}}).\r\n```",
              "createdAt": "2025-07-11T04:20:48Z",
              "updatedAt": "2025-07-11T04:20:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86zUto4",
          "commit": {
            "abbreviatedOid": "6df424e"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-11T04:44:41Z",
          "updatedAt": "2025-07-11T04:44:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86zXNN_",
          "commit": {
            "abbreviatedOid": "6df424e"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-11T08:23:35Z",
          "updatedAt": "2025-07-11T08:23:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nquality to fit within a target throughput.  For instance, an HTTP Live Streaming\r\n```\r\nRFC 8216 uses mixed-case throughout, so maybe it makes sense to do the same here?",
              "createdAt": "2025-07-11T08:23:35Z",
              "updatedAt": "2025-07-11T08:23:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo861XeKz",
          "commit": {
            "abbreviatedOid": "5e10d57"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2025-07-22T12:43:52Z",
          "updatedAt": "2025-07-22T12:43:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo861Xf3U",
          "commit": {
            "abbreviatedOid": "5e10d57"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this looks great to me -- it concisely summarizes the main strategies I'm aware of to achieve this both unilaterally from the client side, and with cooperation from the sending peer.",
          "createdAt": "2025-07-22T12:44:51Z",
          "updatedAt": "2025-07-22T12:44:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDON1dwo86gET0A",
      "title": "Fix the innocent protocol mangling",
      "url": "https://github.com/ietf-wg-scone/scone/pull/44",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This depends on an answer to #43 being as I suggested there. I won't make the pull request dependent on that though.\r\n\r\nCloses #10.",
      "createdAt": "2025-07-22T12:58:35Z",
      "updatedAt": "2025-07-30T23:59:31Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "d29ae5ea8becda2ecf653484a83d5948d2bed186",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "following-limits",
      "headRefOid": "5c0b1cc987280c5c3216cea0f6c6d671d05d0f4e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the only real requirement here is not to alter every packet.  That, of course, depends on #46, but I think that's necessary for other reasons (robustness primarily).  The heuristics only apply where there is per-flow state, not everywhere.  Is there a caveat that would make that part more acceptable @huitema?",
          "createdAt": "2025-07-29T03:09:08Z",
          "updatedAt": "2025-07-29T03:09:08Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assume a lazy implementer that does not want to keep state, so simply picks a random number with some probability to decide whether marking the SCONE packet. Now, suppose a systematic collision. If the probability of marking is `x`, then the fraction of mangled packets is also `x`. What is the acceptable rate of mangled packets? I think lower than 1% is probably OK, TCP is more or less designed to handle that. More than that will be severe. 10% means serious performance degradation. 50% means fully broken.\r\n\r\nAt the same time, picking a random rate of 1% means a terrible SCONE service. 50% would probably work, leading to endpoints sending twice as many SCONE packets as required. 10% would lead to 10 times as many packets, and that seems bad.\r\n\r\nMy preference would be to not mention a fraction, but rather mandate a delay. We have seen that if the signal is good for 60 seconds, endpoints should probably sample it every 30 seconds. That means repetitions at shorter interval probably indicate brokenness. If I had to implement that, I would probably use a Bloom filter to check whether the 4-tuple has been seen recently, and in that case leave the packet alone. And I would just zero the filter at short intervals, maybe 5 seconds, maybe 10. That seems something even lazy folks can implement, especially if we twist their arm.\r\n\r\nMy recommendation would be to say something like MUST NOT process a \"SCONE\" packet if the 4-tuple has been seen in the past N seconds. Pick a number for N -- 2, 5, 10 probably all work. Then even the lazy folks can think about a Bloom filter implementation, or something like that.",
          "createdAt": "2025-07-29T04:05:08Z",
          "updatedAt": "2025-07-29T04:05:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My preference would be to not mention a fraction, but rather mandate a delay. We have seen that if the signal is good for 60 seconds, endpoints should probably sample it every 30 seconds.\r\n\r\nIsn't that what this does?\r\n\r\n> Limiting the rate of updates to a small number of times over each enforcement period is sufficient.\r\n\r\nUnless you feel like \"small number\" needs to be more concrete (2-10 seems reasonable, as you say).",
          "createdAt": "2025-07-29T04:33:28Z",
          "updatedAt": "2025-07-29T04:33:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe say that a bit more directly. The first sentence says \"To that end, network elements MUST ensure that\r\nthey do not update the content of every datagram.\" I think we should be more direct, reference both the duration and the unit, i.e., a given 4-tuple. How about:\r\n\r\nTo that end, network elements SHOULD NOT update datagrams sent over a given 4-tuple more than a few times per enforcement period. Network elements MAY update more often\r\nin response to a change in throughput advice,\r\nto reduce the reaction time from senders.",
          "createdAt": "2025-07-29T07:04:26Z",
          "updatedAt": "2025-07-29T07:04:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861XxhW",
          "commit": {
            "abbreviatedOid": "6e2e6f4"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-22T13:03:43Z",
          "updatedAt": "2025-07-22T13:03:44Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I'm afraid this is no longer possible. In the new encoding, a sender only sends SCONE2 packets, and each bit rate maps to exactly one version.",
              "createdAt": "2025-07-22T13:03:44Z",
              "updatedAt": "2025-07-22T13:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo861kG-U",
          "commit": {
            "abbreviatedOid": "6e2e6f4"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-23T07:57:56Z",
          "updatedAt": "2025-07-23T07:57:56Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Right, that heuristic doesn't work anymore. \r\nWe should mention indications though, if they now make it into the protocol. ",
              "createdAt": "2025-07-23T07:57:56Z",
              "updatedAt": "2025-07-23T07:57:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862c8Dr",
          "commit": {
            "abbreviatedOid": "6e2e6f4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T07:58:45Z",
          "updatedAt": "2025-07-28T07:58:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nor other heuristics.\r\n```",
              "createdAt": "2025-07-28T07:58:45Z",
              "updatedAt": "2025-07-28T07:58:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862c9DW",
          "commit": {
            "abbreviatedOid": "ce9e9a2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T07:59:33Z",
          "updatedAt": "2025-07-28T07:59:33Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nthe presence of indications ({{indication}}),\r\nor other heuristics.\r\n```",
              "createdAt": "2025-07-28T07:59:33Z",
              "updatedAt": "2025-07-28T07:59:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862n6lJ",
          "commit": {
            "abbreviatedOid": "6ece583"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I am concerned that this mitigation requires the network elements to keep state by 4-tuples . That could be onerous, and could also open the door for denial of service attacks.\r\n\r\nThe other possible mitigation is to change the scone format to add entropy and reduce the risk of collision. I think that we discussed a solution like that before. For example, add a payload to the scone packet, with two numbers: a counter, and a proof of that counter such as XORing it with the version number or some other magic number. At that point the risk of repeated collision becomes really low. \r\n\r\nOf course, we have a tradeoff here. On one hand, require operators of network elements to keep some state, on the other hand, require some more complicated processing. Both fall in the category of \"you must do that but I know you wont\", with lazy operators either forgetting about checks and processing every packet that they recognize as SCONE, or just rolling the dice for every packet recognized as SCONE to decide whether to mark it.\r\n\r\nAnd of course, the \"rolling the dice\" strategy implies a heavy probability of SCONE packets not marked, which will induce end points to send way more SCONE packets than necessary. Which in turn will stress the network elements.",
          "createdAt": "2025-07-28T17:27:04Z",
          "updatedAt": "2025-07-28T17:43:05Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The verifier does not like `{{indication}}`...",
              "createdAt": "2025-07-28T17:27:04Z",
              "updatedAt": "2025-07-28T17:42:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862sluY",
          "commit": {
            "abbreviatedOid": "6ece583"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-29T03:05:28Z",
          "updatedAt": "2025-07-29T03:05:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yeah, I expect #49 to merge first and then this is fine.",
              "createdAt": "2025-07-29T03:05:28Z",
              "updatedAt": "2025-07-29T03:05:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862_lcV",
          "commit": {
            "abbreviatedOid": "6ece583"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T06:49:10Z",
          "updatedAt": "2025-07-30T06:49:10Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nTo that end, network elements MUST only update the content of datagrams\r\non a given address tuple\r\nmore than a few times each enforcement period.\r\nNetwork elements MAY update more often\r\nimmediately after a change in their throughput advice,\r\nto reduce the reaction time from senders.\r\n```\r\nTweaking @huitema's suggestion.",
              "createdAt": "2025-07-30T06:49:10Z",
              "updatedAt": "2025-07-30T06:49:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863G7Wy",
          "commit": {
            "abbreviatedOid": "5c0b1cc"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T14:56:47Z",
          "updatedAt": "2025-07-30T14:56:47Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "OK, we are down to editorial. I suggested \"SHOULD NOT ... more than a few times\". You propose \"MUST only ... more than a few times.\" I still prefer my original proposal for two reasons:\r\n\r\n- \"MUST only ... more\" is a weird construct. I think this should be either \"MUST NOT ... more\" or \"SHOULD NOT .. more\".\r\n- I originally thought of writing \"MUST NOT\", but in general if we have a combination of mandate and exception we write \"SHOULD NOT \\<do something>\" followed by \"MAY \\<by exception do something else>\", so I would rather use the established pattern.\r\n\r\nIf you prefer a positive tone, we could also strike out \"*more than*\" in \"[SHOULD|MUST] only update the content of datagrams on a given address tuple ~more than~ a few times each enforcement period.\" That too would remove the weirdness.",
              "createdAt": "2025-07-30T14:56:47Z",
              "updatedAt": "2025-07-30T15:01:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863NCnL",
          "commit": {
            "abbreviatedOid": "5c0b1cc"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T23:59:31Z",
          "updatedAt": "2025-07-30T23:59:31Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Considering that SCONE is meant to work with any version of QUIC, I'm not sure if we would want to talk about identifying handshakes, as that is a concept specific to version 1 of QUIC.",
              "createdAt": "2025-07-30T23:59:31Z",
              "updatedAt": "2025-07-30T23:59:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDON1dwo86gP9iz",
      "title": "Add a minimum rate algorithm",
      "url": "https://github.com/ietf-wg-scone/scone/pull/46",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This approach ensures that we don't have blackout periods (an issue raised in the meeting).  But it makes the whole rate limit signaling more robust.  It also allows network elements the option of skipping updates.",
      "createdAt": "2025-07-23T11:37:13Z",
      "updatedAt": "2025-08-07T17:30:52Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "time",
      "baseRefOid": "3cda4b7b9ce75a332e91a8db04e43364b6b34347",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "min-rate",
      "headRefOid": "143e2354b0579f18b8ac8f97d493bb77379f4568",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "wesley-eddy",
          "authorAssociation": "NONE",
          "body": "I think this is missing the mark a bit or making things overly complex.\r\n\r\nThe problem it's aiming to solve might be better discussed in the WG a bit more to make sure the understanding is aligned with vendors and CSPs that would be implementing and deploying, to make sure it's aligning with needs.\r\n\r\nThe notion of monitoring periods, sampling, nyquist, etc. are not needed.  The max throughput guidance is not like an analog signal that we're trying to sample and reproduce with some fidelity.  For most envisioned current cases, it's a fixed number that will not change for the duration of a flow.  It comes from the mobile user's subscriber plan (e.g. the plan says video at 720p is supported, so the SCONE signaling always indicates a corresponding fixed rate).\r\n\r\nThe text here about senders and receivers keeping state is really adding too much complexity for the typical case where a client gets SCONE advice of N Mbps, and then is able to use that knowledge in its ABR algorithm as a top limit subsequently for video chunks requested in the flow.  Allowing it to refresh or receive updated guidance does not have to be this complex IMHO.",
          "createdAt": "2025-08-06T20:40:46Z",
          "updatedAt": "2025-08-06T20:40:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we need to balance a few tensions there:\r\n\r\n1. Time limited advice. The conditions will change. They may change randomly. The application will usually get some advice if conditions change for the worse, but probably not if they change for the better. They could easily trigger a SCONE probe in case of worsening, but they do have to resort to periodic or quasi periodic probing to detect easing. The PR helps here with a number, 67. If the advice is supposed good for 67 seconds, the client has no reason to probe more than every 20 to 30 seconds.\r\n\r\n2. Load of network intermediaries. Ideally, intermediaries should be able to process all incoming packets at line rate, but that may not be realistic. Stateless solutions such as only marking a random fraction of packets wont work well: if the application sends 3 probes in 67seconds, any significant non marking rate incurs the risk of none of these 3 packets being processed. Thus, we need some state per flow.\r\n\r\n3. Difficulty of keeping state in network intermediaries. The number of flow could be very large, but if applications only send a stone packet every 20-30 seconds and send video at 720p, that's one mark per 2000 to 3000 packets. This can be used as a design criteria -- if the intermediary monitors a link carrying 1M pps, it should be able to handle 1K SCONE per second. That can be used for example to dimension a Bloom filter. The network element can use a Bloom filter that is zeroed every 10 seconds, check whether the flow is already in the filter, not process the packet if it is there, process the SCONE packet and add a mark in the filter if it is not.\r\n\r\nBottom line, I think the advice is correct.",
          "createdAt": "2025-08-07T17:30:52Z",
          "updatedAt": "2025-08-07T17:30:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861vnXM",
          "commit": {
            "abbreviatedOid": "94e5d41"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think we need to be a bit more directive in the `#apply` section.",
          "createdAt": "2025-07-23T21:43:35Z",
          "updatedAt": "2025-07-23T21:45:10Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "That's where Nyquist applies. \"No more than a monitoring period\" is not wrong, but it is incomplete. I argue that:\r\n\r\n1- To detect change in appropriate times, the interval between probes should be about half the monitoring period;\r\n2- To avoid synchronization, the interval between probes should be randomized.",
              "createdAt": "2025-07-23T21:43:36Z",
              "updatedAt": "2025-07-23T21:45:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862dA6c",
          "commit": {
            "abbreviatedOid": "94e5d41"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T08:02:44Z",
          "updatedAt": "2025-07-28T08:02:44Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "```suggestion\r\nBecause this depends on the availability of SCONE packets,\r\nnetwork elements might need to be prepared to update\r\nat a much higher frequency.\r\nSending and updating SCONE packets at least twice per monitoring period\r\nensures that signals are always available.\r\n```",
              "createdAt": "2025-07-28T08:02:44Z",
              "updatedAt": "2025-07-28T08:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862dBam",
          "commit": {
            "abbreviatedOid": "143e235"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T08:03:10Z",
          "updatedAt": "2025-07-28T08:03:13Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "I think that this randomization can come later.",
              "createdAt": "2025-07-28T08:03:10Z",
              "updatedAt": "2025-07-28T08:03:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDON1dwo86gQKLy",
      "title": "Update CI files",
      "url": "https://github.com/ietf-wg-scone/scone/pull/47",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-23T11:55:28Z",
      "updatedAt": "2025-07-23T13:37:27Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "517e54b2c40db10df3f14f55f7efb7399c7fc8f2",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "update-ci",
      "headRefOid": "e7faf85c7d653e60ac31ca7c747437b6a3f39c3c",
      "closedAt": "2025-07-23T13:37:27Z",
      "mergedAt": "2025-07-23T13:37:27Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "7a5c958cc37d32558ef6c37687d2749c6d00c048"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDON1dwo86gRnvr",
      "title": "Forbid insertion of SCONE packets",
      "url": "https://github.com/ietf-wg-scone/scone/pull/48",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is one potential approach to #21.  However, it does constrain things more than I think is necessary.  I tend to think that staying quiet is best, because it gives network elements the option and endpoints the choice of ignoring those inserted SCONE packets.  I wouldn't want to *encourage* that outcome though.\r\n\r\nCloses #21.",
      "createdAt": "2025-07-23T13:55:32Z",
      "updatedAt": "2025-07-23T13:55:32Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "min-rate",
      "baseRefOid": "94e5d41ffb5519696c2667da48d109d6a22a153f",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "insertion",
      "headRefOid": "e1c4874dc6f63a84f8fbe65f13cc93ebdc6a7ae6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDON1dwo86gSeQK",
      "title": "Add an indication",
      "url": "https://github.com/ietf-wg-scone/scone/pull/49",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This adds a small indicator to the end of packets, so that network elements can maybe flip their posture for those flows. That requires a bit of a gamble, because the indication doesn't mean that SCONE is supported or that throughput advice will be followed, but it seems like we have some belief that this will change how the protocol might be deployed.\r\n\r\nI didn't strongly mandate the new flow indication piece.  That's something we could do, but it turned out to be incredibly hard to specify something that works sensibly.  Tying this to PATH_CHALLENGE/PATH_RESPONSE does work, but those have more uses than initializing a flow on a new path, so the set of conditions you need to set out for when the indication is attached to a datagram end up being very complicated.\r\n\r\nGiven that we already have good reason to send SCONE packets on new paths, I don't think we need to overthink that part.\r\n\r\nCloses #5.\r\nCloses #23.",
      "createdAt": "2025-07-23T15:07:55Z",
      "updatedAt": "2025-07-31T04:47:57Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "7a5c958cc37d32558ef6c37687d2749c6d00c048",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "indication",
      "headRefOid": "81dae9893279a63ce5e76afa833992dd820bad92",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861xDOL",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I have really mixed feelings about the support for indications, but this text is probably OK. The indicator is present for all new flows that negotiate SCONE, and as such merely repeats an information already contained in the transport parameters and accessible by deep packet inspection in the Initial packets, which means the privacy impact is minimal.\r\n\r\nI left a comment in the \"migrated flows\" section. We must be clear that applications MAY do that, but they don't have to. The new flows are hard to analyze by deep packet inspection. Network elements would not know whether the flow belongs to a SCONE capable connection. Providing the indication provides extra information to this network elements, and thus is a tradeoff between privacy and expected benefits.\r\n\r\nI do not see an analysis of how servers are supposed to react to indications. For example, if the Initial packets includes the SCONE TP, is the absence of indication an error? As we say that clients MUST include the indication, it would be logical to treat presence of SCONE TP + absence of indication as a protocol error. We may want to state that.\r\n\r\nWhat about the opposite, if the client first flight includes SCONE indication but does not carry the SCONE TP? I think the only reasonable behavior is for the servers to ignore that indication, because it might be the result of a random process. We should say that.",
          "createdAt": "2025-07-24T00:31:44Z",
          "updatedAt": "2025-07-24T00:46:22Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "If I read between the lines, this says that applications MAY send a SCONE packet on a new path, if they so chose, which they may not. But this reading between the lines is a bit ambiguous.\r\n\r\nI would rewrite the first two paragraphs as:\r\n\r\nApplications MAY decide to indicate support for SCONE on new flows. They cannot use the\r\nindicator to do that, but they can send a SCONE packet for the first few packets on a new path.\r\nThis would give network elements on that path the ability\r\nto recognize the flow as being able to receive throughput advice\r\nand also gives the network element an opportunity to provide that throughput advice.",
              "createdAt": "2025-07-24T00:31:44Z",
              "updatedAt": "2025-07-24T00:46:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86106R6",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the write up.",
          "createdAt": "2025-07-24T07:58:53Z",
          "updatedAt": "2025-07-24T08:15:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nA client that is using a QUIC version that includes length-delimited QUIC packets,\r\nwhich includes QUIC versions 1 {{QUIC}} and 2 {{!QUICv2=RFC9369}},\r\ncan include an indicator of SCONE support outside of the QUIC packet\r\n```",
              "createdAt": "2025-07-24T07:58:53Z",
              "updatedAt": "2025-07-24T08:15:17Z"
            },
            {
              "originalPosition": 58,
              "body": "Maybe it is a good idea to talk about NAT rebinding too.\r\n\r\nAlso, I think it would be better to state that the actor of sending these indications is the client; not the server.\r\n\r\n```suggestion\r\nBy sending a SCONE packet for the first few packets on a new path, clients\r\ngives network elements on that path the ability\r\nto recognize the flow as being able to receive throughput advice\r\nand also gives the network element an opportunity to provide that throughput advice.\r\n\r\nClients might also send send SCONE packets for the few packets after quiescence,\r\nas the tuple observed by network elements might have changed due to NAT rebinding.\r\n\r\n```",
              "createdAt": "2025-07-24T08:13:45Z",
              "updatedAt": "2025-07-24T08:15:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862ePB8",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T09:03:12Z",
          "updatedAt": "2025-07-28T09:03:12Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "SCONE packets are also QUIC packets, so that doesn't work.\r\n\r\nThough I agree that the use of packet protection isn't ideal.",
              "createdAt": "2025-07-28T09:03:12Z",
              "updatedAt": "2025-07-28T09:03:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862ebm9",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-28T09:12:19Z",
          "updatedAt": "2025-07-28T09:12:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I'm not sure that we need to talk about NAT rebinding.  I think that our (upcoming) advice on when to add SCONE packets will help that.  That is, we'll provide more general advice to invite updated signals after a period of idleness, in addition to other triggers.",
              "createdAt": "2025-07-28T09:12:19Z",
              "updatedAt": "2025-07-28T09:12:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862nRqm",
          "commit": {
            "abbreviatedOid": "fae13e1"
          },
          "author": "martinduke",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "From the standpoint of an endpoint, I find this PR to be unobjectionable. As Christian says, this is just externalizes the content of a transport parameter, which is readable unless the TPs are included in an ECH. If the operators can do something useful with these two bytes, then it SGTM.",
          "createdAt": "2025-07-28T16:45:02Z",
          "updatedAt": "2025-07-28T16:47:07Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "The client is unaware of NAT rebinding, no?",
              "createdAt": "2025-07-28T16:45:02Z",
              "updatedAt": "2025-07-28T16:47:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862skmd",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-29T03:03:50Z",
          "updatedAt": "2025-07-29T03:03:51Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Kazuho was suggesting that clients play the odds and add a SCONE packet if the connection has been idle long enough that a NAT rebinding is likely.  That's not a bad idea if your goal is to ensure that there is an indication on every flow, but I suspect that we'll get that coverage with more general advice about when to add a SCONE packet.",
              "createdAt": "2025-07-29T03:03:51Z",
              "updatedAt": "2025-07-29T03:03:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862s-PB",
          "commit": {
            "abbreviatedOid": "fae13e1"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-29T03:53:20Z",
          "updatedAt": "2025-07-29T03:53:20Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Thanks, my intention is what you have described, and I agree that it can be spelled out differently.",
              "createdAt": "2025-07-29T03:53:20Z",
              "updatedAt": "2025-07-29T03:53:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo8625aM_",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "martinduke",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-29T17:20:05Z",
          "updatedAt": "2025-07-29T17:20:05Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Fair enough; I imagine that SCONE network elements have timers too, so the after-idle advice is about much more than NATs.",
              "createdAt": "2025-07-29T17:20:05Z",
              "updatedAt": "2025-07-29T17:20:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863NAz_",
          "commit": {
            "abbreviatedOid": "fae13e1"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T23:54:05Z",
          "updatedAt": "2025-07-30T23:54:05Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Aside from what @huitema says, it might make sense to refer to the use of scone_supported TP (e.g., \"endpoints can exchange the scone_supported Transport Parameter and send a SCONE packet...\"), so that the text would not be misinterpreted as a permission to send SCONE packets without receiving the TP from the peer.",
              "createdAt": "2025-07-30T23:54:05Z",
              "updatedAt": "2025-07-30T23:54:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863OHnm",
          "commit": {
            "abbreviatedOid": "96a96ca"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-31T04:19:17Z",
          "updatedAt": "2025-07-31T04:19:17Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Good points both.  I've tweaked the text and added both.  Check it out.",
              "createdAt": "2025-07-31T04:19:17Z",
              "updatedAt": "2025-07-31T04:19:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863OJGc",
          "commit": {
            "abbreviatedOid": "81dae98"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-31T04:24:26Z",
          "updatedAt": "2025-07-31T04:24:51Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "This text works for me.",
              "createdAt": "2025-07-31T04:24:26Z",
              "updatedAt": "2025-07-31T04:24:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo863OP38",
          "commit": {
            "abbreviatedOid": "81dae98"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the tweaks. LGTM.",
          "createdAt": "2025-07-31T04:47:57Z",
          "updatedAt": "2025-07-31T04:47:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDON1dwo86gTBN8",
      "title": "Define the transport parameter",
      "url": "https://github.com/ietf-wg-scone/scone/pull/50",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Give it a value and a length (0).\r\n\r\nCloses #41.",
      "createdAt": "2025-07-23T15:52:22Z",
      "updatedAt": "2025-07-30T04:50:40Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "7a5c958cc37d32558ef6c37687d2749c6d00c048",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "tp-len",
      "headRefOid": "494eae2b7562cfd2884b4b49d3cf775f881adbab",
      "closedAt": "2025-07-28T08:45:51Z",
      "mergedAt": "2025-07-28T08:45:51Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "faf5431b1c6b9b54c0f7c31ea4d597058cd1f20b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861sHPh",
          "commit": {
            "abbreviatedOid": "494eae2"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-23T16:39:22Z",
          "updatedAt": "2025-07-23T16:39:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo861vhpI",
          "commit": {
            "abbreviatedOid": "494eae2"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yes. Empty TP is the simplest design.",
          "createdAt": "2025-07-23T21:36:51Z",
          "updatedAt": "2025-07-23T21:36:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo861__IJ",
          "commit": {
            "abbreviatedOid": "494eae2"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-24T21:48:00Z",
          "updatedAt": "2025-07-24T21:48:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDON1dwo86gTJUk",
      "title": "Define version numbers",
      "url": "https://github.com/ietf-wg-scone/scone/pull/51",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #45.",
      "createdAt": "2025-07-23T16:04:45Z",
      "updatedAt": "2025-07-30T07:15:56Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "7a5c958cc37d32558ef6c37687d2749c6d00c048",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "define-versions",
      "headRefOid": "4ef39186f17399447683cae3a0712e6f286c1c85",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861shcR",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-23T17:12:50Z",
          "updatedAt": "2025-07-23T17:12:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo861s4gn",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-07-23T17:48:35Z",
          "updatedAt": "2025-07-23T17:48:40Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I think we want to use the 7-bit field to represent a value that can be generated by shifting an integer, and that means that the MSB of the QUIC version conveys the LSB of the rate signal.\r\n\r\nBut the proposed text uses the MSB of the QUIC version field to convey the MSB of the rate signal.",
              "createdAt": "2025-07-23T17:48:35Z",
              "updatedAt": "2025-07-23T17:48:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862IRZJ",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-25T14:24:13Z",
          "updatedAt": "2025-07-25T14:24:13Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I think it's fine to use the MSB of QUIC version field to convey the MSB of the signal. It allows us to keep the spec as is, which is clear and easy to read.\r\nIt's still possible to construct and retrieve the signal and version with a shift and an addition. ",
              "createdAt": "2025-07-25T14:24:13Z",
              "updatedAt": "2025-07-25T14:24:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862-bQN",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T04:02:04Z",
          "updatedAt": "2025-07-30T04:02:04Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "@kazuho, changing the setup to be the LSB is possible, if you want to propose a change like that.  We can do this in stages.  But @ihlar's point is reasonable.  The difference is pretty minor.",
              "createdAt": "2025-07-30T04:02:04Z",
              "updatedAt": "2025-07-30T04:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862_bX5",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T06:33:34Z",
          "updatedAt": "2025-07-30T06:33:34Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Yeah let me give it a try. I think that specification-wise, the complexity would be the same, while by using the version field to carry LSB instead of MSB, we get the following benefits:\r\n* contiguous 7-bit field for carrying a log value without bit swaps,\r\n* use of two versions across the spectrum (as opposed to 0xSCONE1 essentially indicating the existence of rate limiters).",
              "createdAt": "2025-07-30T06:33:34Z",
              "updatedAt": "2025-07-30T07:16:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo862_2Lf",
          "commit": {
            "abbreviatedOid": "4ef3918"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-30T07:15:56Z",
          "updatedAt": "2025-07-30T07:15:56Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "PTAL: https://github.com/ietf-wg-scone/scone/pull/54/files",
              "createdAt": "2025-07-30T07:15:56Z",
              "updatedAt": "2025-07-30T07:15:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDON1dwo86gTO1A",
      "title": "Update the UDP checksum",
      "url": "https://github.com/ietf-wg-scone/scone/pull/52",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This might seem obvious to some of us, but it's an easy thing to overlook when implementing.\r\n\r\nI don't want to mention the all-zero UDP checksum thing.  I'm sure that anyone looking into this will discover that and be able to reach their own conclusions about how feasible that is.\r\n\r\nCloses #42.",
      "createdAt": "2025-07-23T16:14:27Z",
      "updatedAt": "2025-07-28T08:35:44Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "7a5c958cc37d32558ef6c37687d2749c6d00c048",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "checksum-update",
      "headRefOid": "3af621a3fb302256741a4cb1824a38ba7e1b4afa",
      "closedAt": "2025-07-28T08:35:44Z",
      "mergedAt": "2025-07-28T08:35:44Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "7e7e0c67790438cc071de3bf1607a214af62bb4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo861vqfi",
          "commit": {
            "abbreviatedOid": "3af621a"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-23T21:47:28Z",
          "updatedAt": "2025-07-23T21:47:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDON1dwo86gm2On",
      "title": "Handle DSCP markings",
      "url": "https://github.com/ietf-wg-scone/scone/pull/53",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #27.  Not directly, but this is the only thing that I think was relevant from that issue.",
      "createdAt": "2025-07-25T10:26:28Z",
      "updatedAt": "2025-07-28T08:47:22Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "7a5c958cc37d32558ef6c37687d2749c6d00c048",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "dscp-is-weird",
      "headRefOid": "1076fd3dd714604593d11c605d1083a4d87cc297",
      "closedAt": "2025-07-28T08:47:22Z",
      "mergedAt": "2025-07-28T08:47:22Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "5df97596fa6047432a605985af2177994955efe8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo862LYxB",
          "commit": {
            "abbreviatedOid": "1076fd3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "That's enough said indeed.",
          "createdAt": "2025-07-25T18:29:47Z",
          "updatedAt": "2025-07-25T18:29:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDON1dwo86hTKTy",
      "title": "MSB of version is LSB of the rate signal",
      "url": "https://github.com/ietf-wg-scone/scone/pull/54",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is against #51, uses MSB of the version field to carry the LSB of the rate signal, so that the bit 2 to bit 8 of the first 64-bit field carries a rate signal, which is calculated by using a logarithmic function without bit swaps or any other complexity.",
      "createdAt": "2025-07-30T07:15:17Z",
      "updatedAt": "2025-07-30T09:31:05Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "define-versions",
      "baseRefOid": "4ef39186f17399447683cae3a0712e6f286c1c85",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/7bit-contiguous-rate",
      "headRefOid": "927b5e3303438289f9a0c844224113ab40862529",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo863BfXP",
          "commit": {
            "abbreviatedOid": "927b5e3"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't mind either way on this one, though I will note that this is in some ways *simpler* than before (so consider this an approval).\r\n\r\nTo validate this, the code starts looking pretty lean:\r\n\r\n```rust\r\n        // Setup involves math\r\n        let v = (((target_rate / 100_000.0).log10() * 20.0) as u64).clamp(0, 63);\r\n        let target_value = (0x106f << 48) | (v << 61);\r\n\r\n        // updates\r\n        let x = u64::from_be_bytes(packet.first_chunk().unwrap().to_owned());\r\n        if (x & 0x807f_ffff_ff00_0000) == 0x106f_7dc0_fd00_0000\r\n            && target_value < (x & 0xbfff_0000_0000_0000)\r\n        {\r\n            packet[0] = (packet[0] & 0x40) | (target_value >> 56) as u8;\r\n            packet[1] = (target_value >> 48) as u8;\r\n        }\r\n```",
          "createdAt": "2025-07-30T09:31:05Z",
          "updatedAt": "2025-07-30T09:31:05Z",
          "comments": []
        }
      ]
    }
  ]
}